<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/java/</link>
    <description>Recent content in Java on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Feb 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://engineering.facile.it/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using Kotlin type-safe builders to create a DSL for Forms</title>
      <link>https://engineering.facile.it/blog/eng/kotlin-dsl/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/kotlin-dsl/</guid>
      <description>

&lt;p&gt;Here at Facile.it we are constantly dealing with a lot of &lt;strong&gt;forms&lt;/strong&gt;: we use them to collect various information and data needed to feed our in-house comparing algorithms. These forms could be &lt;strong&gt;really complex&lt;/strong&gt;, having multiple rules and dependencies between fields, and they are likely to be &lt;strong&gt;changed and tuned frequently&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When I joined Facile.it, a lot of forms within the Android app needed to be updated or modified and sticking with the existing strategy would have required me to do &lt;strong&gt;a lot of work&lt;/strong&gt; just to add or remove a simple field. So I took a step back and I started thinking about a strategy that would have allowed me to define and structure a form in a more &lt;em&gt;flexible&lt;/em&gt; and &lt;em&gt;declarative&lt;/em&gt; way. I wanted to be able to declare the &lt;strong&gt;relationships&lt;/strong&gt; between fields, their &lt;strong&gt;validation rules&lt;/strong&gt; and their &lt;strong&gt;serialized representation&lt;/strong&gt; (how they are sent to the server).&lt;/p&gt;

&lt;p&gt;I firstly thought about defining it using some configuration file, maybe written in JSON or YAML. The &lt;em&gt;problem&lt;/em&gt; with this strategy was that it would also have required me to write a lot code to parse and validate those files to be able to create some sort of representation of the form in Java&amp;hellip;but don&amp;rsquo;t we already have the compiler for this kind of jobs?&lt;/p&gt;

&lt;p&gt;I still wanted to be able to have both a &lt;strong&gt;human readable representation&lt;/strong&gt; of the form and the right degree of &lt;strong&gt;flexibility&lt;/strong&gt; to integrate the form definition into the app code.
So I thought that creating a &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-specific_language&#34;&gt;Domain-Specific Language&lt;/a&gt; would have been a perfect strategy to solve the problem in an elegant and efficient way.
Writing a DSL in Java could have ended up into something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Form.create()
    .openSection(sectionId)
    .field(key1, &amp;quot;label1&amp;quot;, style, ...) 
    .field(key2, &amp;quot;label2&amp;quot;, style, ...) 
    .field(key3, &amp;quot;label3&amp;quot;, style, ...) 
    .closeSection()
    ...
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t think the previous code is readable nor flexible and it requires a lot of boilerplate to be written.&lt;/p&gt;

&lt;h2 id=&#34;kotlin-to-the-rescue&#34;&gt;Kotlin to the rescue!&lt;/h2&gt;

&lt;p&gt;Unlike Java, Kotlin (take a look at my &lt;a href=&#34;https://engineering.facile.it/blog/eng/kotlin-intro/&#34;&gt;previous post&lt;/a&gt; about it) has a lot of features that makes it really powerful when it comes to write internal DSLs. The results are very similar to Groovy (think about a Gradle file) but thanks to its type system they could be &lt;a href=&#34;https://kotlinlang.org/docs/reference/type-safe-builders.html#type-safe-builders&#34;&gt;Type-Safe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The builders you can write with Kotlin are extremely readable and easy to understand even for people that don&amp;rsquo;t know either the language or the DSL itself. Here&amp;rsquo;s how a form built using my final DSL looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val FORM = form {
    page(&amp;quot;Page 1 Title&amp;quot;) {
        section(&amp;quot;Section 1 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey1&amp;quot;) {
                checkbox(&amp;quot;Checkbox Field Label&amp;quot;) {
                    boolToStringConverter = { if (it == true) &amp;quot;Yes&amp;quot; else &amp;quot;No&amp;quot; }
                    rules = { listOf(NotMissing()) }
                }
            }
            field(key = &amp;quot;fieldKey2&amp;quot;) {
                picker(&amp;quot;Picker Field Label&amp;quot;) {
                    placeHolder = &amp;quot;Select a value&amp;quot;
                    possibleValues = Available(listOf(
                            1 keyTo &amp;quot;Value1&amp;quot;,
                            2 keyTo &amp;quot;Value2&amp;quot;,
                            3 keyTo &amp;quot;Value3&amp;quot;))
                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE
                }
            }
        }
        section(&amp;quot;Section 2 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey3&amp;quot;) {
                picker(&amp;quot;Picker Field Label&amp;quot;) {
                    placeHolder = &amp;quot;Select a value&amp;quot;
                    possibleValues = ToBeRetrieved(someWebService.getValues())
                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE
                }
            }
            field(key = &amp;quot;fieldKey4&amp;quot;) {
                input(&amp;quot;Input Text Field Label&amp;quot;) {
                    inputTextType = InputTextType.EMAIL
                    rules = { listOf(IsEmail()) }
                }
            }
            field(key = &amp;quot;fieldKey&amp;quot;) {
				        empty(&amp;quot;Empty Field&amp;quot;)
            }
        }
		    section(&amp;quot;Section 3 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey6&amp;quot;) {
                toggle(&amp;quot;Toggle Field Label&amp;quot;) {
                    boolToStringConverter = { if (it == true) &amp;quot;OK&amp;quot; else &amp;quot;KO&amp;quot; }
                    rules = { listOf(NotMissing()) }
                    representation = ALWAYS representAs SIMPLE_KEY_TO_VALUE
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is the result on Android using my &lt;a href=&#34;https://github.com/brescia123/forms&#34;&gt;Form library&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/kotlin-dsl/form_screen.png&#34; alt=&#34;Form screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cool, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;type-safe-builders&#34;&gt;Type-safe builders&lt;/h2&gt;

&lt;h3 id=&#34;some-kotlin-important-features&#34;&gt;Some Kotlin important features&lt;/h3&gt;

&lt;p&gt;To grasp how Type-safe builders work in Kotlin we need to understand some key Kotlin features and how they can be combined together:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Higher-Order Functions and Lambdas&lt;/strong&gt;: in Kotlin we are allowed to write functions that have &lt;em&gt;functions as parameters or return type&lt;/em&gt; (higher-order functions) and functions that are &lt;em&gt;not declared&lt;/em&gt;, but are passed immediately as an expression (lambdas). Because of this, we can write things like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Higher-Order Function
fun transformWith(path: String, function: (String) -&amp;gt; List&amp;lt;String&amp;gt;): List&amp;lt;String&amp;gt; {
    return function(this)
}

// Lambda
{ path: String -&amp;gt; path.split(&amp;quot;/&amp;quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to Kotlin syntactic sugar we can use them in these ways:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;transformWith(&amp;quot;some/path/to&amp;quot;, { path: String -&amp;gt; path.split(&amp;quot;/&amp;quot;) }) // -&amp;gt; [some, path, to]

// Functions which have a function as the last parameter can be written as follow
transformWith(&amp;quot;some/path/to&amp;quot;) { path -&amp;gt; path.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]

// If the lambda has only one parameter it can be ommitted and referenced as &amp;quot;it&amp;quot;
transformWith(&amp;quot;some/path/to&amp;quot;) { it.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Extension Functions&lt;/strong&gt;: they allow us to &lt;em&gt;extend&lt;/em&gt; a type with functions without modifying the original class. They are useful to add functionalities to classes we don&amp;rsquo;t have control on or to create utility methods without the need to create &amp;ldquo;Utils classes&amp;rdquo; that contains static methods, as we are used to as Java developers. To continue the previous example we can write:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Extension function
fun String.transformWith(function: (String) -&amp;gt; List&amp;lt;String&amp;gt;) {
    return function(this)
}

&amp;quot;some/path/to&amp;quot;.transformWith { receiverString: String -&amp;gt; receiverString(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]

// or more concisely 
&amp;quot;some/path/to&amp;quot;.transformWith { it.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we are referring to the string inside the closure of the extension function using &lt;code&gt;this&lt;/code&gt; as it will be the String object on which the method will be called.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Function Literals with Receiver&lt;/strong&gt;: similarly to extension functions you are also allowed to define functions with a receiver that will be referred to as &lt;code&gt;this&lt;/code&gt; inside the literal closure:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;val transformWith: String.() -&amp;gt; List&amp;lt;String&amp;gt; = { this.split(&amp;quot;/&amp;quot;) }

&amp;quot;some/path/to&amp;quot;.transformWith() // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To better understand function literals with receiver you should think of them as follow: &lt;em&gt;lambda is to normal function as function literal with receiver is to extension function&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// lambda
{ s: String -&amp;gt; s.split(&amp;quot;/&amp;quot;) }
// is to
fun function(s: String): List&amp;lt;String&amp;gt; { return s.split(&amp;quot;/&amp;quot;) }
// as
val functionLiteralWithReceiver = String.() -&amp;gt; List&amp;lt;String&amp;gt; = { this.split(&amp;quot;/&amp;quot;) }
// is to
fun String.extensionFunction(): List&amp;lt;String&amp;gt; { return function(this) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically function literals with receiver are extension functions that can be passed to other functions.&lt;/p&gt;

&lt;h3 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;Now we have all the elements required to understand and write a Type-safe builder.&lt;/p&gt;

&lt;p&gt;Combining the above mentioned Kotlin features we can now write a function and name it &lt;code&gt;form&lt;/code&gt;. This function will take as parameter a function literal with receiver usually called &lt;code&gt;init()&lt;/code&gt; and will do the follow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create a new Form object&lt;/li&gt;
&lt;li&gt;call &lt;code&gt;init()&lt;/code&gt; on it (that is using it as the receiver of the function literal)&lt;/li&gt;
&lt;li&gt;return the built object to the caller&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun form(init: Form.() -&amp;gt; Unit): Form {
    val form = Form() 
    form.init()
    return form
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s imagine that our Form class defines a function &lt;code&gt;field()&lt;/code&gt; that actually creates a field object and adds it to the list of fields contained within the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Form() {
    val fields: List&amp;lt;Field&amp;gt;
    ...
    fun field(key: String) { ... }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Taking advantage of Kotlin syntactic sugar we can use &lt;code&gt;form()&lt;/code&gt; passing it the &lt;code&gt;init()&lt;/code&gt; function as a lambda and call methods on the Form object to build it as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val builtForm = form() {
    // Here we can take advantage of the compiler and, as a result, of the IDE code completion
    field(&amp;quot;key1&amp;quot;) // == this.field(&amp;quot;key1&amp;quot;) where this is the object create by form()
    field(&amp;quot;key2&amp;quot;)
}
builtForm.getFields() // -&amp;gt; [Field(&amp;quot;key1&amp;quot;), Field(&amp;quot;key2&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see Type-Safe builders are an &lt;strong&gt;extremely powerful&lt;/strong&gt; and useful feature of Kotlin and they allow you to write very complex DSLs with a &lt;strong&gt;really readable and clear syntax&lt;/strong&gt;. They give you a lot of &lt;strong&gt;flexibility&lt;/strong&gt; letting you combine multiple builders to create a domain language that can meet your requirements.&lt;/p&gt;

&lt;p&gt;If you want to learn more about this subject check out the official &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;documentation&lt;/a&gt; or, for example, &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;kotlinx&lt;/a&gt;, an official project from the Kotlin team that allows you to create HTML documents with a custom DSL entirely written with Type-safe builders.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A new hope for the JVM: Kotlin</title>
      <link>https://engineering.facile.it/blog/eng/kotlin-intro/</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/kotlin-intro/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/kotlin-intro/logo_Kotlin.svg&#34; alt=&#34;Kotlin&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;premise&#34;&gt;Premise&lt;/h2&gt;

&lt;p&gt;Java is an &lt;strong&gt;old&lt;/strong&gt; programming language. Version 1.0 was released in 1996 by Sun Microsystems and  even though it has evolved and grown a lot over the past twenty years it is still carrying on some bad design choices such as &lt;em&gt;null&lt;/em&gt; (ask &lt;a href=&#34;https://en.wikipedia.org/wiki/Tony_Hoare?section=3#Apologies_and_retractions&#34;&gt;Tony Hoare&lt;/a&gt;), primitive types or lack of a proper function type. With the last version of the language (Java 8) Java tried to address some of these problems introducing concepts such as &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&#34;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&#34;&gt;lambda expression&lt;/a&gt;. Although these additions clearly represent a step forward for the language I still have the feeling that they are just &lt;em&gt;patches&lt;/em&gt; applied to &lt;strong&gt;mitigate problems&lt;/strong&gt; and not to solve them at their very source. For example &lt;code&gt;Optional&lt;/code&gt; could be used to reduce NPE (Null Pointer Exception) but it is clearly not designed for &lt;a href=&#34;https://twitter.com/mariofusco/status/780770300178956289&#34;&gt;this purpose&lt;/a&gt; and lambda expressions, implemented in Java 8 with SAM types, still force you to write an interface only to define a &lt;em&gt;function&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-android-world&#34;&gt;The Android world&lt;/h2&gt;

&lt;p&gt;All the above concerns about Java are even more problematic within the Android world where, due to the notorious &lt;a href=&#34;https://developer.android.com/about/dashboards/index.html&#34;&gt;fragmentation&lt;/a&gt; (a huge amount of devices are stuck with an &lt;strong&gt;outdated VM&lt;/strong&gt;), you are forced to target lower Java versions (6 and 7).
Google is addressing the problem with its new compiler &lt;a href=&#34;https://source.android.com/source/jack.html&#34;&gt;Jack&lt;/a&gt; that enables &lt;em&gt;some&lt;/em&gt; of the features of Java 8 maintaining backward compatibility with older OS versions. But still it lets us deal with the verbosity of the language and it doesn’t truly solve the problem.&lt;/p&gt;

&lt;h2 id=&#34;a-new-hope&#34;&gt;A new hope&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/kotlin-intro/kotlin_helloworld.png&#34; alt=&#34;Kotlin Hello World!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Back in 2011 the JetBrains team (the guys behind IntelliJ and so Android Studio) unveiled &lt;a href=&#34;https://kotlinlang.org/&#34;&gt;Kotlin&lt;/a&gt;, a new programming language that targets the JVM (and can also be compiled to JavaScript).
Kotlin is a statically-typed language that combines Object Oriented and functional features enforcing no particular philosophy of programming, and it introduces a whole new set of concepts and tools that helps making the code &lt;strong&gt;safer, cleaner and much more readable&lt;/strong&gt;.
Thanks to its nature it works everywhere Java do and it is also &lt;strong&gt;interoperable&lt;/strong&gt; with it, meaning it will not force you to rewrite the entire codebase to taste it: you can add it to your project a little at a time (&lt;a href=&#34;https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776#.lyvd3h43x&#34;&gt;maybe starting with tests&lt;/a&gt; 😉). It also features a REPL &lt;code&gt;kotlinc-jvm&lt;/code&gt; that allows you to test language features with no effort (see the &lt;a href=&#34;https://kotlinlang.org/docs/tutorials/command-line.html#running-the-repl&#34;&gt;doc&lt;/a&gt; form more info).
I am going to rapidly cover some features of Kotlin that address the previously mentioned Java limitations.&lt;/p&gt;

&lt;h3 id=&#34;null-safety&#34;&gt;Null-safety&lt;/h3&gt;

&lt;p&gt;In Kotlin &lt;strong&gt;a variable cannot be null&lt;/strong&gt;. If you want or need a variable to be &lt;em&gt;nullable&lt;/em&gt; you have to add &lt;code&gt;?&lt;/code&gt; to the variable type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val x: Int = null // compile error
val y: Int? = null // ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to this information the compiler sees &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Int?&lt;/code&gt; as two completely different types and can therefore enforce the &lt;a href=&#34;http://kotlinlang.org/docs/reference/null-safety.html&#34;&gt;null-safety&lt;/a&gt; of your variables.
The &lt;code&gt;?.&lt;/code&gt; allows you to safe call methods on nullable variables without throwing NPE but simply returning null at the end of the  call chain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val x: Int? = null
x?.toString()?.substring(2) // no NPE, returns null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;?:&lt;/code&gt; operator (Elvis operator) allows you to provide a “default” value when the variable is &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// The two expressions are semantically equivalent:
text?.length ?: -1
(text.length != null) ? text.length  : -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;higher-order-functions-and-lambdas&#34;&gt;Higher-Order Functions and Lambdas&lt;/h3&gt;

&lt;p&gt;In Kotlin is possible to declare a method (or more generally a function) that returns or takes another &lt;strong&gt;function as parameter&lt;/strong&gt;. The syntax to define the &lt;a href=&#34;https://kotlinlang.org/docs/reference/lambdas.html&#34;&gt;function type&lt;/a&gt; is similar to other languages such as Scala or Swift and is very &lt;strong&gt;intuitive&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val function: (T1, T2) -&amp;gt; R = {t1, t2 -&amp;gt; r}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;data-classes&#34;&gt;Data classes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class City(val name: String, val state: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://kotlinlang.org/docs/reference/data-classes.html&#34;&gt;Data classes&lt;/a&gt; address the verbosity of Java when dealing with classes that have the only purpose to hold data. With a single line you get &lt;code&gt;equals()/hashCode()&lt;/code&gt;, &lt;code&gt;toString()&lt;/code&gt; and getters/setters for free (and if you are a Java developer you already knows the benefits!)&lt;/p&gt;

&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;Java has to maintain backward compatibility with previous versions and still has to support the huge amount of developers and codebases present all around the world; therefore it is natural that every new feature and design change is to be considered, weighted and reasoned really carefully, inevitably &lt;strong&gt;slowing down its evolution&lt;/strong&gt;. But this does not have to mean that us, as Android developers, “tied” to the JVM, should not try more modern and advanced languages such as Kotlin. At bottom, a part of our job (one of the best!) is to try and &lt;strong&gt;experiment&lt;/strong&gt; new technologies and to &lt;strong&gt;learn&lt;/strong&gt; new concepts and techniques that improve our ability to address problems in the best possible way (and of course, to have some fun 😄).&lt;/p&gt;

&lt;p&gt;I think that it is fundamental for a software engineer to be &lt;strong&gt;exposed to more than a single programming language&lt;/strong&gt;: learning new patterns, exploring other programming paradigms or simply using and understanding a never-seen syntax has an immeasurable value for our growth and most of the times it turns out to be unexpectedly useful even when coding with ”our” language.
So why not do it with a language that allows us to continue working on projects targeting our beloved JVM?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>