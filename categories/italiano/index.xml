<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Italiano on Facile Engineering</title>
    <link>/categories/italiano/</link>
    <description>Recent content in Italiano on Facile Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/italiano/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Puli: Universal Packages for PHP</title>
      <link>/blog/ita/puli-universal-packages-for-php/</link>
      <pubDate>Tue, 15 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/puli-universal-packages-for-php/</guid>
      <description>

&lt;h2 id=&#34;composer-e-l-ecosistema-php:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Composer e l&amp;rsquo;ecosistema PHP&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;ecosistema PHP è notevolmente cambiato negli ultimi anni grazie all&amp;rsquo;introduzione di &lt;em&gt;Composer&lt;/em&gt;.
Esso ha definito degli standard per risolvere problemi comuni come l&amp;rsquo;autoloading e la gestione di pacchetti e dipendenze.
In questi ultimi anni si è assistito ad un proliferare di numerose componenti software riusabili che hanno significativamente modificato le strategie di sviluppo.&lt;/p&gt;

&lt;p&gt;Nonostante Composer si sia evoluto molto, in alcuni contesti le sue funzionalità risultano essere limitanti e incomplete.
I framework e i pacchetti più complessi hanno bisogno di una gestione personalizzata delle dipendenze. Generalmente sono necessarie operazioni di configurazione e registrazione. Ciò è specialmente vero per pacchetti core dei framework come i &lt;em&gt;template engines&lt;/em&gt;.
Composer, inoltre, possiede una cattiva gestione delle risorse non PHP. I file di configurazione devono essere gestiti manualmente oppure è necessario adottare standard strettamente legati a ciascun framework.&lt;/p&gt;

&lt;h2 id=&#34;la-soluzione-puli:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;La soluzione: Puli&lt;/h2&gt;

&lt;p&gt;A partire dal gennaio 2014 è stato sviluppato &lt;strong&gt;Puli, Universal Packages for PHP&lt;/strong&gt;, da Bernhard Schussek.
Puli mira a risolvere i problemi d&amp;rsquo;integrazione menzionati in precedenza creando un &lt;strong&gt;layer d&amp;rsquo;astrazione aggiuntivo tra Composer e l&amp;rsquo;applicazione&lt;/strong&gt;. Tale layer consente di gestire le risorse secondo convenzioni indipendenti dai framework. Ciò significa che Puli può essere usato anche dalle applicazioni che non ne fanno uso.
Attualmente Puli è in Beta, la versione stabile non è stata ancora annunciata ma è prevista per l&amp;rsquo;inizio del 2016.
&lt;strong&gt;Puli è stato ideato per affiancare Composer&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Puli lavora ad un livello più alto per fornire le seguenti funzionalità:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#puli-path&#34;&gt;Gestione dei path virtuali per risorse non PHP&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#override-puli-path&#34;&gt;Overriding dei path virtuali&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#binding-type&#34;&gt;Interazione semplificata dei pacchetti con l&amp;rsquo;uso di Binding Type&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#url-generation&#34;&gt;Generazione automatica di URL per risorse pubbliche&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#assets-install&#34;&gt;Installazione automatica delle risorse pubbliche nelle document root&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;le-componenti-di-puli:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Le componenti di Puli&lt;/h2&gt;

&lt;p&gt;Puli offre svariate funzionalità organizzate nei seguenti componenti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Resource repository&lt;/li&gt;
&lt;li&gt;Discovery service&lt;/li&gt;
&lt;li&gt;Public resources manager&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;configurazione:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Configurazione&lt;/h3&gt;

&lt;p&gt;Nell&amp;rsquo;offire questi servizi, Puli legge e scrive un proprio file di configurazione &lt;code&gt;puli.json&lt;/code&gt; presente nella root directory del pacchetto, allo stesso modo del &lt;code&gt;composer.json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Tale configurazione può essere modificata manualmente oppure utilizzando l&amp;rsquo;&lt;strong&gt;interfaccia CLI di Puli&lt;/strong&gt;;
Tale strumento può essere installato da Packagist tramite il pacchetto &lt;code&gt;puli/cli&lt;/code&gt;.
Al pari di Composer, sono disponibili archivi Phar per un uso immediato.&lt;/p&gt;

&lt;h3 id=&#34;installazione:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Installazione&lt;/h3&gt;

&lt;p&gt;Affiché le applicazioni possano usare i servizi offerti da Puli è necessario procedere all&amp;rsquo;installazione.
Per applicazioni che non fanno uso di framework è sufficiente abilitare il &lt;em&gt;Composer Plugin&lt;/em&gt; &lt;code&gt;puli/composer-plugin&lt;/code&gt;.
Quest&amp;rsquo;azione viene svolta da Composer con il comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ composer require puli/composer-plugin:^1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tale plugin consente di generare atomaticamente la cosiddetta &lt;strong&gt;Puli Factory Class&lt;/strong&gt;: componente chiave da cui è possibile accedere a tutti i servizi offerti da Puli.&lt;/p&gt;

&lt;p&gt;A questo punto è possibile usare Puli nel modo seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;require &#39;./vendor/autoload.php&#39;;

// La costante PULI_FACTORY_CLASS viene 
// definita al &amp;quot;composer install&amp;quot;
$factoryClass = PULI_FACTORY_CLASS;
$factory = new $factoryClass();

$puliRepository = $factory-&amp;gt;createRepository();
$puliDiscovery  = $factory-&amp;gt;createDiscovery($puliRepository);
$puliGenerator  = $factory-&amp;gt;createUrlGenerator($puliDiscovery);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;resource-repository:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Resource repository&lt;/h3&gt;

&lt;p&gt;Il resource repository fornisce un &lt;strong&gt;file system virtuale&lt;/strong&gt; per accedere alle risorse non PHP.
Ciò consente di localizzare facilmente i file senza conoscere la loro effettiva posizione.&lt;/p&gt;

&lt;h4 id=&#34;accesso-alle-risorse-con-composer:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Accesso alle risorse con Composer&lt;/h4&gt;

&lt;p&gt;Con Composer era frequente scrivere codice di questo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$translationFileName = realpath(__DIR__ . &#39;/../vendor/acme/blog/resources/translation-it.xml&#39;);
$translationContent = file_get_contents($translationFileName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tale operazione fa uso di dettagli implementativi: il layout delle directory fornito da Composer. La soluzione non è riusabile nè configurabile.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;puli-path&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;accesso-alle-risorse-con-puli:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Accesso alle risorse con Puli&lt;/h4&gt;

&lt;p&gt;Ciascun pacchetto compatibile con Puli può registrare diversi &lt;strong&gt;Path Mapping&lt;/strong&gt; utilizzati per tradurre i &lt;strong&gt;percorsi virtuali (Puli path)&lt;/strong&gt; in &lt;strong&gt;percorsi reali&lt;/strong&gt;.
Tali Path Mapping sono elencati nel &lt;code&gt;puli.json&lt;/code&gt; e normalmente sono modificati con il comando Puli CLI &lt;code&gt;map&lt;/code&gt;.
Ad esempio, il maintainer di acme/blog può eseguire questo comando per definire un nuovo mapping:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ puli map /acme/blog resources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tale operazione crea un&amp;rsquo;associazione tra il prefisso del path virtuale &lt;code&gt;/acme/blog&lt;/code&gt; e la directory &lt;code&gt;resources&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Un ipotetico utilizzatore del pacchetto acme/blog potrà quindi accedere alle risorse nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$puliPath = &#39;/acme/blog/translation-it.xml&#39;;
$translationContent = $puliRepository-&amp;gt;get($puliPath)-&amp;gt;getBody();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;È importante notare come i Path mapping siano definiti dal maintainer del pacchetto. Le altre componenti si limitano ad usarli per accedere alle risorse.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;override-puli-path&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;resource-overriding:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Resource overriding&lt;/h4&gt;

&lt;p&gt;È tuttavia presente un&amp;rsquo;eccezione a questa regola, tale concetto è alla base del &lt;strong&gt;Resource overriding&lt;/strong&gt;.
Immaginiamo di dover lavorare con due pacchetti: A e B.
Il pacchetto B è dipendente dal pacchetto A.
B, tuttavia, vuole personalizzare alcune risorse fornite da A.
Il maintainer di B può quindi rimpiazzare (&lt;em&gt;override&lt;/em&gt;) tali risorse aggiungengo nuovi Path Mapping.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;binding-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;discovery-service:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Discovery service&lt;/h3&gt;

&lt;p&gt;Il componente discovery semplifica l&amp;rsquo;interazione tra pacchetti: consente di condividere le risorse senza codice boilerplate attraverso l&amp;rsquo;uso di &lt;strong&gt;Binding Type&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Per il componente Discovery i pacchetti sono siddivisi in due categorie:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Resource providers&lt;/strong&gt;: pacchetti che offrono risorse;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resource consumers&lt;/strong&gt;: pacchetti che richiedono risorse.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I Binding Types sono definiti dai resource consumers. Ciascun Binding Type è idendificato da un nome (es. &lt;code&gt;acme/translator/messages&lt;/code&gt;).
I resource providers possono quindi associare una o più risorse a tali Binding Type.
&lt;strong&gt;L&amp;rsquo;associazione avviene legando un Puli Path ad un Binding Type&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;I &lt;em&gt;Binding Type&lt;/em&gt; sono quindi un&amp;rsquo;interfaccia per la condivisione di risorse.&lt;/p&gt;

&lt;h4 id=&#34;esempio:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Esempio&lt;/h4&gt;

&lt;p&gt;Esaminiamo, con un esempio, l&amp;rsquo;interazione tra due pacchetti: &lt;code&gt;acme/md2html&lt;/code&gt; e &lt;code&gt;acme/blog&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acme/md2html&lt;/code&gt; è un componente per tradurre contenuto Markdown verso pagine Html. Md2html è un sistema configurabile: la resa dell&amp;rsquo;output avviene attraverso template Twig modificabili.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acme/blog&lt;/code&gt; fornisce tools per la gestione di articoli da blog. Siccome questi ultimi possono essere scritti in Markdown, &lt;code&gt;acme/blog&lt;/code&gt; fa uso di &lt;code&gt;acme/md2html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Il componente &lt;code&gt;acme/blog&lt;/code&gt; può personalizzare i template di Md2html in questo modo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$md2html = new Md2Html();
$md2html-&amp;gt;useHeaderTemplate(__DIR__ . &#39;/resources/templates/markdown-header.twig&#39;);

$htmlContent = $md2html-&amp;gt;translate(&#39;## markdown content&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Questo approccio ha due svantaggi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;acme/blog&lt;/code&gt; ha la diretta responsabilità di configurare correttamente Md2html utilizzando l&amp;rsquo;API fornita;&lt;/li&gt;
&lt;li&gt;Gli utenti di &lt;code&gt;acme/blog&lt;/code&gt; non possono modificare facilmente le personalizzazioni apportate a Md2html.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tali problemi possono essere risolti con Puli.&lt;/p&gt;

&lt;p&gt;Il mantainer di Md2html decide di rendere il suo pacchetto compatibile con Puli.&lt;/p&gt;

&lt;p&gt;Definisce quindi il Binding Type: &lt;code&gt;acme/md2html/header-template&lt;/code&gt; con il seguente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ puli type --define acme/md2html/header-template
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il maintainer di &lt;code&gt;acme/blog&lt;/code&gt; può quindi usare tale Binding Type nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ puli map /acme/blog resources
$ puli bind /acme/blog/templates/markdown-header.twig acme/md2html/header-template
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Così &lt;code&gt;acme/md2html&lt;/code&gt; può leggere il nuovo template &lt;code&gt;markdown-header.twig&lt;/code&gt; in modo trasparente.&lt;/p&gt;

&lt;p&gt;Gli utilizzatori di acme/blog che desiderassero modificare tale template hanno due strategie:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Modificare l&amp;rsquo;associazione al Binding Type &lt;code&gt;acme/md2html/header-template&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Sovrascrivere il Puli Path &lt;code&gt;/acme/blog/templates/markdown-header.twig&lt;/code&gt; con il meccanismo dell&amp;rsquo;overriding esaminato in precedenza.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;url-generation&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;public-resources-manager:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Public resources manager&lt;/h3&gt;

&lt;p&gt;Puli gestisce anche le risorse pubbliche, gli assets. In particolare, è in grado di generare path e URL da usare nei template o nei fogli di stile.&lt;/p&gt;

&lt;p&gt;Come primo passo, è necessario &lt;strong&gt;registrare i server web che servono tali risorse&lt;/strong&gt;.
È possibile aggiungere un nuovo server con il comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ puli server --add localhost public_html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo esempio, &lt;code&gt;localhost&lt;/code&gt; è il nome del server, mentre &lt;code&gt;public_html&lt;/code&gt; è la sua &lt;em&gt;document root&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ora è possibile pubblicare delle risorse sul server &lt;code&gt;localhost&lt;/code&gt; con il comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ puli publish /acme/blog/public localhost /blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ciò mappa il Puli Path &lt;code&gt;/acme/blog/public&lt;/code&gt; alla directory &lt;code&gt;blog&lt;/code&gt; della document root del server &lt;code&gt;localhost&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Puli ora ha tutte le informazioni per generare i persorsi delle risorse pubbliche:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$puliPath = &#39;/acme/blog/public/images/logo.png&#39;;
$url = $puliGenerator-&amp;gt;generateUrl($puliPath);
echo $url; // -&amp;gt; &amp;quot;/blog/images/logo.png&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;ultima operazione può essere eseguita in un template Twig con l&amp;rsquo;utilizzo dell&amp;rsquo;estensione &lt;code&gt;puli/twig-extension&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-twig&#34;&gt;&amp;lt;img src=&amp;quot;{{ resource_url(&#39;/acme/blog/public/images/logo.png&#39;) }}&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;assets-install&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;installazione-delle-risorse:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Installazione delle risorse&lt;/h4&gt;

&lt;p&gt;Puli può installare automaticamente le risorse pubbliche nella document root dei web server.&lt;/p&gt;

&lt;p&gt;Il comando è il seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ puli publish --install
Installing /acme/blog/public into public_html via symlink...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gli autori di Puli hanno annunciato che &lt;strong&gt;tale funzionalità sarà rimossa da Puli CLI in favore di estensioni Gulp o altri tool simili&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusioni:4e9f2019ea2ccadae6802f9a945a5d57&#34;&gt;Conclusioni&lt;/h3&gt;

&lt;p&gt;Abbiamo visto come Puli offra numerose funzionalità aggiuntive rispetto al solo utilizzo di Composer.
Puli è un progetto giovane, nel corso del tempo saranno aggiunte ulteriori funzionalità che lo renderanno ancora più potente.
Per approfondire, la documentazione ufficiale è molto chiara e completa ed è disponibile all&amp;rsquo;indirizzo: &lt;a href=&#34;http://docs.puli.io/&#34;&gt;http://docs.puli.io/&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Facile.it devs @ Codemotion Milan 2015</title>
      <link>/blog/ita/facile-it-devs-codemotion-milan-2015/</link>
      <pubDate>Thu, 26 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/facile-it-devs-codemotion-milan-2015/</guid>
      <description>

&lt;p&gt;L&amp;rsquo;appuntamento con il &lt;a href=&#34;http://milan2015.codemotionworld.com&#34;&gt;Codemotion&lt;/a&gt; di quest&amp;rsquo;anno a Milano è stato particolarmente &lt;strong&gt;ricco&lt;/strong&gt;: tante tracce, moltissimi contenuti suddivisi tra talk tecnici, workshop e keynote, e alcuni ospiti illustri, tra cui il celebre &lt;a href=&#34;https://twitter.com/rasmus&#34;&gt;Rasmus Lerdorf&lt;/a&gt;, creatore del linguaggio &lt;strong&gt;PHP&lt;/strong&gt;. Come già fatto per il &lt;a href=&#34;http://engineering.facile.it/php-day-2015/&#34;&gt;PHP Day 2015&lt;/a&gt;, proponiamo le nostre impressioni sulla conferenza, citando i talk che ci hanno colpito maggiormente: la scelta dei talk è basata sul gusto personale dei vari membri della redazione di Facile.it Engineering, e le considerazioni esposte non vanno lette come recensioni, ma come riflessioni di vario genere sulle tematiche trattate, volte a stimolare nei lettori l&amp;rsquo;interesse a &lt;strong&gt;partecipare&lt;/strong&gt; a conferenze come il Codemotion.&lt;/p&gt;

&lt;p&gt;I talk sono in ordine cronologico.&lt;/p&gt;

&lt;h2 id=&#34;indice:fd439f196c3125ae563b4be0e3399006&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#a-programmer-is&#34;&gt;A programmer is&amp;hellip;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tdd-per-android&#34;&gt;TDD per Android&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#platformer-2d&#34;&gt;Platformer 2D: jumping from XNA to Unity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#grocery-site-in-react&#34;&gt;Building the world&amp;rsquo;s largest grocery site in React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#alert-overload&#34;&gt;Alert overload: How to adopt a microservices architecture without being overwhelmed with noise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#f-sharp-not-a-game&#34;&gt;F#, not a game!!!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#polymer-firebase&#34;&gt;Applicazioni Real-Time con Polymer e Firebase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#offline-web-applications&#34;&gt;The new Mobile Challenge: Offline-Enablement for Web Applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#feature-gluttony&#34;&gt;How to defeat feature gluttony&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#webassembly&#34;&gt;Is WebAssembly the killer of JavaScript?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fatal-error&#34;&gt;The evolution in the design of FATAL ERROR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ancora-cpp&#34;&gt;Perché nel 2015 parliamo ancora di C++?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mobile-senza-unity&#34;&gt;Mobile senza Unity: il caso SBK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#php-7&#34;&gt;Speeding up the Web with PHP 7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;a-programmer-is&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-programmer-is:fd439f196c3125ae563b4be0e3399006&#34;&gt;A Programmer is&amp;hellip;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Birgitta Boeckeler (&lt;a href=&#34;https://twitter.com/birgitta410&#34;&gt;@birgitta410&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 10:15 - 11:00 - Keynote Motivational (&lt;a href=&#34;http://www.slideshare.net/Codemotion/keynote-birgitta-boeckeler-track-motivational-a-programmer-is&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In uno dei due &lt;em&gt;keynote&lt;/em&gt; di apertura della prima giornata Birgitta Boeckeler ha affrontato la spinosa questione di &lt;a href=&#34;http://milan2015.codemotionworld.com/talk-detail/?detail=1980&amp;amp;sub=1&#34;&gt;&amp;ldquo;cosa è un programmatore&amp;rdquo;&lt;/a&gt;, mostrando che assunzioni e incomprensioni &lt;strong&gt;vecchie di 50 anni&lt;/strong&gt; ancora oggi influenzano la professione di programmatore e il modo in cui essa è considerata nel mondo, da addetti ai lavori e non.&lt;/p&gt;

&lt;p&gt;La &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/&#34;&gt;software crisis&lt;/a&gt; degli anni &amp;lsquo;60 aveva spinto aziende e università a elaborare metodi per distinguere i &amp;ldquo;buoni programmatori&amp;rdquo; sulla base di &lt;strong&gt;test attitudinali&lt;/strong&gt; come l&amp;rsquo;&lt;em&gt;IBM PAT&lt;/em&gt;, e influenti pubblicazioni accademiche come &lt;a href=&#34;http://dl.acm.org/citation.cfm?id=1142628&#34;&gt;A vocational interest scale for computer programmers&lt;/a&gt;(1966) hanno contribuito alla definizione del programmatore tipo come una persona che &amp;ldquo;ama i puzzle&amp;rdquo;, &amp;ldquo;ama sperimentare e rischiare&amp;rdquo; e &amp;ldquo;odia la gente&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Purtroppo questo archetipo sopravvive ancora oggi, e forse la sua conseguenza più grave è stato lo sviluppo dell&amp;rsquo;idea che una delle professioni più belle e appaganti che esistano sia una &amp;ldquo;cosa da uomini&amp;rdquo;. Ma Birgitta nel suo &lt;em&gt;keynote&lt;/em&gt; cita anche &lt;a href=&#34;https://en.wikipedia.org/wiki/Jean_Bartik&#34;&gt;Jean Bartik&lt;/a&gt;, programmatrice di uno dei primi computer mai costruiti, l&amp;rsquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/ENIAC&#34;&gt;ENIAC&lt;/a&gt;, annunciato nel 1946: quando quella del &amp;ldquo;programmatore&amp;rdquo; non era ancora considerata una &lt;strong&gt;vera professione&lt;/strong&gt;, ma era vista come poco più di un lavoro di segreteria, gran parte dei programmatori negli USA era composta da donne. Ma in una recente &lt;a href=&#34;http://computerhistory.org/revolution/birth-of-the-computer/4/78/2258&#34;&gt;intervista&lt;/a&gt; la Bartik ha fatto notare che molte delle tecniche che usiamo e delle problematiche che ci troviamo ad affrontare in quanto programmatori erano &lt;strong&gt;già vere&lt;/strong&gt; negli anni &amp;lsquo;40: ad esempio, erano già evidenti i vantaggi del &lt;a href=&#34;https://en.wikipedia.org/wiki/Pair_programming&#34;&gt;pair programming&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nell&amp;rsquo;ultima parte del talk, Birgitta mostra come questa erronea visione della professione di programmatore porti ancora oggi molte donne, interessate a una carriera nello sviluppo software, a &lt;strong&gt;sentirsi escluse&lt;/strong&gt; dal club perché pensano che &lt;em&gt;veri&lt;/em&gt; programmatori si nasca, e che se la propria passione non sia in realtà una vera e propria &lt;em&gt;ossessione&lt;/em&gt; non si riuscirà mai ad eccellere: in realtà questo &lt;em&gt;status quo&lt;/em&gt; è, come si è visto, il prodotto di decenni di incompresioni e &lt;a href=&#34;http://www.npr.org/sections/money/2014/10/21/357629765/when-women-stopped-coding&#34;&gt;incredibili scivoloni&lt;/a&gt; nello sviluppo della professione di programmatore, e che è possibile aspirare ai massimi livelli di tale professione anche con un approccio più &lt;em&gt;bilanciato&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nel seguente tweet Birgitta cita libri, articoli e talk che hanno ispirato il suo &lt;em&gt;keynote&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;it&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Here is the material I used to put together my talk, &lt;a href=&#34;https://twitter.com/hashtag/Codemotion?src=hash&#34;&gt;#Codemotion&lt;/a&gt;. Read! Especially &amp;quot;Unlocking the Clubhouse&amp;quot; &lt;a href=&#34;https://t.co/ZKmdC1zvkf&#34;&gt;pic.twitter.com/ZKmdC1zvkf&lt;/a&gt;&lt;/p&gt;&amp;mdash; Birgitta B. (@birgitta410) &lt;a href=&#34;https://twitter.com/birgitta410/status/667646910161883136&#34;&gt;20 Novembre 2015&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;tdd-per-android&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tdd-per-android:fd439f196c3125ae563b4be0e3399006&#34;&gt;TDD per Android&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Matteo Vaccari (&lt;a href=&#34;https://twitter.com/xpmatteo&#34;&gt;@xpmatteo&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 11:20 - 12:00 - Mobile track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/matteo-vaccari-tdd-per-android-codemotion-milan-2015&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Matteo Vaccari porta al codemotion un talk, dal titolo alla prima apparenza banale, ma indicato come livello &lt;em&gt;intermediate&lt;/em&gt;. Con TDD per Android infatti, &lt;em&gt;non vuole introdurre né al testing di applicazioni Android, né al TDD&lt;/em&gt;.
Piuttosto durante il talk vengono mostrati alcuni trucchi da lui scovati durante la sua esperienza per fare vero &lt;em&gt;Test Driven Development&lt;/em&gt;. Come primo passo consiglia e spiega come affiancare al TestCase ufficiale dell&amp;rsquo; SDK Android, un altro strumento &lt;strong&gt;semplificato ed ottimizzato&lt;/strong&gt; per una esecuzione veloce dei test unitari: esso, basandosi esclusivamente su JUnit, permette l’esecuzione veloce del “ciclo” Red, Green, Refactor, senza dover attendere i tempi del device virtuale (o meno). Matteo  quindi  passa a sviscerare alcuni &lt;em&gt;trick&lt;/em&gt; più ricercati e specifici, dimostrandoli con due app d&amp;rsquo;esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/xpmatteo/unit-doctor&#34;&gt;esempio 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/xpmatteo/fairy-fingers&#34;&gt;esempio 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;platformer-2d&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;platformer-2d-jumping-from-xna-to-unity:fd439f196c3125ae563b4be0e3399006&#34;&gt;Platformer 2D: jumping from XNA to Unity&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Paolo Cattaneo (&lt;a href=&#34;https://twitter.com/RavenTravelStd&#34;&gt;Raven Travel Studios&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 12:10 - 13:10 - Game Dev track&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il vecchio ambiente di sviluppo &lt;strong&gt;XNA&lt;/strong&gt; è ormai stato abbandonato da Microsoft da anni. Molti sviluppatori si sono quindi visti costretti a migrare su altri &lt;em&gt;tool&lt;/em&gt;, come per esempio Unity, che con XNA condivide l’adozione del linguaggio C# per gli script. Il passaggio da una programmazione vecchio stampo ad un ambiente visuale può creare qualche problema, soprattutto per via di alcuni ostacoli apparentemente invalicabili. È realmente necessario creare manualmente per ogni &lt;em&gt;asset&lt;/em&gt; di un progetto un GameObject in Unity? Diffidate delle guide ufficiali e sfruttate la generazione a &lt;em&gt;runtime&lt;/em&gt; di nuovi GameObject, associando uno script di creazione ad un solo GameObject padre!&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;grocery-site-in-react&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;building-the-world-s-largest-grocery-site-in-react:fd439f196c3125ae563b4be0e3399006&#34;&gt;Building the world&amp;rsquo;s largest grocery site in React&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Robbie McCorkell (&lt;a href=&#34;https://twitter.com/robbiemccorkell&#34;&gt;@robbiemccorkell&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 14:10 - 14:50 - Architecture track&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lo speaker Robbie McCorkell, tech lead presso &lt;a href=&#34;http://red-badger.com&#34;&gt;Red Badger&lt;/a&gt;, società londinese che si occupa di web design per grossi partner internazionali, ci ha raccontato del viaggio che ha portato la sua azienda a creare il sito web di &lt;strong&gt;Tesco&lt;/strong&gt;, negozio online e distributore di prodotti di vario genere che opera principalmente in Europa, Nord America ed Estremo Oriente.
La tecnologia chiave impiegata per la realizzazione è stata &lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React&lt;/a&gt;, libreria open source realizzata da Facebook che consente di creare la view di applicazioni web mediante &lt;strong&gt;componenti&lt;/strong&gt;.
Una delle esigenze alla base dello sviluppo di un sito per un marchio così famoso era la possibilità di fruire di esso sul &lt;strong&gt;maggior numero possibile di dispositivi e browser&lt;/strong&gt;, cercando di minimizzare il traffico. La soluzione adottata da Red Badger a questo problema è stata la realizzazione di un applicazione &lt;strong&gt;isomorfica&lt;/strong&gt;, cioè un sistema che condivide lo stesso codice sia lato server sia lato client ed è in grado di fornire al browser delle pagine &lt;strong&gt;già renderizzate&lt;/strong&gt; che soltanto opzionalmente possono sfruttare javascript per l&amp;rsquo;interazione con gli elementi grafici.
Anche le ottimizzazioni per il SEO traggono benefici da un sito costruito in questo modo in quanto tutte le pagine sono &lt;strong&gt;indicizzabili&lt;/strong&gt; dai motori di ricerca.
L&amp;rsquo;impiego di React è stata quasi una scelta obbligata, visto che esso mette a disposizione degli strumenti semplici ma potenti per raggiungere l&amp;rsquo;obiettivo che si sono posti.
Particolare attenzione durante il talk è stata posta sulla necessità di essere sempre al passo con le varie versioni di React e delle librerie ad esso collegate (soprattutto quelle ufficiali che Facebook stessa sviluppa ed utilizza per i suoi prodotti, tipo &lt;a href=&#34;https://facebook.github.io/relay/&#34;&gt;Relay&lt;/a&gt; e &lt;a href=&#34;https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html&#34;&gt;GraphQL&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;alert-overload&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;alert-overload-how-to-adopt-a-microservices-architecture-without-being-overwhelmed-with-noise:fd439f196c3125ae563b4be0e3399006&#34;&gt;Alert overload: How to adopt a microservices architecture without being overwhelmed with noise&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sarah Wells (&lt;a href=&#34;https://twitter.com/sarahjwells&#34;&gt;@sarahjwells&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 14:10 - 14:50 - DevOps track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/sarah-wells-alert-overload-how-to-adopt-a-microservices-architecture-without-being-overwhelmed-with-noise&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il talk di Sarah, come promesso dal titolo, dava una serie di consigli su come mantenere in produzione un&amp;rsquo;architettura a microservizi senza venir &lt;strong&gt;sommersi dalle notifiche&lt;/strong&gt; di errore e dagli alert che ne derivano in caso di malfunzionamento:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pensare al monitoring dall&amp;rsquo;inizio, non è un attività che può essere posticipata;&lt;/li&gt;
&lt;li&gt;Gli alert devono presentarsi &lt;strong&gt;solo quando richiedono un&amp;rsquo;interazione&lt;/strong&gt; da parte di chi amministra il sistema;&lt;/li&gt;
&lt;li&gt;Costruire il proprio sistema &lt;strong&gt;pensando al supporto&lt;/strong&gt; (documentazione, test, etc..);&lt;/li&gt;
&lt;li&gt;Utilizzare il &lt;strong&gt;tool giusto per il lavoro che bisogna compiere&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;Configurare un&amp;rsquo;alert fa parte del fix del problema! &lt;em&gt;(Code -&amp;gt; Test -&amp;gt; Alert)&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Spegnere tutte le mail di notifica dai sistemi di monitoring (ci sono tool migliori: IRC, Slack, etc..;&lt;/li&gt;
&lt;li&gt;Assicurarsi di sapere se uno degli alert ha smesso di funzionare;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Oltre a questo Sarah ha anche parlato di alcuni &lt;strong&gt;tool&lt;/strong&gt; che utilizza più o meno frequentemente quali:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nagios.org&#34;&gt;Nagios&lt;/a&gt;: Monitoring e alerting&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.splunk.com&#34;&gt;Splunk&lt;/a&gt;: Log aggregation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://grafana.org&#34;&gt;Grafana&lt;/a&gt;: Per creare grafici e dashboard&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://getsentry.com/welcome&#34;&gt;Sentry&lt;/a&gt;: Per aggregare gli errori&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dashing.io&#34;&gt;Dashing&lt;/a&gt;: Framework per creare dashboard&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;f-sharp-not-a-game&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;f-not-a-game:fd439f196c3125ae563b4be0e3399006&#34;&gt;F#, not a game!!!&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Andrea Magnorsky (&lt;a href=&#34;https://twitter.com/silverspoon&#34;&gt;@silverspoon&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 14:10 - 14:50 - Game Dev track (&lt;a href=&#34;http://www.roundcrisis.com/presentations/2015-codemotion-milan/#/&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Andrea Magnorsky di &lt;a href=&#34;http://www.digitalfurnacegames.com&#34;&gt;Digital Furnace Games&lt;/a&gt; ha parlato dell&amp;rsquo;uso dei pattern di &lt;strong&gt;programmazione funzionale&lt;/strong&gt; nello sviluppo del loro prossimo gioco &lt;em&gt;Onikira: Demon Killer&lt;/em&gt;, per il quale hanno adottato il linguaggio funzionale &lt;a href=&#34;https://en.wikipedia.org/wiki/F_Sharp_(programming_language&#34;&gt;F#&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Nel giustificare un approccio più funzionale allo sviluppo software in generale, Andrea parla del bellissimo articolo &lt;a href=&#34;http://shaffner.us/cs/papers/tarpit.pdf&#34;&gt;Out of the Tar Pit&lt;/a&gt;, di Ben Moseley e Peter Marks, già citato più volte su questo blog. L&amp;rsquo;eccessiva &lt;strong&gt;complessità&lt;/strong&gt; può rendere ingestibili i progetti software, compresi i giochi, e un linguaggio come F#, basato - come ogni linguaggio funzionale - sull&amp;rsquo;uso di strutture dati immbutabili, funzioni pure e &lt;em&gt;pattern matching&lt;/em&gt;, permette di gestire lo stato del sistema in maniera più semplice: F# risulta essere particolarmente potente per questo scopo, grazie agli &lt;a href=&#34;http://fsharpforfunandprofit.com/posts/convenience-active-patterns/&#34;&gt;&lt;em&gt;active patterns&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nel corso del talk Andrea ha parlato anche dell&amp;rsquo;ottima interoperabilità di F# con C#, e dell&amp;rsquo;uso di librerie di &lt;a href=&#34;https://en.wikipedia.org/wiki/Property_testing&#34;&gt;&lt;em&gt;property testing&lt;/em&gt;&lt;/a&gt; come &lt;a href=&#34;https://github.com/fscheck/FsCheck&#34;&gt;FsCheck&lt;/a&gt;, e &lt;em&gt;building tools&lt;/em&gt; come &lt;a href=&#34;http://fsharp.github.io/FAKE/&#34;&gt;FAKE&lt;/a&gt;, mostrando quindi un ecosistema ricco di strumenti di sviluppo, perfettamente adeguato alla realizzazione di software ad alto livello, e cosa c&amp;rsquo;è di più &lt;em&gt;elevato&lt;/em&gt; di un videogioco?&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;polymer-firebase&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;applicazioni-real-time-con-polymer-e-firebase:fd439f196c3125ae563b4be0e3399006&#34;&gt;Applicazioni Real-Time con Polymer e Firebase&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Michel Murabito (&lt;a href=&#34;https://twitter.com/michelmurabito&#34;&gt;@michelmurabito&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 15:00 - 16:00 - Server-Side track&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il talk, portato al Codemotion 2015 dal GDG (Google Developer Group) Community Manager Italia  Michel Murabito, tratta due tecnologie emergenti nel panorama realtime, javascript (e non solo). Michael, attraverso un live tutorial atto a creare una todolist ci ha introdotto a &lt;a href=&#34;https://www.polymer-project.org&#34;&gt;Polymer&lt;/a&gt;, accompagnandoci per mano alla scoperta dei &lt;a href=&#34;https://elements.polymer-project.org/&#34;&gt;suoi components&lt;/a&gt;, spiegando come utilizzarli per ottenere senza sforzo un’interfaccia veloce e pulita, come personalizzarli e come crearne di nuovi. Successivamente ha integrato nell’applicazione ottenuta la persistenza dei dati utilizzando &lt;a href=&#34;https://www.firebase.com/&#34;&gt;Firebase&lt;/a&gt;, un servizio API, basato su DB NO SQL, veloce e tecnologicamente avanzato, tra le cui peculiarità troviamo, ad esempio, la capacità di mantenere aggiornati in realtime i client connessi.
&lt;a href=&#34;https://t.co/kukysY8sgZ&#34;&gt;App dimostrativa&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;offline-web-applications&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-new-mobile-challenge-offline-enablement-for-web-applications:fd439f196c3125ae563b4be0e3399006&#34;&gt;The new Mobile Challenge: Offline-Enablement for Web Applications&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Christiane Kurz (&lt;a href=&#34;https://twitter.com/learnui5&#34;&gt;@learnui5&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 15:00 - 16:00 - Mobile track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/christiane-kurz-the-new-mobile-challenge-offlineenablement-for-web-applications&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ottimo talk che introduce tecnologie ancora poco conosciute nello sviluppo web, e offre un’ottima soluzione per iniziare a pensare a come rendere disponibili i nostri siti web anche in modalità offline. Questo apre orizzonti a nuove soluzioni e a nuove sfide, come salvare i dati lato client (nel talk si parla di &lt;a href=&#34;https://developer.mozilla.org/it/docs/Web/API/IndexedDB_API&#34;&gt;indexedDB&lt;/a&gt;), e gestire conflitti tra i dati durante la sincronizzazione col server, cercando possibili strumenti di compatibilità con vecchi browser: in effetti l&amp;rsquo;unica piccola pecca della soluzione proposta è la ridotta compatibilità con i browser, soprattutto mobile, consultabile anche a questo &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API#Browser_compatibility&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Che altro dire… questo è un ottimo spunto per iniziare a pensare a qualche possibile implementazione in vista di un maggior supporto.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;feature-gluttony&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-to-defeat-feature-gluttony:fd439f196c3125ae563b4be0e3399006&#34;&gt;How to defeat feature gluttony&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Kasia Mrowca (&lt;a href=&#34;https://twitter.com/MrowcaKasia&#34;&gt;@MrowcaKasia&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 15:00 - 16:00 - Startup track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/kasia-mrowca-how-to-defeat-feature-gluttony-codemotion-milan-2015-55472938&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kasia Mrowca, ex programmatrice ed ora product owner, ci spiega le sue strategie per ovviare ai &lt;strong&gt;problemi di backlog&lt;/strong&gt;: desiderare buone e nuove feature è una cosa buona, ma esagerare è male.&lt;/p&gt;

&lt;p&gt;Per spiegarci tutto questo ci porta la sua esperienza, ad esempio come ha visto un backlog crescere così tanto da necessitare fino a 15 (!) persone per essere gestito; ovviamente questo è uno scenario catastrofico, i cui &lt;strong&gt;costi di organizzazione&lt;/strong&gt; e comunicazione necessari tra tutte queste persone porta ad un rallentamento irrisolvibile. Nel suo talk ci illustra alcune tecniche utili di visualizzazione e organizzazione delle feature richieste, per selezionarle e prioritizzarle con criterio.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;webassembly&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;is-webassembly-the-killer-of-javascript:fd439f196c3125ae563b4be0e3399006&#34;&gt;Is WebAssembly the killer of JavaScript?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Boyan Mihaylov (&lt;a href=&#34;https://twitter.com/bmihaylov&#34;&gt;@bmihaylov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 1 - 17:10 - 17:50 - Languages track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/boyan-mihaylov-is-web-assembly-the-killer-of-javascript&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La presentazione è condotta da Boyan Mihaylov ed è un&amp;rsquo;introduzione al nuovo mondo di &lt;a href=&#34;https://medium.com/javascript-scene/what-is-webassembly-the-dawn-of-a-new-era-61256ec5a8f6#.ee7hgs4df&#34;&gt;WebAssembly&lt;/a&gt;: una tecnologia in fase di sviluppo molto promettente nell&amp;rsquo;ambito internet.
JavaScript è il linguaggio del web. È nato nel 1995 per risolvere specifici problemi di computazione lato browser. Per molto tempo è stato un linguaggio &lt;strong&gt;senza specifiche&lt;/strong&gt;, con conseguenti difficoltà nello scrivere script compatibili cross-broswer. Con il passare del tempo, sono stati definiti degli standard (ECMA) che hanno parzialmente risolto il problema.
Nell&amp;rsquo;ultimo periodo JavaScript si è diffuso molto. Oggi lo si usa praticamente ovunque per sviluppare applicazioni client-side, server-side, mobile e desktop.&lt;/p&gt;

&lt;p&gt;Tuttavia molti problemi rimangono irrisolti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Il browser esegue solo codice scritto in JavaScript;&lt;/li&gt;
&lt;li&gt;JavaScript è spesso considerato verboso e carente di funzionalità rispetto ad altri linguaggi;&lt;/li&gt;
&lt;li&gt;Ad ogni esecuzione, la sintassi dei programmi JavaScript deve essere elaborata con un significativo impatto sulle performance;&lt;/li&gt;
&lt;li&gt;JavaScript è text-based, i file con codice sorgente possono raggiungere dimensioni notevoli per il trasferimento via rete;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Diverse strategie sono state attuate per aggirare questi problemi.
È frequente l&amp;rsquo;uso di tool di &lt;strong&gt;minificazione&lt;/strong&gt; del sorgente per ridurre le dimensioni.
Sono stati sviluppati differenti flavour di JavaScript per aumentare l&amp;rsquo;espressività del linguaggio (CoffeeScript, TypeScript, ecc.);
Sono stati creati dei compilatori per tradurre in JavaScript programmi scritti in altri linguaggi.&lt;/p&gt;

&lt;p&gt;Ciò tuttavia è molto inefficiente: perché non compilare il codice sorgente in una specie di bytecode? Sarebbe più performante in fase d&amp;rsquo;esecuzione e download.&lt;/p&gt;

&lt;p&gt;La risposta è WebAssembly o WASM.
WASM è un linguaggio binario destinato ad essere eseguito da una virtual machine integrata nei browser.
Teoricamente qualsiasi linguaggio dotato di compilatore WebAssembly può essere utilizzato per sviluppare applicazioni browser-based.&lt;/p&gt;

&lt;p&gt;WebAssembly beneficia di tutti i vantaggi di JS, compresa l&amp;rsquo;esecuzione in Sandbox.
WASM non sostituirà JavaScript in quanto quest&amp;rsquo;ultimo, tramite compilazione, genererà istruzioni WebAssembly.&lt;/p&gt;

&lt;p&gt;WebAssembly è ancora in fase di prototipazione, è una tecnologia molto interessante e si pensa che essa detterà le basi per sviluppare virtual machine d&amp;rsquo;ultima generazione.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;fatal-error&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-evolution-in-the-design-of-fatal-error:fd439f196c3125ae563b4be0e3399006&#34;&gt;The evolution in the design of FATAL ERROR&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ciro Continisio (&lt;a href=&#34;https://twitter.com/ccontinisio&#34;&gt;@ccontinisio&lt;/a&gt;), Ennio Pirolo (&lt;a href=&#34;https://twitter.com/santennio&#34;&gt;@SantEnnio&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 2 - 11:20 - 12:00 - Game Dev track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/ciro-continisio-ennio-pirolo-the-evolution-in-the-design-of-fatal-error&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A volte lo sviluppo di un videogioco può protrarsi per mesi, anche anni. È quello che è accaduto con FATAL ERROR, titolo nato dalle menti di Ciro Continisio ed Ennio Pirolo ben 2 anni fa in occasione della GamesWeek di Milano. Nel corso degli anni il processo di sviluppo iterativo tipico dei videogiochi ha portato a vari miglioramenti tecnici, rimanendo però fedeli alle prime linee guida di game design. L’IA nel gioco ha adottato un interessante meccanismo di comportamenti che, una volta associati ad un bot governato dalla CPU, permettono a seconda dell’azione su schermo di attivare un determinato comportamento. Un approccio applicabile anche al di fuori dello sviluppo di videogiochi.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;ancora-cpp&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;perché-nel-2015-parliamo-ancora-di-c:fd439f196c3125ae563b4be0e3399006&#34;&gt;Perché nel 2015 parliamo ancora di C++?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Marco Arena (&lt;a href=&#34;https://twitter.com/italiancpp&#34;&gt;@italiancpp&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 2 - 12:10 - 13:10 - Languages track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/marco-arena-perch-nel-2015-parliamo-ancora-di-c-codemotion-milan-2015&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La domanda è lecita, a 30 anni dalla presentazione del linguaggio, ma Marco Arena ha tutte le risposte nonostante quel giorno non fosse ancora nato. Il C++ è &lt;em&gt;molto popolare&lt;/em&gt;: diversi software di uso quotidiano, tra cui probabilmente il browser che state usando, sono scritti in questo linguaggio. È inoltre &lt;em&gt;compatibile con il C&lt;/em&gt; e, più in generale, si &lt;em&gt;preoccupa del passato&lt;/em&gt;: segue uno standard ISO, la retrocompatibiltà è sempre garantita e i miglioramenti sono ottenuti aggiungendo nuovi costrutti. Non è &lt;em&gt;garbage collected&lt;/em&gt;: il lifetime di oggetti e risorse è &lt;em&gt;scoped&lt;/em&gt;, garantendo in questo modo un comportamento deterministico ed evitando complicazioni in sistemi &lt;em&gt;latency-critical&lt;/em&gt;. È &lt;em&gt;indipendente dal paradigma&lt;/em&gt;, perché ne comprende diversi, ed è adatto al &lt;em&gt;system programming&lt;/em&gt; grazie al suo accesso a basso livello alla memoria. Sta inoltre &lt;em&gt;crescendo in fretta&lt;/em&gt;: dopo oltre 20 anni in cui è rimasto sostanzialmente immutato, ha recentemente presentato diverse innovazioni e molte altre sono state annunciate per i prossimi anni. Da ultimo, è immerso in un &lt;em&gt;ecosistema straordinario&lt;/em&gt;, composto da industrie, mondo accademico e user groups.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;mobile-senza-unity&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;mobile-senza-unity-il-caso-sbk:fd439f196c3125ae563b4be0e3399006&#34;&gt;Mobile senza Unity: il caso SBK&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Giuseppe Navarria (&lt;a href=&#34;https://twitter.com/waveringradiant&#34;&gt;@WaveringRadiant&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 2 - 12:10 - 13:10 - Game Dev track (&lt;a href=&#34;http://www.slideshare.net/Codemotion/giuseppe-navarria-mobile-senza-unity-il-caso-sbk&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con tool in circolazione come Unity ed Unreal Engine quasi ci si scorda di come vengono costruiti i motori grafici dei videogiochi. Giuseppe Navarria ha spiegato alcune caratteristiche del motore realizzato in C++ per le versioni mobile del gioco SBK, evidenziando alcuni pregi acquisiti grazie proprio al “fai da te”. L’utilizzo di lightmap generate da immagini HDR, gli effetti di rifrazione della luce con pixel shader e spheremaps, nonché ombre precalcolate con effetto blob shadow, hanno permesso di raggiungere livelli qualitativi di un certo spessore anche su dispositivi un po’ datati. Interessante la divisione in moduli del motore che seleziona il miglior set di componenti per il dispositivo sul quale opera.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;php-7&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;speeding-up-the-web-with-php-7:fd439f196c3125ae563b4be0e3399006&#34;&gt;Speeding up the Web with PHP 7&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Rasmus Lerdorf (&lt;a href=&#34;https://twitter.com/rasmus&#34;&gt;@rasmus&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;day 2 - 14:10 - 14:50 - Languages track&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Da questo talk di &lt;strong&gt;Rasmus Lerdorf&lt;/strong&gt; (creatore del linguaggio PHP) ci si sarebbe potuto aspettare una semplice lista delle nuove feature di PHP 7 (di cui abbiamo già parlato in &lt;a href=&#34;/php-7-overview&#34;&gt;questo post&lt;/a&gt;, in realtà però il relatore si è spinto molto più in là mostrando alcuni &lt;strong&gt;benchmark di comparazione delle performance&lt;/strong&gt; tra PHP 7, PHP 5 e HHVM 3.10, nei quali PHP 7 stracciava PHP 5 e teneva egregiamente il passo con HHVM 3.10, per poi dare una semplice ma approfondita overview rispetto ad alcune parti del lavoro fatto per ottenere quello che oggi è PHP 7 in termini di &lt;strong&gt;performance e feature&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Rasmus ha parlato del lungo lavoro di micro ottimizzazioni e di &lt;strong&gt;refactoring&lt;/strong&gt; sulla codebase, soprattutto per quanto riguarda l&amp;rsquo;utilizzo della memoria da parte di HashTable e Zval che ora, nella maggior parte dei casi, è stato più che dimezzato.&lt;/p&gt;

&lt;p&gt;Preziose sono state anche le informazioni riguardanti l&amp;rsquo;&lt;a href=&#34;https://wiki.php.net/rfc/abstract_syntax_tree&#34;&gt;AST&lt;/a&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;Abstract Syntax Tree&lt;/a&gt;) che è stata introdotta in questa nuova versione e che permette non solo di ragionare in termini più strutturati quando si effettuano modifiche agli internals del linguaggio ma che sarà causa della nascita, secondo Rasmus, di una serie infinita di tool come: analizzatori statici, compilatori, parser in userland etc..&lt;/p&gt;

&lt;p&gt;Ultime ma non meno importanti sono le informazioni date riguardo la &lt;strong&gt;FDO&lt;/strong&gt; di gcc (&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc-4.1.0/gcc/Optimize-Options.html&#34;&gt;Feedback Directed Optimization&lt;/a&gt;) con la quale, per chi compila PHP da sé, si possono ottenere degli ulteriori &lt;strong&gt;incrementi di performance facendo training&lt;/strong&gt; sulla propria codebase in fase di compilazione della SAPI.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Optionals in Objective-C</title>
      <link>/blog/ita/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/optionals-in-objective-c/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Objective-C vivrà ancora per molto&lt;/strong&gt;. Nonostante Swift sia il nuovo punto di riferimento per lo sviluppo iOS e OS X, ci sono ragioni concrete per scegliere di continuare a sviluppare in Objective-C, almeno per un po&amp;rsquo;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;progetti esistenti basati su Objective-C richiedono ancora mantenimento e probabile aggiunta di nuove funzionalità, e anche se è tecnicamente possibile mescolare i linguaggi, la cosa può risultare &lt;strong&gt;poco conveniente&lt;/strong&gt; per via della natura molto dinamica di Objective-C;&lt;/li&gt;
&lt;li&gt;Swift sta cambiando rapidamente, presenta ancora alcuni bug e &lt;strong&gt;problemi di performance&lt;/strong&gt;, e il suo workflow manca ancora di alcune feature fondamentali per i professionisti, mentre Objective-C è un linguaggio maturo, con una community molto vivace;&lt;/li&gt;
&lt;li&gt;alcuni possono &lt;strong&gt;preferire un linguaggio più dinamico&lt;/strong&gt;, e il supporto di Apple su Objective-C è &lt;a href=&#34;https://netguru.co/blog/objective-c-generics&#34;&gt;ancora forte&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Personalmente ho la tendenza a preferire linguaggi più statici, e un approccio &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;type-first&lt;/a&gt; alla programmazione, ma di tanto in tanto mi piace lavorare in un ambiente più &lt;em&gt;dinamico&lt;/em&gt;, quindi, sia per preferenza personale che per esigenze di business, non ho ancora messo Objective-C da parte. Ma dopo poche settimane di Swift, mi è mancata subito una delle sue funzionalità più potenti: gli &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optionals&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#il-tipo-optional&#34;&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optionals-in-swift&#34;&gt;Optionals in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#torniamo-a-objective-c&#34;&gt;Torniamo a Objective-C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-un-parser-json&#34;&gt;Esempio: un parser JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusione&#34;&gt;Conclusione&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;il-tipo-optional&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-tipo-optional:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt; è un tipo &lt;em&gt;generico&lt;/em&gt; (o, più propriamente, &lt;em&gt;parametrico&lt;/em&gt;), dipendente da un &lt;strong&gt;tipo secondario&lt;/strong&gt;: è possibile ad esempio definire un &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt; oppure un &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt;: la sintassi di Swift permette di scrivere i tipi appena indicati con &lt;code&gt;String?&lt;/code&gt; e &lt;code&gt;Int?&lt;/code&gt;. Ma cos&amp;rsquo;è esattamente un &lt;code&gt;Optional&lt;/code&gt;?. È un tipo particolare che serve a rappresentare un dato che &lt;em&gt;potrebbe&lt;/em&gt; esistere, ed essere quindi di un certo tipo secondario, o potrebbe non esistere, ed essere quindi &lt;strong&gt;nil&lt;/strong&gt;: &lt;em&gt;inscatolando&lt;/em&gt; il valore opzionale in un &lt;code&gt;Optional&lt;/code&gt;, il compilatore di Swift saprà che quel valore potrà essere nil, e emettere un errore nei casi in cui stiamo usando un &lt;code&gt;Optional&lt;/code&gt; dove ci si aspetta un valore &lt;strong&gt;sempre&lt;/strong&gt; presente. Questa semplice funzionalità ci garantisce notevole rigore nella definizione dei nostri tipi di dato e funzione: ad esempio, in Swift non possiamo inizializzare un valore non opzionale con nil, e considerando che, per il compilatore, un valore non può essere usato prima di essere istanziato, se assegniamo il tipo &lt;code&gt;String&lt;/code&gt; a un valore, siamo sicuri al 100% che quel valore sarà &lt;strong&gt;sempre a comunque&lt;/strong&gt; una stringa.&lt;/p&gt;

&lt;p&gt;Al contrario, in Objective-C un oggetto può essere sempre nil, e spesso siamo costretti a controllare l&amp;rsquo;effettiva presenza di un oggetto ogni volta in cui abbiamo bisogno di un&amp;rsquo;istanza che non sia nil. In realtà non si tratta di un grosso problema: è un classico &lt;strong&gt;compromesso&lt;/strong&gt; dei linguaggi dinamici, e il fatto che posso sempre inviare un messaggio a un riferimento nil può essere anche considerato una &lt;em&gt;feature&lt;/em&gt;: usando un linguaggio dinamico, ci si aspetta che progettiamo le nostre API tenendo sempre in considerazione il concetto di &lt;a href=&#34;https://en.wikipedia.org/wiki/Late_binding&#34;&gt;late-binding&lt;/a&gt;. Inoltre, i nuovi &lt;a href=&#34;https://developer.apple.com/swift/blog/?id=25&#34;&gt;&lt;em&gt;nullability specifiers&lt;/em&gt;&lt;/a&gt; di Objective-C aiutano il compilatore a emettere avvisi quando stiamo passando nil a un metodo o una &lt;em&gt;property&lt;/em&gt; che richiedono invece che il parametro sia &lt;code&gt;nonnull&lt;/code&gt;. Ma il problema rimane: abbiamo bisogno di molto &lt;em&gt;boilerplate&lt;/em&gt; per verificare se qualcosa è nil, e ciò può portare a codice poco leggibile e comprensibile, soggetto ad errori. Swift non ha tipicamente bisogno di questo &lt;em&gt;boilerplate&lt;/em&gt; grazie alla natura stessa del tipo &lt;code&gt;Optional&lt;/code&gt;: esso ha le stesse caratteristiche del tipo &lt;code&gt;Maybe&lt;/code&gt; in Haskell, o del tipo &lt;code&gt;Option&lt;/code&gt; in Scala, cioè &lt;code&gt;Optional&lt;/code&gt; è in realtà un &lt;strong&gt;monad&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il concetto di &lt;em&gt;monad&lt;/em&gt; è ereditato, in programmazione funzionale, dalla &lt;a href=&#34;https://it.wikipedia.org/wiki/Teoria_delle_categorie&#34;&gt;teoria delle categorie&lt;/a&gt;, ed è facile trovare &lt;a href=&#34;https://wiki.haskell.org/Monad&#34;&gt;molti&lt;/a&gt; &lt;a href=&#34;https://www.haskell.org/tutorial/monads.html&#34;&gt;testi&lt;/a&gt; &lt;a href=&#34;http://learnyouahaskell.com/a-fistful-of-monads&#34;&gt;introduttivi&lt;/a&gt; sul tema, quindi non approfondirò ulteriormente: dirò solo che un &lt;em&gt;monad&lt;/em&gt; è un &lt;em&gt;contesto computazionale&lt;/em&gt;, quindi una &lt;em&gt;specifica&lt;/em&gt; per il modo in cui una espressione deve essere valutata. Applicare una certa trasformazione a un &lt;em&gt;monad&lt;/em&gt; avrà come risultato un&amp;rsquo;altra istanza dello stesso &lt;em&gt;monad&lt;/em&gt; differente dalla prima, a seconda dello specifico tipo di &lt;em&gt;monad&lt;/em&gt;. Ad esempio, applicare una trasformazione a un &lt;code&gt;Optional&lt;/code&gt; risulterà nell&amp;rsquo;applicazione della stessa trasformazione al valore &lt;em&gt;contenuto&lt;/em&gt;, se presente, o assolutamente niente se l&amp;rsquo;&lt;code&gt;Optional&lt;/code&gt; contiene nil: in entrambi i casi, il risultato della trasformazione sarà un nuovo &lt;code&gt;Optional&lt;/code&gt;, possibilmente con un tipo secondario diverso.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;optionals-in-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;optionals-in-swift:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Optionals in Swift&lt;/h2&gt;

&lt;p&gt;Consideriamo il seguente codice Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?  
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)  
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalString = optionalInt.map(toString)  
print(optionalString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nell&amp;rsquo;esempio, &lt;code&gt;optionalInt&lt;/code&gt; è un &lt;code&gt;Int&lt;/code&gt; &lt;em&gt;contenuto&lt;/em&gt; in un &lt;code&gt;Optional&lt;/code&gt;, che quindi ha tipo &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt; (in Swift è possibile abbreviarlo in &lt;code&gt;Int?&lt;/code&gt;), e applicando ad esso la funzione &lt;code&gt;toString&lt;/code&gt; otteniamo un&amp;rsquo;istanza di &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt;. Possiamo vedere che, per applicare effettivamente la funzione &lt;code&gt;toString&lt;/code&gt;, abbiamo passato la funzione come argomento al metodo &lt;code&gt;map&lt;/code&gt; del &lt;code&gt;Optional&lt;/code&gt;: questa operazione è solitamente chiamata &lt;em&gt;lifting&lt;/em&gt; di una funzione, perché la funzione &lt;code&gt;toString&lt;/code&gt;, di tipo &lt;code&gt;Int -&amp;gt; String&lt;/code&gt;, è &lt;em&gt;sollevata&lt;/em&gt; (&lt;em&gt;lifted&lt;/em&gt;) fino a diventare di tipo &lt;code&gt;Optional&amp;lt;Int&amp;gt; -&amp;gt; Optional&amp;lt;String&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Come possiamo vedere, non sono state usate istruzioni condizionali nel manipolare il valore intero &lt;em&gt;opzionale&lt;/em&gt;: &lt;em&gt;sollevando&lt;/em&gt; le trasformazioni con il metodo &lt;code&gt;map&lt;/code&gt;, possiamo applicarle direttamente alle istanze di &lt;code&gt;Optional&lt;/code&gt;, e possiamo anche concatenarle molto facilmente, ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?  
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)  
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let doubled: Int -&amp;gt; Int = { $0*2 }

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalDoubledString = optionalInt.map(doubled).map(toString)  
print(optionalDoubledString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Volendo esprimere l&amp;rsquo;operazione opposta, avremmo un problema: trasformare una stringa in un intero non è sempre possibile in Swift (ad esempio se non c&amp;rsquo;è alcun numero nella stringa), quindi l&amp;rsquo;operazione stessa risulterebbe in un &lt;code&gt;Optional&lt;/code&gt;. Infatti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalStringFrom(value: String, ifTrue: Bool) -&amp;gt; String?  
{
  return ifTrue ? value : nil
}

let toInt: String -&amp;gt; Int? = { Int($0) }

let anotherOptionalString = makeOptionalStringFrom(&amp;quot;3&amp;quot;, ifTrue: true)

let anotherOptionalInt = anotherOptionalString.map(toInt).map(doubled)
/// errore di compilazione!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il problema qui è che la funzione &lt;code&gt;toInt&lt;/code&gt; è di tipo &lt;code&gt;String -&amp;gt; Optional&amp;lt;Int&amp;gt;&lt;/code&gt;, e il &lt;em&gt;lifting&lt;/em&gt; della funzione verso il &lt;em&gt;mondo opzionale&lt;/em&gt; la trasformerebbe in una funzione del tipo &lt;code&gt;Optional&amp;lt;String&amp;gt; -&amp;gt; Optional&amp;lt;Optional&amp;lt;Int&amp;gt;&amp;gt;&lt;/code&gt;, quindi un intero opzionale contenuto in un altro &lt;code&gt;Optional&lt;/code&gt;; in base alla terminologia accettata, abbiamo bisogno di un&amp;rsquo;operazione di &lt;code&gt;flatMap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let anotherOptionalInt = anotherOptionalString.flatMap(toInt).map(doubled)  
/// funziona
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi, per quanto riguarda il tipo &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; è simile a &lt;code&gt;map&lt;/code&gt;, ma deve essere usato per il &lt;em&gt;lifting&lt;/em&gt; di funzioni che generano altri valori opzionali. Nel leggere il codice, &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt; possono sostanzialmente essere letti nello stesso modo: indicano entrambi una trasformazione, e il fatto che le funzioni passate a &lt;code&gt;flatMap&lt;/code&gt; abbiano un tipo diverso può essere considerato un dettaglio di implementazione.&lt;/p&gt;

&lt;p&gt;In realtà Swift tratta questi tipi di dato &lt;strong&gt;in maniera differente&lt;/strong&gt; rispetto ad altri linguaggi: ad esempio, nei linguaggi &lt;em&gt;funzionali&lt;/em&gt; &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt; sono di norma &lt;em&gt;funzioni libere&lt;/em&gt;, mentre in Swift sono &lt;strong&gt;metodi&lt;/strong&gt;. In generale, Swift incoraggia l&amp;rsquo;uso dei metodi, e del loro &lt;strong&gt;concatenamento&lt;/strong&gt;, invece di funzioni libere, composte con operatori speciali: si tratta, più che altro, di una questione filosofica, ma nel trasportare queste feature in Objective-C l&amp;rsquo;approccio basato sui metodi tornerà utile poiché non c&amp;rsquo;è un modo semplice di rappresentare funzioni libere nel linguaggio, mentre i metodi hanno la classica sintassi alla quale siamo abituati.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;torniamo-a-objective-c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;torniamo-a-objective-c:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Torniamo a Objective-C&lt;/h2&gt;

&lt;p&gt;Implementiamo la classe &lt;code&gt;Optional&lt;/code&gt; in Objective-C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface Optional : NSObject

+ (Optional*)with:(id _Nullable)value;

- (Optional*)map:(id(^)(id))mapBlock;
- (Optional*)flatMap:(Optional*(^)(id))flatMapBlock;

@end

NS_ASSUME_NONNULL_END 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

#import &amp;quot;Optional.h&amp;quot;

@interface Optional ()

@property (strong, nonatomic, nullable) id value;

@end

@implementation Optional

+ (Optional*)with:(id _Nullable)value
{
  Optional* optional = [Optional new];
  optional.value = value;
  return optional;
}

- (Optional *)map:(id  _Nonnull (^)(id _Nonnull))mapBlock
{
  if (self.value != nil)
  {
    return [Optional with:mapBlock(self.value)];
  }
  return self;
}

- (Optional *)flatMap:(Optional* _Nonnull (^)(id _Nonnull))flatMapBlock
{
  if (self.value != nil)
  {
    return flatMapBlock(self.value);
  }
  return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come possiamo vedere, il metodo di classe &lt;code&gt;with:&lt;/code&gt; crea un oggetto &lt;code&gt;Optional&lt;/code&gt; inscatolando un altro oggetto, di tipo non specificato: poiché non esiste un vero concetto di &lt;em&gt;generic&lt;/em&gt; in Objective-C, non sarà possibile realizzare un tipo &lt;code&gt;Optional&lt;/code&gt; sicuro, dal punto di vista dei tipi, come in Swift, ma non sarà un grosso problema, e saremo comunque in grado di ereditare da Swift &lt;strong&gt;potenti features&lt;/strong&gt;. Il metodo &lt;code&gt;map:&lt;/code&gt; verifica se l&amp;rsquo;oggetto contenuto non sia nil, e in tal caso applica la trasformazione espressa con &lt;code&gt;mapBlock&lt;/code&gt;: in questo caso i &lt;em&gt;nullability specifiers&lt;/em&gt; di Objective-C ci hanno aiutato nello scrivere la firma dei metodi, infatti abbiamo chiaramente specificato che &lt;code&gt;mapBlock&lt;/code&gt; accetta e ritorna oggetti che non siano nil; &lt;code&gt;flatMapBlock&lt;/code&gt; ritorna invece un altro &lt;code&gt;Optional&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Possiamo testare la cosa riscrivendo lo stesso esempio visto per Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Test : NSObject

+ (void)testOptional;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.m

#import &amp;quot;Test.h&amp;quot;
#import &amp;quot;Optional.h&amp;quot;

@implementation Test

+ (void)testOptional
{
  Optional* optionalInt = [self makeOptionalIntFrom:@3 ifTrue:YES];
  Optional* optionalDoubledString = [[optionalInt
                                      map:[self doubled]]
                                     map:[self toString]];
  NSLog(@&amp;quot;%@&amp;quot;, optionalDoubledString);
}

+ (Optional*)makeOptionalIntFrom:(NSNumber*)fromInt ifTrue:(BOOL)ifTrue
{
  return [Optional with:ifTrue ? fromInt : nil];
}


+ (NSNumber*(^)(NSNumber*))doubled
{
  return ^NSNumber*(NSNumber* value)  {
    return @(value.integerValue*2);
  };
}

+ (NSString*(^)(NSNumber*))toString
{
  return ^NSString*(NSNumber* value)  {
    return [NSString stringWithFormat:@&amp;quot;%@&amp;quot;, value];
  };
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Un volta applicate le trasformazioni, abbiamo bisogno di un metodo per &amp;ldquo;estrarre&amp;rdquo; l&amp;rsquo;oggetto all&amp;rsquo;interno del &lt;code&gt;Optional&lt;/code&gt;: Swift permette questa operazione a livello di sintassi, mentre in Objective-C possiamo seguire le convenzioni standard in programmazione funzionale, e cioè definire un metodo &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id _Nullable)get;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)get
{
  return self.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo &lt;code&gt;get&lt;/code&gt; ritorna un &lt;code&gt;id _Nullable&lt;/code&gt;: ciò vuol dire che l&amp;rsquo;oggetto ritornato può (ovviamente) essere nil. Un pattern frequente quando si ha a che fare con oggetti nil consiste nel sostituirli con versioni di &amp;ldquo;default&amp;rdquo;: può essere utile quando non ci interessano tanto i dati contenuti in un oggetto, ma non vogliamo correre i rischi associati al lavorare riferimenti &lt;em&gt;null&lt;/em&gt;. Ancora una volta, con la classe &lt;code&gt;Optional&lt;/code&gt; possiamo evitare istruzioni condizionali ed esprimere il meccanismo di &amp;ldquo;defaulting&amp;rdquo; in un modo più dichiarativo: dobbiamo semplicemente aggiungere un metodo &lt;code&gt;getOrElse:&lt;/code&gt;, che ritorni l&amp;rsquo;oggetto contenuto se presente, o un oggetto di default passato al metodo stesso:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id)getOrElse:(id(^)())elseBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)getOrElse:(id  _Nonnull (^)())elseBlock
{
  if (self.value != nil)
  {
    return self.value;
  }
  return elseBlock();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, il metodo &lt;code&gt;getOrElse:&lt;/code&gt; &lt;strong&gt;non&lt;/strong&gt; ritorna un oggetto &lt;code&gt;_Nullable&lt;/code&gt;: in effetti non stiamo passando l&amp;rsquo;oggetto, ma un block che &amp;ldquo;produrrà&amp;rdquo; l&amp;rsquo;oggetto una volta invocato; in questo modo riusciamo a ottenere l&amp;rsquo;oggetto di default in maniera &lt;strong&gt;lazy&lt;/strong&gt;, perché se l&amp;rsquo;oggetto contenuto è presente, non è necessario generare l&amp;rsquo;oggetto di default.&lt;/p&gt;

&lt;p&gt;Per il resto dell&amp;rsquo;articolo lavoreremo su un esempio più concreto, e implementeremo diverse funzionalità per la classe &lt;code&gt;Optional&lt;/code&gt;, rendendola via via più utile e potente.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-un-parser-json&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-un-parser-json:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Esempio: un parser JSON&lt;/h2&gt;

&lt;p&gt;Supponiamo di voler realizzare un&amp;rsquo;app che mostra informazioni sui film: possiamo ottenerle in formato JSON da un sito come &lt;a href=&#34;http://api.myapifilms.com/index.do&#34;&gt;myapifilms&lt;/a&gt;. La rappresentazione JSON di ogni film è del tipo seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
    &amp;quot;countries&amp;quot;: [
        &amp;quot;USA&amp;quot;
    ],
    &amp;quot;directors&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;filmingLocations&amp;quot;: [
        &amp;quot;St. Croix&amp;quot;,
        &amp;quot;U.S. Virgin Islands&amp;quot;
    ],
    &amp;quot;genres&amp;quot;: [
        &amp;quot;Crime&amp;quot;,
        &amp;quot;Drama&amp;quot;
    ],
    &amp;quot;idIMDB&amp;quot;: &amp;quot;tt0111161&amp;quot;,
    &amp;quot;languages&amp;quot;: [
        &amp;quot;English&amp;quot;
    ],
    &amp;quot;metascore&amp;quot;: &amp;quot;80/100&amp;quot;,
    &amp;quot;originalTitle&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;plot&amp;quot;: &amp;quot;Andy Dufresne is a young and successful banker whose life changes drastically when he is convicted and sentenced to life imprisonment for the murder of his wife and her lover. Set in the 1940s, the film shows how Andy, with the help of his friend Red, the prison entrepreneur, turns out to be a most unconventional prisoner.&amp;quot;,
    &amp;quot;ranking&amp;quot;: 1,
    &amp;quot;rated&amp;quot;: &amp;quot;R&amp;quot;,
    &amp;quot;rating&amp;quot;: &amp;quot;9.3&amp;quot;,
    &amp;quot;releaseDate&amp;quot;: &amp;quot;19941014&amp;quot;,
    &amp;quot;runtime&amp;quot;: [
        &amp;quot;142 min&amp;quot;
    ],
    &amp;quot;simplePlot&amp;quot;: &amp;quot;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;The Shawshank Redemption&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;Movie&amp;quot;,
    &amp;quot;urlIMDB&amp;quot;: &amp;quot;http://www.imdb.com/title/tt0111161&amp;quot;,
    &amp;quot;urlPoster&amp;quot;: &amp;quot;http://ia.media-imdb.com/images/M/MV5BODU4MjU4NjIwNl5BMl5BanBnXkFtZTgwMDU2MjEyMDE@._V1_SX214_AL_.jpg&amp;quot;,
    &amp;quot;votes&amp;quot;: &amp;quot;1,533,914&amp;quot;,
    &amp;quot;writers&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Stephen King&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0000175&amp;quot;
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;year&amp;quot;: &amp;quot;1994&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vogliamo definire la nostra rappresentazione interna del film con un &lt;em&gt;value object&lt;/em&gt;, modificare in parte la struttura e magari ignorare alcuni elementi che non consideriamo rilevanti. Ecco un&amp;rsquo;interfaccia possibile per la classe &lt;code&gt;Movie&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NS_ASSUME_NONNULL_BEGIN

@interface Movie : NSObject

@property (copy, nonatomic, readonly) NSString* title;
@property (copy, nonatomic, readonly) NSNumber* rating;
@property (copy, nonatomic, readonly) NSNumber* year;
@property (copy, nonatomic, readonly) NSNumber* lengthInMinutes;

+ (Movie*)withJSONDict:(NSDictionary*)dict;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo di classe &lt;code&gt;withJSONDict:&lt;/code&gt; crea un&amp;rsquo;istanza di &lt;code&gt;Movie&lt;/code&gt; da un dizionario JSON come quello appena mostrato: come si può vedere dall&amp;rsquo;interfaccia dichiarata, abbiamo deciso di non permettere valori nil per le varie &lt;em&gt;property&lt;/em&gt;; ma quando abbiamo a che fare con JSON &lt;strong&gt;tutto può succedere&lt;/strong&gt;, come chiavi mancanti, valori null o di tipo diverso. Useremo il tipo &lt;code&gt;Optional&lt;/code&gt; per parsare il dizionario JSON in modo chiaro, dichiarativo e a prova di errore.&lt;/p&gt;

&lt;p&gt;Iniziamo con i titolo. Dal JSON vediamo che il titolo si trova in corrispondenza della chiave &amp;ldquo;title&amp;rdquo;, e dovrebbe essere una stringa (&lt;code&gt;NSString&lt;/code&gt; in Objective-C), quindi possiamo ottenere il titolo così:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[[Optional
                        with:[dict objectForKey:@&amp;quot;title&amp;quot;]]

                       flatMap:^Optional*(id title) {
                         return [Optional with:[title isKindOfClass:[NSString class]] ? title : nil];
                       }]

                      flatMap:^Optional*(NSString* title) {
                        return [Optional with:title.length &amp;gt; 0 ? title : nil];
                      }]

                     getOrElse:^NSString*{
                       return @&amp;quot;NO TITLE&amp;quot;;
                     }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il primo &lt;code&gt;flatMap&lt;/code&gt; indica che l&amp;rsquo;oggetto &amp;ldquo;titolo&amp;rdquo; deve appartenere alla classe &lt;code&gt;NSString&lt;/code&gt;. Conviene astrarre questa operazione inserendola direttamente nel costruttore, perché l&amp;rsquo;applicheremo ogni volta per tutti i dati:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;+ (Optional *)with:(id)value as:(Class)valueClass
{
  if ([value isKindOfClass:valueClass])
  {
    return [Optional with:value];
  }
  return [Optional with:nil];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il secondo &lt;code&gt;flatMap:&lt;/code&gt; indica che se la stringa trovata ha lunghezza 0, considereremo il titolo come &amp;ldquo;sconosciuto&amp;rdquo;. In effetti questo step avrà l&amp;rsquo;effetto di &amp;ldquo;filtro&amp;rdquo;, perché lascerà &amp;ldquo;passare&amp;rdquo; solo le stringhe non vuote; considerando ciò, aggiungiamo un metodo &lt;code&gt;filter:&lt;/code&gt; alla classe &lt;code&gt;Optional&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (Optional*)filter:(BOOL(^)(id))filterBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (Optional*)filter:(BOOL (^)(id _Nonnull))filterBlock
{
  return [self flatMap:^Optional*(id value) {
    if (filterBlock(value))
    {
      return self;
    }
    else
    {
      return [Optional with:nil];
    }
  }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo &lt;code&gt;filter:&lt;/code&gt; accetta come parametro un block che ritorna un &lt;code&gt;BOOL&lt;/code&gt; basato sul valore contenuto: internamente, &lt;code&gt;filter:&lt;/code&gt; chiamerà comunque &lt;code&gt;flatMap:&lt;/code&gt;, con un&amp;rsquo;espressione condizionale che verifichi se &lt;code&gt;filterBlock&lt;/code&gt; riesce o fallisce.&lt;/p&gt;

&lt;p&gt;Infine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[Optional  
                       with:[dict objectForKey:@&amp;quot;title&amp;quot;]
                       as:[NSString class]]

                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]

                     getOrElse:^NSString*{ return @&amp;quot;NO TITLE&amp;quot;; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi, nessuna espressione condizionale, e poche linee di codice, completamente dichiarative.&lt;/p&gt;

&lt;p&gt;Per quanto riguarda i parametri &lt;code&gt;rating&lt;/code&gt; e &lt;code&gt;year&lt;/code&gt; abbiamo bisogno di un &lt;code&gt;map&lt;/code&gt; che converta &lt;code&gt;NSString&lt;/code&gt; in &lt;code&gt;NSNumber&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* rating = [[[[Optional  
                         with:[dict objectForKey:@&amp;quot;rating&amp;quot;]
                         as:[NSString class]]

                        filter:^BOOL(NSString* string) {
                          return string.length &amp;gt; 0;
                        }]

                       map:^NSNumber*(NSString* stringValue) {
                         return [NSDecimalNumber decimalNumberWithString:stringValue];
                       }]

                      getOrElse:^NSNumber*{ return @0; }];
  movie.rating = rating;

  NSNumber* year = [[[[Optional
                       with:[dict objectForKey:@&amp;quot;year&amp;quot;]
                       as:[NSString class]]

                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]

                     map:^NSNumber*(NSString* stringValue) {
                       return [NSDecimalNumber decimalNumberWithString:stringValue];
                     }]

                    getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il parametro &lt;code&gt;lengthInMinutes&lt;/code&gt; è un po&amp;rsquo; complicato; dal JSON possiamo vedere che la sua rappresentazione è la seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;runtime&amp;quot;: [ 
    &amp;quot;142 min&amp;quot; 
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi ci aspettiamo un array, del quale siamo interessati solo al primo elemento (quindi l&amp;rsquo;array non deve essere vuoto), che deve essere una stringa; di questa stringa abbiamo bisogno solo della prima parte, rimuovendo &lt;code&gt;min&lt;/code&gt;. Fortunatamente abbiamo già tutti gli strumenti necessari per procedere:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* lengthInMinutes =
  [[[[[[Optional
        with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
        as:[NSArray class]]

       flatMap:^Optional*(NSArray* array) {
         return [Optional with:[array firstObject]];
       }]

      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]

     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]

    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]

   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In realtà manca qualcosa: il metodo &lt;code&gt;[array firstObject]&lt;/code&gt; ritorna il primo oggetto dell&amp;rsquo;array se questo ha almeno un elemento, oppure ritorna nil se l&amp;rsquo;array è vuoto: non c&amp;rsquo;è alcuna indicazione sul fatto che vogliamo che il primo elemento sia di tipo &lt;code&gt;NSString&lt;/code&gt;, quindi dobbiamo aggiungere uno step &lt;code&gt;filter&lt;/code&gt; per assicurarci che la classe dell&amp;rsquo;istanza trovata sia corretta. Quindi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* lengthInMinutes =
  [[[[[[[Optional
         with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
         as:[NSArray class]]

        flatMap:^id(NSArray* array) {
          return [Optional with:[array firstObject]];
        }]

       filter:^BOOL(id value) {
         return [value isKindOfClass:[NSString class]];
       }]

      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]

     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]

    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]

   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come possiamo vedere, lavorando con la classe &lt;code&gt;Optional&lt;/code&gt;, aggiungere una condizione significa semplicemente &lt;strong&gt;aggiungere uno step&lt;/strong&gt; nella sequenza lineare di espressioni.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusione:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Conclusione&lt;/h2&gt;

&lt;p&gt;Implementare la classe &lt;code&gt;Optional&lt;/code&gt; in Objective-C ci ha permesso di parsare un JSON, cosa spesso difficile da mantenere e soggetta a errori, in un modo semplice e lineare. In realtà ci sono &lt;strong&gt;molti casi&lt;/strong&gt; in cui lavorare con gli &lt;em&gt;optionals&lt;/em&gt; ci può dare gli stessi vantaggi: componendo operazioni di tipo &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; e &lt;code&gt;filter&lt;/code&gt; possiamo esprimere il nostro intento in maniera chiara e leggibile. Ma tutto questo non riguarda solo il tipo &lt;code&gt;Optional&lt;/code&gt;: alcuni lettori avranno probabilmente notato che molti linguaggi (incluso Swift) permettono operazioni dell stesso tipo su liste e array, e il loro significato è identico: &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt;, in particolare, sono &lt;strong&gt;concetti generici&lt;/strong&gt; legati ai &lt;em&gt;monad&lt;/em&gt; (in effetti, anche il tipo &lt;code&gt;Array&lt;/code&gt; è un &lt;em&gt;monad&lt;/em&gt;), e riguarda la composizione dichiarativa di trasformazioni. Questo concetto è alla base della &lt;strong&gt;programmazione funzionale&lt;/strong&gt;, e penso ci siano molti motivi per applicare concetti simili ad ambienti più &lt;em&gt;object-oriented&lt;/em&gt;, perché aiuterebbero il programmatore a ragionare sul codice ed esprimere l&amp;rsquo;intento in maniera più dichiarativa.&lt;/p&gt;

&lt;p&gt;Il codice per la classe &lt;code&gt;Optional&lt;/code&gt; mostrata nell&amp;rsquo;articolo è reperibile su &lt;a href=&#34;https://gist.github.com/broomburgo/e318228a5f7d6a605e82&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paraunit: test paralleli, Doctrine e le fixture</title>
      <link>/blog/ita/paraunit/</link>
      <pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/paraunit/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Questo articolo è la sintesi di un talk presentato al &lt;a href=&#34;http://2015.symfonyday.it/&#34;&gt;SymfonyDay 2015&lt;/a&gt;; potete trovare le slide &lt;a href=&#34;http://jean85.github.io/slides/2015-10-paraunit-symfonyday/index.html&#34;&gt;qui&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;i-test-e-la-loro-durata:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;I test e la loro durata&lt;/h4&gt;

&lt;p&gt;Sviluppare applicazioni scrivendo &lt;strong&gt;test&lt;/strong&gt; e facendo &lt;a href=&#34;https://it.wikipedia.org/wiki/Test_driven_development&#34;&gt;Test Driven Development&lt;/a&gt; è un&amp;rsquo;ottima pratica, e dà parecchie soddisfazioni. Con l&amp;rsquo;andare del tempo, si fa &lt;strong&gt;crescere la suite di test&lt;/strong&gt; del proprio progetto, cercando di aumentarne la copertura e l&amp;rsquo;efficacia e si scrivono nuovi test corrispondenti alle nuove funzionalità che vengono man mano sviluppate.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;aumento della quantità di test però porta alla crescita (direttamente proporzionale) del &lt;strong&gt;tempo necessario&lt;/strong&gt; ad eseguire i test stessi.
Nel caso dei &lt;strong&gt;test unitari&lt;/strong&gt; questo aumento è spesso trascurabile, poiché &lt;strong&gt;si limitano a caricare una singola classe&lt;/strong&gt; e ad analizzarne il comportamento in completo isolamento, terminando la loro esecuzione nel giro di &lt;strong&gt;pochi millisecondi&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Quando invece parliamo di &lt;strong&gt;test funzionali&lt;/strong&gt;, il tempo di esecuzione non è più così limitato: vengono caricate &lt;strong&gt;molte più classi&lt;/strong&gt;, spesso viene coinvolto anche il &lt;strong&gt;database&lt;/strong&gt;, deve essere messa alla prova l&amp;rsquo;interazione tra molti elementi; il tutto porta a test la cui durata è talvolta di &lt;strong&gt;quasi un secondo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Leggendo libri e blog sull&amp;rsquo;argomento, e con l&amp;rsquo;esperienza personale, ho imparato che c&amp;rsquo;è una &lt;strong&gt;soglia critica&lt;/strong&gt; che rappresenta il limite ideale oltre il quale una test suite diventa troppo lenta, e questa soglia è di &lt;strong&gt;circa dieci minuti&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ma perché proprio dieci minuti? Il motivo è molto semplice, e pratico: in dieci minuti, il programmatore può fare una pausa, prendersi un caffè o decidere di discutere brevemente una questione tecnica con un collega, e al suo ritorno troverà la suite completata e potrà procedere col lavoro. In caso contrario, possono succedere due cose:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;il programmatore &lt;strong&gt;rimane a fissare lo schermo&lt;/strong&gt; mentre i test si eseguono, dando ragione ai detrattori dei test che affermano che fare TDD è una perdita di tempo;&lt;/li&gt;
&lt;li&gt;si &lt;strong&gt;smette di eseguire la test suite&lt;/strong&gt;, o per lo meno di farla eseguire per intero.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La seconda opzione può sembrare fattibile: si fanno girare solo i &lt;strong&gt;test strettamente necessari&lt;/strong&gt; mentre si sviluppa, quelli che vengono scritti in quel momento o che coprono la parte di codice che si sta modificando, per poi eseguire il commit del proprio codice senza far girare l&amp;rsquo;intera suite.&lt;/p&gt;

&lt;p&gt;In realtà &lt;strong&gt;questo approccio fa perdere valore ai test&lt;/strong&gt; stessi, perché i test sono codice che non andrà mai in produzione, e che quindi può dare valore ai nostri progetti solo se viene eseguito ogni volta. Inoltre questo approccio nasconde &lt;strong&gt;una trappola&lt;/strong&gt;, dato che i test, per essere davvero efficaci, vanno eseguiti tutti ogni volta: la loro forza sta proprio nell&amp;rsquo;&lt;strong&gt;individuare gli effetti collaterali&lt;/strong&gt; imprevisti delle nostre modifiche, i bug che possono presentarsi in punti inaspettati e apparentemente lontani del nostro progetto.&lt;/p&gt;

&lt;h4 id=&#34;esecuzione-parallela-dei-test:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;Esecuzione parallela dei test&lt;/h4&gt;

&lt;p&gt;In Facile.it lavoro in un progetto basato su Symfony2 e Doctrine e mi sono trovato proprio davanti a questa problematica: avevamo una &lt;strong&gt;suite di test che stava crescendo&lt;/strong&gt; a ritmo sostenuto e che a volte impiegava ad eseguirsi, tra build di preparazione ed esecuzione vera e propria, anche 25 minuti.&lt;/p&gt;

&lt;p&gt;Dopo aver ottimizzato le prestazioni del nostro ambiente di sviluppo (passando da Vagrant a Docker, ma questa è un&amp;rsquo;altra storia), ci siamo resi conto di aver bisogno di una soluzione più drastica al nostro problema, e abbiamo pensato di &lt;strong&gt;eseguire in parallelo i nostri test&lt;/strong&gt; per sfruttare al meglio le risorse hardware e ridurre così i tempi di esecuzione.&lt;/p&gt;

&lt;p&gt;Dopo un po&amp;rsquo; di ricerche, abbiamo individuato alcuni tool esistenti che permettevano questo approccio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/brianium/paratest&#34;&gt;brianium/paratest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/liuggio/fastest&#34;&gt;liuggio/fastest&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Entrambi i tool sono ben sviluppati e semplici da utilizzare e le prime prove sui &lt;strong&gt;test unitari&lt;/strong&gt; sono state molto promettenti: grazie alla ridotta dimensione, la loro parallelizzazione è estremamente semplice.&lt;/p&gt;

&lt;h4 id=&#34;i-problemi-di-concorrenza-nei-test-funzionali:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;I problemi di concorrenza nei test funzionali&lt;/h4&gt;

&lt;p&gt;Quando siamo passati a provare Paratest sui &lt;strong&gt;test funzionali&lt;/strong&gt; abbiamo invece incontrato grossi problemi, che si concretizzavano in &lt;strong&gt;fallimenti casuali durante l&amp;rsquo;esecuzione parallela&lt;/strong&gt;. Questi fallimenti erano dati da un problema molto semplice: stavamo accedendo più volte e in parallelo al nostro database di test.&lt;/p&gt;

&lt;p&gt;Ma perché il nostro codice, che è lo stesso che viene eseguito in produzione (dove elabora centinaia, migliaia di richieste al minuto) ha così tanti &lt;strong&gt;problemi di accesso concorrente&lt;/strong&gt; nell&amp;rsquo;ambiente di test? I motivi sono semplici:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;i dati di test sono pochi&lt;/strong&gt;, mentre in produzione abbiamo tabelle da milioni di righe;&lt;/li&gt;
&lt;li&gt;per questo motivo &lt;strong&gt;i test tentano di accedere sempre alle stesse righe&lt;/strong&gt; del database;&lt;/li&gt;
&lt;li&gt;la &lt;strong&gt;sequenza&lt;/strong&gt; di operazioni di ogni test in genere è &lt;strong&gt;lettura - elaborazione - scrittura&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;i test hanno una &lt;strong&gt;rapidità di esecuzione&lt;/strong&gt; superiore a quella di un utilizzatore umano.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tutti questi motivi contribuiscono a creare situazioni in cui &lt;strong&gt;si verificano dei &lt;a href=&#34;https://it.wikipedia.org/wiki/Deadlock&#34;&gt;deadlock&lt;/a&gt;&lt;/strong&gt; e che il nostro database può risolvere solo bloccando uno dei due tentativi di accesso ai dati, facendo così fallire il test corrispondente.&lt;/p&gt;

&lt;p&gt;Un altro problema che può verificarsi è l&amp;rsquo;&lt;strong&gt;alterazione dei dati&lt;/strong&gt;: quando due test vengono eseguiti in contemporanea, uno dei due può modificare il database e, così facendo, può far mancare i giusti dati di partenza ad un altro test che si sta avviando nello stesso istante.&lt;/p&gt;

&lt;p&gt;Purtroppo &lt;strong&gt;Paratest non offre una soluzione&lt;/strong&gt; a questo genere di problemi, mentre Fastest propone come approccio la creazione di un database di test differente per ogni core del proprio processore, per poi eseguire tanti test in parallelo quanti sono i database a disposizione.&lt;/p&gt;

&lt;p&gt;Sfortunatamente anche questo approccio non ci ha soddisfatto, in quanto la costruzione del nostro database di test era piuttosto lenta (avevamo molte migration da eseguire e altrettante fixture da caricare ogni volta) e rischiavamo di guadagnare tempo da una parte per perderlo dall&amp;rsquo;altra, inoltre, avevamo avuto &lt;strong&gt;un&amp;rsquo;idea nuova&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;facile-it-paraunit:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;facile-it/paraunit&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/facile-it/paraunit&#34;&gt;&lt;img src=&#34;https://poser.pugx.org/facile-it/paraunit/version.svg&#34; alt=&#34;Packagist&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://travis-ci.org/facile-it/paraunit&#34;&gt;&lt;img src=&#34;https://travis-ci.org/facile-it/paraunit.svg&#34; alt=&#34;Travis build&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://codeclimate.com/github/facile-it/paraunit&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/facile-it/paraunit/badges/gpa.svg&#34; alt=&#34;Codeclimate&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://coveralls.io/github/facile-it/paraunit?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/facile-it/paraunit/badge.svg?branch=master&amp;amp;service=github&#34; alt=&#34;Coverage&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Abbiamo così deciso di sviluppare la nostra soluzione: &lt;strong&gt;&lt;a href=&#34;https://github.com/facile-it/paraunit&#34;&gt;facile-it/paraunit&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;è sviluppato con i &lt;strong&gt;componenti Symfony&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sa leggere la configurazione XML di PHPUnit&lt;/strong&gt; per individuare le test suite;&lt;/li&gt;
&lt;li&gt;esegue il &lt;strong&gt;parsing e l&amp;rsquo;aggregazione dei risultati&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;grazie ai processi separati, &lt;strong&gt;sa gestire i fatal error&lt;/strong&gt; senza far bloccare completamente l&amp;rsquo;esecuzione;&lt;/li&gt;
&lt;li&gt;sempre grazie ai processi, riesce ad &lt;strong&gt;ottimizzare l&amp;rsquo;uso della memoria&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;risulta &lt;strong&gt;affidabile&lt;/strong&gt; grazie al fatto che basa il suo responso sugli exit code dei singoli processi PHPUnit.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La maggior parte di questi vantaggi sono ovviamente comuni a tutti gli approcci di parallelizzazione dei test, inoltre, grazie al parsing dei risultati, &lt;strong&gt;Paraunit sa riconoscere i casi di fallimento dovuti a deadlock&lt;/strong&gt; e riesegue i test che falliscono per questo motivo.&lt;/p&gt;

&lt;p&gt;Questo però era solo un primo passo e ovviamente ci siamo concentrati sull&amp;rsquo;implementare una &lt;strong&gt;soluzione radicale ai problemi di concorrenza&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;facile-it-paraunit-testcase:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;facile-it/paraunit-testcase&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://packagist.org/packages/facile-it/paraunit-testcase&#34;&gt;&lt;img src=&#34;https://poser.pugx.org/facile-it/paraunit-testcase/version.svg&#34; alt=&#34;Packagist&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;La soluzione che abbiamo trovato è molto semplice: &lt;strong&gt;le transazioni&lt;/strong&gt;.
Per realizzarla nella sua totalità, abbiamo sviluppato un test-case per PHPUnit, rilasciato col pacchetto &lt;strong&gt;&lt;a href=&#34;https://github.com/facile-it/paraunit-testcase&#34;&gt;facile-it/paraunit-testcase&lt;/a&gt;&lt;/strong&gt;; ovviamente il test-case è stato sviluppato in partenza per il nostro caso d&amp;rsquo;uso, ovvero per il &lt;strong&gt;test di un&amp;rsquo;applicazione basata su Symfony2 e Doctrine&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Grazie a questo test-case, ogni test può accedere al database solo dentro una transazione e questa transazione non riceve mai il &lt;em&gt;commit&lt;/em&gt;, ma sempre il &lt;strong&gt;rollback&lt;/strong&gt; al termine. Questo significa che &lt;strong&gt;nulla verrà mai realmente scritto&lt;/strong&gt; sul nostro database.&lt;/p&gt;

&lt;p&gt;I vantaggi di questo approccio sono molteplici:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;nessun test può interferire&lt;/strong&gt; con gli altri, visto che non possono alterare i dati;&lt;/li&gt;
&lt;li&gt;ogni test può permettersi di &lt;strong&gt;creare al volo un dato o di alterarne uno esistente&lt;/strong&gt;, senza doversi preoccupare di ripulire il database al termine, con grande risparmio di tempo nella scrittura dei test;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;il database di test rimane sempre pulito&lt;/strong&gt; e non dobbiamo più preoccuparci di prepararlo ogni volta che la suite deve essere eseguita, o che eseguiamo un test che può sporcare i dati;&lt;/li&gt;
&lt;li&gt;anche se non viene mai realmente scritto nulla, &lt;strong&gt;il database esegue comunque le verifiche di integrità&lt;/strong&gt;, quali vincoli di unicità o di chiavi esterne;&lt;/li&gt;
&lt;li&gt;diventa &lt;strong&gt;impossibile avere test interdipendenti&lt;/strong&gt;, ovvero test che possono funzionare solo se prima ne vengono eseguiti altri, che modificano in modo ideale i dati di fixture.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;L&amp;rsquo;unico limite di questo approccio è che le transazioni sono disponibili solo con alcuni database e all&amp;rsquo;interno di Doctrine quindi solo con l&amp;rsquo;&lt;code&gt;EntityManager&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;la-rapidità-di-esecuzione:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;La rapidità di esecuzione&lt;/h4&gt;

&lt;p&gt;Per darvi un&amp;rsquo;idea di quanto possa essere veloce Paraunit rispetto alla normale esecuzione con PHPUnit, ho misurato il tempo di esecuzione della nostra test suite funzionale, che è sufficientemente ampia (261 classi, 1568 metodi):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/paraunit/grafico.png&#34; alt=&#34;Grafico&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Come potete vedere, Paraunit esegue l&amp;rsquo;intera test suite in soli &lt;strong&gt;6 minuti e 6 secondi&lt;/strong&gt;, mentre PHPUnit ci metterebbe &lt;strong&gt;oltre 40 minuti!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ho usato il condizionale per un motivo specifico: il tempo di esecuzione di PHPUnit è in realtà una stima (in proiezione lineare) perché, circa al 12% dell&amp;rsquo;esecuzione, il processo si è chiuso per &lt;strong&gt;esaurimento della memoria&lt;/strong&gt; a disposizione, a riprova di un altro dei vantaggi nell&amp;rsquo;uso di Paraunit.&lt;/p&gt;

&lt;h4 id=&#34;test-coverage-in-parallelo:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;Test coverage in parallelo&lt;/h4&gt;

&lt;p&gt;Un&amp;rsquo;altra caratteristica di Paraunit, attualmente in sviluppo, è la possibilità di &lt;strong&gt;parallelizzare l&amp;rsquo;elaborazione della &lt;a href=&#34;https://phpunit.de/manual/current/en/code-coverage-analysis.html&#34;&gt;coverage&lt;/a&gt;&lt;/strong&gt; dei test.&lt;/p&gt;

&lt;p&gt;Questo è possibile grazie all&amp;rsquo;opzione &lt;code&gt;--coverage-php&lt;/code&gt; di PHPUnit che salva in un file .php il risultato parziale ottenuto; dopo aver lanciato i singoli test come processi separati, Paraunit esegue l&amp;rsquo;unione di tutti questi risultati.&lt;/p&gt;

&lt;h4 id=&#34;sviluppi-futuri:f5798a251e9e47af9f9c30a07b87b80c&#34;&gt;Sviluppi futuri&lt;/h4&gt;

&lt;p&gt;Ovviamente questo è solo l&amp;rsquo;inizio, il primo &lt;strong&gt;rilascio in open source&lt;/strong&gt; della nostra soluzione.
Tra gli sviluppi futuri spero di poter realizzare:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la &lt;strong&gt;prioritizzazione dei test lenti&lt;/strong&gt;, ovvero poter eseguire per primi i test noti per la loro lentezza, così da non rallentare l&amp;rsquo;esecuzione complessiva della test suite;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;aggiunta di &lt;strong&gt;altre opzioni&lt;/strong&gt; di selezione test, come p.e. l&amp;rsquo;opzione &lt;code&gt;--group&lt;/code&gt; di PHPUnit;&lt;/li&gt;
&lt;li&gt;il miglioramento delle &lt;strong&gt;prestazioni&lt;/strong&gt; all&amp;rsquo;avvio dei processi, cosa che pesa molto per i test unitari;&lt;/li&gt;
&lt;li&gt;il &lt;strong&gt;supporto per altri framework e ORM&lt;/strong&gt; oltre a Symfony e Doctrine, creando altri test-case appositi;&lt;/li&gt;
&lt;li&gt;il miglioramento della funzionalità di test coverage parallela;&lt;/li&gt;
&lt;li&gt;una soluzione per i database non transazionali, come MongoDB.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vi invito quindi a partecipare allo sviluppo di Paraunit su &lt;a href=&#34;https://github.com/facile-it/paraunit&#34;&gt;GitHub&lt;/a&gt;, proponendo pull request, aprendo issue per proporre nuove feature o anche semplicemente utilizzandolo per le vostre test suite, così da verificarne l&amp;rsquo;efficacia e la compatibilità!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>No Country For If Else</title>
      <link>/blog/ita/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/no-country-for-if-else/</guid>
      <description>

&lt;p&gt;C&amp;rsquo;è un &lt;strong&gt;ospite indesiderato&lt;/strong&gt; che ci accompagna sempre mentre scriviamo codice e realizziamo progetti software: si tratta del &lt;strong&gt;codice già esistente&lt;/strong&gt;, e dobbiamo tener conto della sua complessità man mano che la &lt;em&gt;code base&lt;/em&gt; aumenta di dimensioni. Un&amp;rsquo;elevata complessità del codice può rendere le seguenti attività particolarmente difficili:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;comprendere il significato di codice vecchio, scritto da altri o da se stessi;&lt;/li&gt;
&lt;li&gt;tracciare le cause di bug, cioè errori, nel codice;&lt;/li&gt;
&lt;li&gt;eseguire modifiche a una certa procedura;&lt;/li&gt;
&lt;li&gt;aggiungere funzionalità a strutture già esistenti;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Anche approcciando lo sviluppo di nuovo software con &lt;a href=&#34;https://en.wikipedia.org/wiki/Agile_software_development&#34;&gt;metodologie agili&lt;/a&gt;, dobbiamo comunque fare i conti con il codice esistente, e per farlo dobbiamo almeno essere in grado di &lt;strong&gt;comprenderlo senza sforzi eccessivi&lt;/strong&gt;. Dunque quando parlo di &lt;em&gt;complessità&lt;/em&gt; mi riferisco in particolare alla difficoltà con la quale una programmatore è in grado di &lt;em&gt;ragionare&lt;/em&gt; sul codice. La prefazione del noto testo accademico &lt;a href=&#34;http://deptinfo.unice.fr/~roy/sicp.pdf&#34;&gt;Structure and interpretation of computer programs&lt;/a&gt; contiene la seguente frase:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Non potrei essere più d&amp;rsquo;accordo: il tempo speso da un programmatore a scrivere nuovo codice rappresenta solo &lt;strong&gt;una minima parte&lt;/strong&gt; del suo tempo totale di lavoro; molto tempo è passato a leggere il codice esistente, per correggerlo, estenderlo, modificarlo o semplicemente comprenderlo. Generando codice più comprensibile, sul quale sia più semplice ragionare, possiamo valutare più facilmente la &lt;strong&gt;correttezza&lt;/strong&gt; di quanto abbiamo scritto o, in caso di comportamento non atteso, trovare agevolmente l&amp;rsquo;errore. Ovviamente tutto questo non deve prescindere dalle tecniche che abitualmente utilizziamo per testare la correttezza del software &lt;em&gt;a posteriori&lt;/em&gt;: d&amp;rsquo;altronde, nessuna disciplina tecnico/scientifica è esente da verifiche empiriche, e in effetti l&amp;rsquo;approccio empirico all&amp;rsquo;ingegneria del software è preso in considerazione anche in ambito accademico, come dimostra l&amp;rsquo;&lt;a href=&#34;http://static.springer.com/sgw/documents/1525357/application/pdf/10664_JournalMetrics_Flyer.pdf&#34;&gt;esistenza&lt;/a&gt; della rivista &lt;a href=&#34;http://link.springer.com/journal/10664&#34;&gt;Empirical Software Engineering&lt;/a&gt;. La mia personale posizione è nel mezzo: il testing è importante, ma è anche importante ragionare &lt;em&gt;a priori&lt;/em&gt; sul proprio design, sulla sua correttezza, e sulla presenza di eventuale &lt;strong&gt;complessità accidentale&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice:c252b88516f644ca0545d16795aa645d&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#l-importanza-dell-astrazione&#34;&gt;L&amp;rsquo;importanza dell&amp;rsquo;astrazione&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#misurare-la-complessita&#34;&gt;Misurare la complessità&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-strutturata&#34;&gt;Esempio: soluzione strutturata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-oo&#34;&gt;Esempio: soluzione OO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-funzionale&#34;&gt;Esempio: soluzione funzionale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#una-verifica-empirica&#34;&gt;Una verifica empirica&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusioni&#34;&gt;Conclusioni&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;l-importanza-dell-astrazione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;l-importanza-dell-astrazione:c252b88516f644ca0545d16795aa645d&#34;&gt;L&amp;rsquo;importanza dell&amp;rsquo;astrazione&lt;/h2&gt;

&lt;p&gt;Come abbiamo visto in un &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/&#34;&gt;precedente articolo&lt;/a&gt;, più che della complessità intrinseca legata alla logica del nostro software, dobbiamo preoccuparci della &lt;a href=&#34;http://shaffner.us/cs/papers/tarpit.pdf&#34;&gt;complessità accidentale&lt;/a&gt; che introduciamo adottando &lt;strong&gt;soluzioni non ottimali e inutilmente complicate&lt;/strong&gt;: l&amp;rsquo;utilizzo eccessivo di strutture di controllo &lt;em&gt;if-else-for-switch&lt;/em&gt; tende a rendere il codice difficile da comprendere, da mantenere e da testare; si veda ad esempio il noto &lt;a href=&#34;http://c2.com/cgi/wiki?ArrowAntiPattern&#34;&gt;Arrow Anti-Pattern&lt;/a&gt;. È da notare che l&amp;rsquo;introduzione della &lt;a href=&#34;https://en.wikipedia.org/wiki/Structured_programming&#34;&gt;programmazione &lt;em&gt;strutturata&lt;/em&gt;&lt;/a&gt;, cioè quella basata proprio sulle strutture di controllo appena citate, ha rappresentato &lt;strong&gt;un grande passo avanti&lt;/strong&gt; nello sviluppo del software a cavallo tra gli anni &amp;lsquo;60 e &amp;lsquo;70: essa ha permesso di programmare a un più alto livello di astrazione rispetto allo stile precedente, rimuovendo la necessità di gestire manualmente l&amp;rsquo;ordine di esecuzione del codice con il &lt;a href=&#34;https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF&#34;&gt;famigerato&lt;/a&gt; comando &lt;code&gt;goto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I paradigmi di sviluppo cambiano quando i programmatori si ritrovano a dover gestire progetti sempre più corposi e complessi: per evitare di essere imbrigliati dalla eccessiva complessità del proprio codice, o del codice scritto altri che ci troviamo comunque a mantenere, dobbiamo lavorare a &lt;strong&gt;più alti livelli di astrazione&lt;/strong&gt;. Quanto alti? Una buona risposta a questa domanda potrebbe essere la seguente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;a un elevato livello di astrazione possiamo dire al sistema di fare ciò che vogliamo, senza specificare come farlo&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A un adeguato livello di astrazione possiamo concentrarci sul &lt;em&gt;cosa&lt;/em&gt; lasciando che sia il sistema a decidere il &lt;em&gt;come&lt;/em&gt;. Ovviamente non esiste un &amp;ldquo;massimo&amp;rdquo; livello di astrazione, e in quanto programmatori ci troviamo sempre a lavorare &lt;strong&gt;a metà strada&lt;/strong&gt; tra le cariche elettriche in movimento in un microprocessore, e le necessità di business della nostra azienda: dobbiamo tuttavia essere in grado di identificare i casi nei quali stiamo lavorando a un livello di astrazione troppo basso, poiché a tale livello può aumentare molto il rischio di fare errori e introdurre complessità accidentale. Ad esempio, nel momento in cui usiamo una struttura di controllo come &lt;em&gt;if-else&lt;/em&gt; all&amp;rsquo;interno di una procedura relativamente grande, stiamo &lt;em&gt;manualmente&lt;/em&gt; prendendo una decisione in base allo stato del nostro sistema: molto meglio sarebbe sviluppare un elemento software, ad esempio un oggetto, che sia in grado di &lt;strong&gt;prendere quella decisione al posto nostro&lt;/strong&gt;; il nostro ruolo, a quel punto, sarà &lt;em&gt;dichiarare&lt;/em&gt; la funzionalità di quell&amp;rsquo;elemento. Mescolare il &lt;em&gt;cosa&lt;/em&gt; con il &lt;em&gt;come&lt;/em&gt; è una delle principali cause di difficoltà nel comprendere cosa fa un blocco di codice, perché può portare all&amp;rsquo;oscuramento dell&amp;rsquo;&lt;strong&gt;intento&lt;/strong&gt; di una procedura, legato alla logica di business, con i &lt;strong&gt;dettagli di implementazione&lt;/strong&gt;, che sono concetti separati e spesso del tutto indipendenti (uno stesso intento può essere realizzato con diverse implementazioni a più basso livello).&lt;/p&gt;

&lt;p&gt;Vediamo un semplice esempio. Supponiamo di avere la seguente funzione:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue1(value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	var x: A?
	if cond1 == true {
		if cond2 == true {
			x = nil
		}
		else {
			x = value
		}
	}
	else {
		if cond2 == true {
			x = value
		}
		else {
			x = nil
		}
	}
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anche se la funzione è piuttosto semplice, non è immediatamente evidente cosa stia succedendo; vediamolo passo-passo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;è dichiarata una variabile &lt;code&gt;x&lt;/code&gt; di tipo &lt;code&gt;A?&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;si verifica la prima condizione:

&lt;ul&gt;
&lt;li&gt;se la prima condizione è vera, si verifica la seconda condizione:

&lt;ul&gt;
&lt;li&gt;se la seconda condizione è vera, la variabile è impostata a &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;se la seconda condizione è falsa, la variabile è impostata a &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se la prima condizione è falsa, si verifica la seconda condizione:

&lt;ul&gt;
&lt;li&gt;se la seconda condizione è vera, la variabile è impostata a &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;se la seconda condizione è falsa, la variabile è impostata a  &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;è ritornata la variabile &lt;code&gt;x&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basta pensarci un attimo per capire che, perché a &lt;code&gt;x&lt;/code&gt; venga assegnato &lt;code&gt;value&lt;/code&gt; le due condizioni devono essere semplicemente diverse tra loro. Possiamo inoltre pensare a un&amp;rsquo;altra semplificazione: non è necessario dichiarare la variabile &lt;code&gt;x&lt;/code&gt;, basta ritornare &lt;code&gt;value&lt;/code&gt; se le due condizioni sono diverse, altrimenti ritornare &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue2(value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	return cond1 != cond2 ? value : nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo semplificato molto la funzione, rendendola più facile da comprendere: ora &lt;strong&gt;basta un&amp;rsquo;occhiata&lt;/strong&gt; per capire cosa fa. Ma in un caso più complesso, con tante diverse condizioni e percorsi possibili, può non bastare semplificare le condizioni.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;misurare-la-complessita&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;misurare-la-complessità:c252b88516f644ca0545d16795aa645d&#34;&gt;Misurare la complessità&lt;/h2&gt;

&lt;p&gt;Un&amp;rsquo;unità di misura presa spesso in considerazione nel valutare la complessità di un metodo o una funzione è la &lt;a href=&#34;https://en.wikipedia.org/wiki/Cyclomatic_complexity&#34;&gt;complessità ciclomatica&lt;/a&gt; (CC): essa rappresenta il livello di complessità generato dall&amp;rsquo;uso di molteplici strutture di controllo in un metodo o una funzione. È possibile calcolare il numero di CC per una procedura strutturata rappresentando quest&amp;rsquo;ultima con un &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_graph&#34;&gt;grafo diretto&lt;/a&gt; e contando il numero di archi e nodi. Ad esempio, possiamo rappresentare la funzione &lt;code&gt;optionalValue1&lt;/code&gt; con il seguente grafo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(value,cond1,cond2)]
|
|-&amp;gt; [var x] -&amp;gt; [cond1 == true ?]
               |
               |-y-&amp;gt; [cond2 == true ?]
               |     |
               |     |-y-&amp;gt; [x = nil] --------|
               |     |-n-&amp;gt; [x = value] ------|
               |                             |
               |-n-&amp;gt; [cond2 == true ?]       |
                     |                       |
                     |-y-&amp;gt; [x = value] ------|
                     |-n-&amp;gt; [x = nil] --------|
                                             |-&amp;gt; [return x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per un singolo grafo connesso, il numero di CC è calcolabile in base alla seguente formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC = [numero archi] - [numero nodi] + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per la funzione &lt;code&gt;defaultValue1&lt;/code&gt; si può vedere che CC = 4. Apparentemente la versione semplificata &lt;code&gt;defaulValue2&lt;/code&gt; ha una complessità ciclomatica inferiore, ma in realtà, come indicato anche nella &lt;a href=&#34;http://www.literateprogramming.com/mccabe.pdf&#34;&gt;pubblicazione originale&lt;/a&gt; di T.J.McCabe, CC vale solo per una procedura &lt;em&gt;completamente strutturata&lt;/em&gt;, cioè una procedura con un solo punto di ingresso e un solo punto di uscita; inoltre CC dovrebbe tener conto di &lt;strong&gt;tutti i casi possibili&lt;/strong&gt; quando si verifica una condizione, e &lt;code&gt;if cond1 != cond2&lt;/code&gt; ha appunto 4 casi possibili. Una trattazione delle possibili evoluzioni di CC tenendo conto di molteplici punti di ingresso e uscita per un modulo è disponibile &lt;a href=&#34;http://www.acis.pamplin.vt.edu/faculty/tegarden/wrk-pap/SQJ.PDF&#34;&gt;qui&lt;/a&gt;. Quindi non terremo conto di CC nel resto dell&amp;rsquo;articolo per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la complessità che ci interessa è quella relativa alla &amp;ldquo;comprensibilità&amp;rdquo; di una funzione, e spesso pattern non strutturati (come &lt;code&gt;guard clause&lt;/code&gt;,&lt;code&gt;return&lt;/code&gt; anticipati o &lt;em&gt;conditional expression&lt;/em&gt; come quella prodotta dall&amp;rsquo;operatore ternario &lt;code&gt;?:&lt;/code&gt;) rendono una funzione o un metodo più semplici da capire;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;obiettivo è scrivere un programma componendo tante piccole funzioni la cui complessità sia la &lt;strong&gt;minima possibile&lt;/strong&gt; (nessuna struttura di controllo), quindi avrà poco valore misurare il numero di CC per ogni funzione;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mi è parso comunque importante citare la complessità ciclomatica in questo articolo, ma più che &lt;em&gt;misurare&lt;/em&gt; la complessità accidentale, siamo interessati a &lt;strong&gt;rimuoverla del tutto&lt;/strong&gt;, sostituendo le decisioni condizionali tipiche della programmazione strutturata con qualcos&amp;rsquo;altro. È da notare che una &lt;em&gt;espressione&lt;/em&gt; condizionale rappresenta un concetto &lt;strong&gt;più semplice&lt;/strong&gt; rispetto a una &lt;em&gt;istruzione&lt;/em&gt; condizionale: nel primo caso, l&amp;rsquo;intera espressione ritorna semplicemente un valore in base a una o più condizioni; nel secondo caso, una o più istruzioni potrebbero essere eseguite o meno in base allo stato del sistema.&lt;/p&gt;

&lt;p&gt;Immaginiamo di avere una funzione di questo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func getCorrectValueConsideringConditions &amp;lt;A&amp;gt; (#cond1: Condition&amp;lt;A&amp;gt;, cond2: Condition&amp;lt;A&amp;gt;, cond3: Condition&amp;lt;A&amp;gt; ...) -&amp;gt; A? {
	/// do stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo caso possiamo avere un gran numero di condizioni legate a un valore di tipo &lt;code&gt;A&lt;/code&gt;, e potrebbe essere necessario valutare ciascuna di queste con diversi &lt;em&gt;if-else&lt;/em&gt; e/o &lt;em&gt;switch&lt;/em&gt; annidati. Un modo per risolvere questo problema può consistere nell&amp;rsquo;&lt;em&gt;astrarre&lt;/em&gt; il concetto stesso di &lt;em&gt;condizione&lt;/em&gt;, trasformandolo in una &lt;em&gt;relazione statica&lt;/em&gt; tra un qualche parametro e un valore di tipo &lt;code&gt;A&lt;/code&gt;: dovremmo quindi realizzare un sistema che sia in grado di &lt;em&gt;risolvere&lt;/em&gt; un qualunque numero di relazioni, possibilmente in un &lt;strong&gt;qualunque ordine&lt;/strong&gt;, e in base ad esse dedurre il valore risultante.&lt;/p&gt;

&lt;p&gt;Vediamo un esempio pratico.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-strutturata&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-strutturata:c252b88516f644ca0545d16795aa645d&#34;&gt;Esempio: soluzione strutturata&lt;/h2&gt;

&lt;p&gt;Una persona si reca all&amp;rsquo;ufficio di collocamento per cercare lavoro: in base ad alcuni attributi (preferenze, giovane/anziano, numero di figli di età inferiore ai 18 anni) essa può essere inviata a un certo sportello per selezionare un impiego tra i vari disponibili, oppure mandata fuori dall&amp;rsquo;ufficio nel caso in cui il set di attributi non generi una lista di lavori accettabili. Ecco la procedura completa (non è importante il realismo, è solo un esempio):&lt;/p&gt;

&lt;p&gt;Un persona &lt;strong&gt;p1&lt;/strong&gt; arriva allo sportello &lt;strong&gt;d1&lt;/strong&gt; per cercare un impiego; &lt;strong&gt;p1&lt;/strong&gt; ha una lista di preferenze lavorative, ma potrebbe accettare anche altri lavori fuori lista; &lt;strong&gt;p1&lt;/strong&gt; ha inoltre una lista di lavori che di sicuro non accetterebbe mai;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; è giovane si ottiene da &lt;strong&gt;p1&lt;/strong&gt; una lista &lt;strong&gt;l1&lt;/strong&gt; di preferenze;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;l1&lt;/strong&gt; è troppo piccola, si chiede a &lt;strong&gt;p1&lt;/strong&gt; di ingrandire la lista con preferenze secondarie;&lt;/li&gt;
&lt;li&gt;si inseriscono le preferenze nel sistema e si ottiene una lista &lt;strong&gt;l2&lt;/strong&gt; di posizioni disponibili;&lt;/li&gt;
&lt;li&gt;se la lista &lt;strong&gt;l2&lt;/strong&gt; è vuota, si chiede a &lt;strong&gt;p1&lt;/strong&gt; se vuole visualizzare la lista completa delle posizioni;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d2&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; è anziano, si chiede a &lt;strong&gt;p1&lt;/strong&gt; di scegliere dalla lista &lt;strong&gt;l3&lt;/strong&gt; dei lavori adatti per gli anziani;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d3&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha figli, in ogni caso la lista delle posizioni disponibili sarà influenzata dal numero di figli:

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 1 figlio con età inferiore ai 18 anni, si presenta a &lt;strong&gt;p1&lt;/strong&gt; la lista &lt;strong&gt;l4&lt;/strong&gt; dei lavori adatti al suo caso;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 2 figli con età inferiore ai 18 anni, si presenta a &lt;strong&gt;p1&lt;/strong&gt; la lista &lt;strong&gt;l5&lt;/strong&gt; dei lavori adatti al suo caso;&lt;/li&gt;
&lt;li&gt;nei due casi precedenti, se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d4&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 3 figli o più, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d5&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un approccio &amp;ldquo;strutturato&amp;rdquo; al problema può consistere nello scrivere una funzione in cui l&amp;rsquo;intera procedura è espressa con una serie di &lt;em&gt;if-else&lt;/em&gt; e uno &lt;em&gt;switch&lt;/em&gt; (nel caso del numero di figli).&lt;/p&gt;

&lt;p&gt;Il progetto relativo a questo articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/NoCountryForIfElse&#34;&gt;GitHub&lt;/a&gt;: suggerisco di controllare il codice nel progetto man mano che si prosegue nella lettura dell&amp;rsquo;articolo; i file &lt;code&gt;.swift&lt;/code&gt; sono semplici file di testo, e possono essere visualizzati con qualsiasi editor. Nel file &lt;code&gt;common.swift&lt;/code&gt; sono indicate alcune strutture e funzioni comuni tra tutte le soluzioni al problema proposto. In particolare, indicheremo una &amp;ldquo;persona&amp;rdquo; con &lt;code&gt;struct Person&lt;/code&gt;, in sostanza un &lt;em&gt;value object&lt;/em&gt; immutabile che contiene i vari attributi considerati nel problema:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Person {
    
    let name: String
    let isYoung: Bool
    let childrenCount: Int
    let likedJobsMain: [String]
    let likedJobsSecondary: [String]
    let dislikedJobs: [String]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;idea è quella di scrivere una funzione &lt;code&gt;placeNameForPerson&lt;/code&gt; che ritorni il nome della &lt;em&gt;destinazione successiva&lt;/em&gt; per la persona in ingresso al problema: tale destinazione può essere un altro sportello &lt;code&gt;d2,d3,d4,d5&lt;/code&gt; oppure &lt;code&gt;outside&lt;/code&gt; nel caso in cui la persona lasci l&amp;rsquo;ufficio di collocamento senza lavoro. La funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; ritorna appunto il nome del luogo di destinazione della persona in ingresso, e richiede anche un secondo input, un &lt;code&gt;DeskWithJobs&lt;/code&gt; cioè uno sportello con diverse liste di lavori disponibili. Nel caso strutturato, l&amp;rsquo;intera logica di esecuzione è indicata nella funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt;, ed è appunto basata su verifiche condizionali annidate, legate alle caratteristiche dei parametri in ingresso.&lt;/p&gt;

&lt;p&gt;Si vede subito che è piuttosto difficile capire cosa succeda nella funzione semplicemente leggendola: probabilmente, in un &amp;ldquo;vero&amp;rdquo; software, una funzione di questo tipo sarebbe annotata con &lt;strong&gt;un gran numero di commenti&lt;/strong&gt;. Inoltre, si vede facilmente che per tracciare un bug in una funzione del genere sarebbe necessario un debugging passo-passo, perché il gran numero di condizioni espresse rende la funzione sostanzialmente non testabile in maniera efficiente. Infine, se ci trovassimo a dover modificare la procedura, modificando delle condizioni o introducendone altre, avremmo vita dura.&lt;/p&gt;

&lt;p&gt;Il problema di fondo è in realtà dovuto al fatto che, con un approccio strutturato, stiamo &lt;strong&gt;mescolando l&amp;rsquo;intento con l&amp;rsquo;implementazione&lt;/strong&gt;: in questo caso l&amp;rsquo;intento è associare gruppi di condizioni a specifici sportelli &amp;ldquo;target&amp;rdquo;, ma nella soluzione strutturata tali relazioni sono &amp;ldquo;nascoste&amp;rdquo; nel codice e devono essere dedotte da esso; se ad esempio ci venisse chiesto qual è lo sportello per una persona anziana con 2 figli, dovremmo necessariamente seguire il flusso di codice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;poiché la prima condizione è relativa al numero di figli, entriamo subito nel branch &lt;code&gt;childrenCount != 0&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;a questo punto entriamo nel &lt;code&gt;case 2&lt;/code&gt; per il numero di figli;&lt;/li&gt;
&lt;li&gt;c&amp;rsquo;è una condizione in base alla quale il codice verifica che c&amp;rsquo;è un lavoro disponibile;&lt;/li&gt;
&lt;li&gt;a scelta positiva lo sportello di destinazione è il &amp;ldquo;d4&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;dov&amp;rsquo;è la condizione &amp;ldquo;giovane/anziano&amp;rdquo;? C&amp;rsquo;è un bug nel codice? Analizzando il ramo &lt;code&gt;childrenCount == 0&lt;/code&gt; possiamo verificare che tale condizione è effettivamente analizzata, ma è semplicemente irrilevante per l&amp;rsquo;altro ramo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;È una strada relativamente lunga per capire una cosa semplice, ed è da notare che se volessimo fare delle modifiche, dovremmo sempre scorrere nuovamente l&amp;rsquo;intera procedura per verificare che abbiamo coperto tutti i casi possibili, e che non ci siano conflitti o ambiguità.&lt;/p&gt;

&lt;p&gt;Possiamo fare di meglio.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-oo&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-oo:c252b88516f644ca0545d16795aa645d&#34;&gt;Esempio: soluzione OO&lt;/h2&gt;

&lt;p&gt;Progettare una soluzione a oggetti è spesso un&amp;rsquo;operazione &lt;strong&gt;tanto razionale quanto creativa&lt;/strong&gt;: in genere è possibile immaginare moltissimi design OO per risolvere uno stesso problema. Come detto, il nostro intento è di &lt;em&gt;astrarre&lt;/em&gt; il concetto di &lt;em&gt;condizione&lt;/em&gt;; basandoci su questo approccio, proviamo fissare qualche punto, in modo da identificare le responsabilità e i comportamenti da assegnare alla classi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vogliamo essere in grado di rappresentare ciascuna condizione come se fosse un &lt;em&gt;check&lt;/em&gt; separato dagli altri, quindi avremo certamente qualcosa che assomiglia a un tipo &lt;em&gt;Check&lt;/em&gt; caratterizzato da metodi che verificano se una certa persona passa un controllo o no;&lt;/li&gt;
&lt;li&gt;vogliamo rappresentare separatamente i check relativi a un attributo della persona, tipo il numero di figli, da quelli relativi alla lista di lavori tra cui scegliere;&lt;/li&gt;
&lt;li&gt;vogliamo costruire oggetti che siano in grado di combinare più check in un unico check;&lt;/li&gt;
&lt;li&gt;vogliamo creare un oggetto che rappresenti una lista di check e sia in grado di valutare se la persona passi uno dei check della lista, uno e solo uno, oppure non passi alcun check;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il file &lt;code&gt;oo.swift&lt;/code&gt; contiene l&amp;rsquo;implementazione completa della soluzione a oggetti. È definito un &lt;code&gt;protocol PersonCheckType&lt;/code&gt;, cioè un&amp;rsquo;interfaccia che dichiara un metodo &lt;code&gt;personIsValid&lt;/code&gt; che verifica se una certa &lt;code&gt;Person&lt;/code&gt; passa il check:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol PersonCheckType {
    func personIsValid(person: Person) -&amp;gt; Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sono quindi dichiarate alcune classi di tipo &lt;code&gt;PersonCheckType&lt;/code&gt; che permettono di verificare singolarmente ciascun attributo intrinseco di una &lt;code&gt;Person&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Il tipo &lt;code&gt;JobsType&lt;/code&gt; dichiara semplicemente un attributo &lt;code&gt;availableJobs&lt;/code&gt; per raccogliere i lavori disponibili nei vari casi: da esso derivano altri &lt;em&gt;check&lt;/em&gt;, a loro volta di tipo &lt;code&gt;PersonCheckType&lt;/code&gt;, che verificano se una persona sia valida dal punto di vista dei lavori preferiti.&lt;/p&gt;

&lt;p&gt;Infine, il tipo &lt;code&gt;NextDeskType&lt;/code&gt; dichiara un metodo &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; in base al quale è possibile definire quale sia il nome del prossimo sportello per una persona; il metodo ritorna &lt;code&gt;String?&lt;/code&gt; perché per una certa persona potrebbe non essere disponibile alcuno sportello:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol NextDeskType {
    func nextDeskNameForPerson(person: Person) -&amp;gt; String?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dal tipo &lt;code&gt;NextDeskType&lt;/code&gt; deriviamo le seguenti classi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CheckNode&lt;/code&gt;, che rappresenta un nodo nella struttura decisionale del software;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CheckStructure&lt;/code&gt;, che rappresenta l&amp;rsquo;intera struttura di nodi;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In effetti, l&amp;rsquo;implementazione di &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; in &lt;code&gt;CheckStructure&lt;/code&gt; corrisponde esattamente alla soluzione del problema posto: trovare il nome dello sportello di destinazione.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;idea è quella di creare alcuni semplici &lt;strong&gt;check unitari&lt;/strong&gt;, usando le varie classi di tipo &lt;code&gt;PersonCheckType&lt;/code&gt;, e combinare questi check in oggetti concreti di classe &lt;code&gt;CheckNode&lt;/code&gt;, definendo la nostra &lt;code&gt;CheckStructure&lt;/code&gt;. In puro stile OO, abbiamo definito classi chiamate &lt;code&gt;MultipleCheck&lt;/code&gt; e &lt;code&gt;ComposedCheck&lt;/code&gt; per poter comporre più check, e &lt;code&gt;FailingCheck&lt;/code&gt; per poter incapsulare un check di cui si richiede il fallimento. Nessuno dei metodi implementati presenta strutture decisionali che influenzino la &lt;em&gt;business logic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Come esempio si riporta l&amp;rsquo;implementazione della classe &lt;code&gt;ChildrenCountCheck&lt;/code&gt;, che si occupa di verificare se una persona abbia un certo numero di figli:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ChildrenCountCheck: PersonCheckType {
    
    let childrenCount: Int
    init(_ childrenCount: Int) {
        self.childrenCount = childrenCount
    }
    
    func personIsValid(person: Person) -&amp;gt; Bool {
        return person.childrenCount == childrenCount
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;oggetto &lt;code&gt;structure&lt;/code&gt; definito nel file &lt;code&gt;main.swift&lt;/code&gt; presenta la lista delle condizioni, sotto forma di oggetti adeguatamente configurati; come si può vedere, la lista è ben leggibile e le condizioni sono chiare: siamo quindi riusciti a &lt;em&gt;dichiarare&lt;/em&gt; l&amp;rsquo;intento in maniera semplice e separata dai dettagli di implementazione.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-funzionale:c252b88516f644ca0545d16795aa645d&#34;&gt;Esempio: soluzione funzionale&lt;/h2&gt;

&lt;p&gt;Nello strutturare la soluzione OO abbiamo adottato un &lt;strong&gt;principio di composizione&lt;/strong&gt;: oggetti dal comportamento semplice, adeguatamente preparati, composti tra loro per poter ottenere strutture più complesse. In particolare ciascuno dei nostri oggetti rappresenta uno specifico &lt;em&gt;comportamento unitario&lt;/em&gt;, e i vari &lt;em&gt;comportamenti&lt;/em&gt; sono combinati per ottenere un &lt;em&gt;comportamento composto&lt;/em&gt;. &lt;strong&gt;L&amp;rsquo;astrazione regge&lt;/strong&gt;, e riusciamo ad accettare il fatto che gli oggetti &lt;em&gt;check&lt;/em&gt; siano scatole chiuse che incapsulano una singola decisione su una persona: creando una scatola più grande, con dentro scatole più piccole, possiamo rappresentare una condizione più complessa. Tuttavia ci sono due problemi tipici dell&amp;rsquo;approccio OO:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ogni singola classe richiede molto codice solo per costruire l&amp;rsquo;astrazione di &amp;ldquo;decisione nella scatola&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;la composizione tra oggetti è basata sui metodi degli oggetti stessi, la qual cosa comporta, di nuovo, la scrittura di molto codice, che può offuscare l&amp;rsquo;intento;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;È possibile ottenere più chiaramente lo stesso risultato, cioè creare una struttura decisionale complessa a partire da componenti semplici, usando uno stile di &lt;strong&gt;programmazione funzionale&lt;/strong&gt;. Il codice funzionale è descritto nel file &lt;code&gt;functional.swift&lt;/code&gt;. Partiamo sempre dall&amp;rsquo;immutabile &lt;code&gt;struct Person&lt;/code&gt; e definiamo, per comodità, un altro semplice contenitore di dati, &lt;code&gt;struct DeskNode&lt;/code&gt;, che accoppia il nome di un nodo al nome di uno sportello di destinazione. Per il resto, definiremo solo ed esclusivamente funzioni, modellizzando l&amp;rsquo;intero problema con una serie di trasformazioni di dati.&lt;/p&gt;

&lt;p&gt;In questo caso &lt;code&gt;PersonCheck&lt;/code&gt; è &lt;strong&gt;un tipo di funzione&lt;/strong&gt;, che associa una &lt;code&gt;Person&lt;/code&gt; a un &lt;code&gt;Bool&lt;/code&gt;. Definiamo inoltre il tipo di funzione &lt;code&gt;PersonNode&lt;/code&gt;, che associa un certo &lt;code&gt;DeskNode&lt;/code&gt; a una &lt;code&gt;Person&lt;/code&gt;, e che ha sostanzialmente lo scopo che aveva il metodo &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; nella soluzione a oggetti.&lt;/p&gt;

&lt;p&gt;Rappresentiamo infine i vari &amp;ldquo;nodi&amp;rdquo; con una funzione del tipo &lt;code&gt;JobsNode&lt;/code&gt;, che costruisce un &lt;code&gt;PersonNode&lt;/code&gt; in base a un certo &lt;code&gt;PersonCheck&lt;/code&gt;: in questo modo, per costruire una lista di &lt;code&gt;PersonNode&lt;/code&gt; sarà sufficiente applicare i vari &lt;em&gt;check&lt;/em&gt; (&lt;code&gt;PersonCheck&lt;/code&gt;) ai rispettivi nodi (&lt;code&gt;JobsNode&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Il metodo più spesso adottato in programmazione funzionale per comporre le funzioni è quello di definire degli &lt;strong&gt;operatori personalizzati&lt;/strong&gt;. Vogliamo ad esempio comporre i vari &lt;code&gt;PersonCheck&lt;/code&gt; come se componessimo dei semplici &lt;code&gt;Bool&lt;/code&gt;, quindi ad esempio definendo degli operatori &lt;strong&gt;AND&lt;/strong&gt; e &lt;strong&gt;OR&lt;/strong&gt;. Ad imitazione dei classici &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; e &lt;code&gt;||&lt;/code&gt; definiremo rispettivamente gli operatori &lt;code&gt;&amp;lt;&amp;amp;&amp;gt;&lt;/code&gt; e &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, copiando regole di &lt;a href=&#34;https://en.wikipedia.org/wiki/Operator_associativity&#34;&gt;precedenza e associatività&lt;/a&gt; dalla libreria standard. Per migliorare la leggibilità e la chiarezza della composizione tra funzioni, definiremo anche un operatore di &lt;em&gt;applicazione di funzione&lt;/em&gt;, nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;infix operator &amp;lt;*&amp;gt; {
    associativity left
    precedence 100
}
func &amp;lt;*&amp;gt; &amp;lt;A,B&amp;gt; (left: A -&amp;gt; B, right: A) -&amp;gt; B {
    return left(right)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vediamo dalla definizione che l&amp;rsquo;operatore &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; in sostanza &lt;em&gt;applica&lt;/em&gt; un argomento (posizionato a destra dell&amp;rsquo;operatore) a una certa funzione (posizionata a sinistra dell&amp;rsquo;operatore): esso rappresenta quindi un modo alternativo di applicare una funzione rispetto allo scrivere i suoi argomenti &lt;strong&gt;tra parentesi&lt;/strong&gt;, ed è particolarmente adatto a migliorare la leggibilità del codice quando usiamo &lt;a href=&#34;https://en.wikipedia.org/wiki/Higher-order_function&#34;&gt;funzioni di ordine superiore&lt;/a&gt;. Vediamo gli operatori all&amp;rsquo;opera nel file &lt;code&gt;main.swift&lt;/code&gt;, quando definiamo i nostri nodi, ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;node(&amp;quot;old&amp;quot;, nextDeskName: &amp;quot;d3&amp;quot;)
    &amp;lt;*&amp;gt; oldCheck
    &amp;lt;&amp;amp;&amp;gt; mustFail(childrenChecks)
    &amp;lt;&amp;amp;&amp;gt; checkExtendedJobs(availableJobsElderly)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione sopraindicata costruisce un &lt;code&gt;PersonNode&lt;/code&gt; chiamato &lt;em&gt;old&lt;/em&gt; che ritorna lo sportello &lt;em&gt;d3&lt;/em&gt; se la &lt;code&gt;Person&lt;/code&gt; in ingresso rispetta un check composto formato dalle seguenti funzioni:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oldCheck&lt;/code&gt;: la persona è anziana;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mustFail(childrenChecks)&lt;/code&gt;: la persona non deve avere figli;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkExtendedJobs(availableJobsElderly)&lt;/code&gt;: l&amp;rsquo;insieme dei lavori adatti agli anziani e l&amp;rsquo;insieme dei lavori preferiti dalla persona devono avere una qualche intersezione;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A un primo impatto lo stile funzionale può risultare poco comprensibile, ma è sufficiente capire le astrazioni di base sulle quali è realizzata la composizione funzionale per poterne apprezzare &lt;strong&gt;la potenza e l&amp;rsquo;espressività&lt;/strong&gt;. L&amp;rsquo;array &lt;code&gt;nodes&lt;/code&gt;, nel file &lt;code&gt;main.swift&lt;/code&gt;, contiene tutti i nodi del problema, rappresentati come funzioni: rispetto  alla soluzione a oggetti contenuta in &lt;code&gt;structure&lt;/code&gt;, quella funzionale appare più chiara e leggibile.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;una-verifica-empirica&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;una-verifica-empirica:c252b88516f644ca0545d16795aa645d&#34;&gt;Una verifica empirica&lt;/h2&gt;

&lt;p&gt;Nel progettare le soluzioni &amp;ldquo;OO&amp;rdquo; e &amp;ldquo;funzionale&amp;rdquo; si è specificamente scelto di costruire strutture di verifica nelle quali l&amp;rsquo;ordine con il quale i check sono eseguiti fosse irrilevante: in questo modo rimuoviamo una nota causa di complessità accidentale, quella del &amp;ldquo;controllo&amp;rdquo;, e cioè dell&amp;rsquo;&lt;strong&gt;ordine&lt;/strong&gt; con il quale le operazioni sono eseguite (ne abbiamo parlato &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/#cause-di-complessita&#34;&gt;qui&lt;/a&gt;). Per fare ciò è tuttavia necessario che i check presenti nella lista &lt;strong&gt;non siano ambigui&lt;/strong&gt;: al massimo un solo check deve poter passare per una certa persona. Probabilmente sarebbe possibile impostare un &lt;strong&gt;metodo formale&lt;/strong&gt; per poter provare che un determinato set di condizioni sia non-ambiguo, e scrivere quindi un test unitario basato su tale prova, ma in questo caso un approccio &lt;em&gt;empirico&lt;/em&gt; sembra più adatto, e &lt;strong&gt;più semplice&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Si è quindi scelto di procedere seguendo il metodo &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt;: si tratta di una libreria scritta per il linguaggio &lt;a href=&#34;https://www.haskell.org&#34;&gt;Haskell&lt;/a&gt; che permette di testare in modo automatico che le funzioni rispettino determinate &lt;em&gt;proprietà&lt;/em&gt;. L&amp;rsquo;idea è quella di verificare che una funzione si comporti sempre nello stesso modo, testandola con &lt;strong&gt;un gran numero di input casuali&lt;/strong&gt;: nel nostro caso la funzione è proprio la lista di check, e l&amp;rsquo;input è un valore di tipo &lt;code&gt;Person&lt;/code&gt;. Per verificare che i check non siano ambigui possiamo semplicemente provarli con un gran numero di &lt;code&gt;Person&lt;/code&gt; generate casualmente: se per un certo valore di &lt;code&gt;Person&lt;/code&gt; due o più check risultano positivi, l&amp;rsquo;esecuzione del test si interrompe e sono stampati in console i nomi dei check incriminati. Se i check ambigui sono due, sarà sufficiente rendere uno di essi più specifico, ad esempio richiedendo che l&amp;rsquo;altro fallisca. Useremo qui il termine &lt;em&gt;QuickCheck&lt;/em&gt; per indicare il test empirico implementato, ma in realtà la libreria originale fa molto di più: rimando alla pagina &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;linkata&lt;/a&gt; per tutte le informazioni.&lt;/p&gt;

&lt;p&gt;Le funzioni &lt;code&gt;quickCheck_oo&lt;/code&gt; e &lt;code&gt;quickCheck_functional&lt;/code&gt; implementano la funzionalità richiesta: generano un certo numero di &lt;code&gt;Person&lt;/code&gt; casuali, e verificano che il numero di &lt;code&gt;check&lt;/code&gt; superato per ogni &lt;code&gt;Person&lt;/code&gt; sia 0 o 1. Possiamo sfruttare immediatamente questo test aggiungendo un nuovo nodo. Supponiamo ad esempio che a un certo punto, dopo qualche tempo in cui il codice è stato usato con successo per risolvere il problema, si scelga di aggiungere una nuova condizione: è stato appositamente aperto uno sportello per persone anziane con un solo figlio. Si noti come modificare il codice della funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; sarebbe piuttosto complicato: probabilmente dovremmo modificare interi branch decisionali, &lt;strong&gt;aggiungendo la stessa condizione in diversi punti&lt;/strong&gt;, e la probabilità di sbagliare sarebbe molto alta. Con le altre due soluzioni, invece, si tratta semplicemente di aggiungere un nuovo check. Tuttavia, dopo aver aggiunto il nodo, se eseguiamo il programma vedremo che QuickCheck fallirà, stampando il seguente messaggio&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ambiguous nodes: [1 child, 1 child old]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QuickCheck ci sta informando che i nodi chiamati &amp;ldquo;1 child&amp;rdquo; e &amp;ldquo;1 child old&amp;rdquo; sono &lt;strong&gt;ambigui&lt;/strong&gt;: in effetti, se la &lt;code&gt;Person&lt;/code&gt; ha un figlio ed è anziana, passeranno i check per entrambi i nodi. Per risolvere il problema sarà sufficiente introdurre una condizione di fallimento nel nodo &amp;ldquo;1 child&amp;rdquo;: perché esso passi, deve fallire il check di anzianità.&lt;/p&gt;

&lt;p&gt;Nel progetto è implementata anche una funzione &lt;code&gt;quickCheck_consistency&lt;/code&gt; che esegue un test di sicurezza del tipo &lt;em&gt;sanity check&lt;/em&gt;: verifica infatti che lo sportello di destinazione di un gran numero di &lt;code&gt;Person&lt;/code&gt; generate casualmente rimanga lo stesso nei 3 metodi implementati.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusioni&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusioni:c252b88516f644ca0545d16795aa645d&#34;&gt;Conclusioni&lt;/h2&gt;

&lt;p&gt;Abbiamo visto tre metodi per risolvere uno stesso problema relativamente complesso, e in due di essi siamo riusciti a ottenere un sistema &lt;strong&gt;più facilmente gestibile&lt;/strong&gt;, estendibile e modificabile in sicurezza, lavorando a un &lt;strong&gt;più alto livello di astrazione&lt;/strong&gt;. In particolare il metodo &amp;ldquo;funzionale&amp;rdquo; ci ha permesso di scrivere codice più compatto, caratterizzato da un intento più evidente, al costo (basso) di un passo iniziale di astrazione in più, rappresentato dagli operatori personalizzati. Ma la chiave di lettura dell&amp;rsquo;intero processo è ancora una volta da ricercarsi nella già citata frase presente in &lt;em&gt;Structure and Interpretation of Computer Programs&lt;/em&gt;, che riporto nuovamente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Adottando uno stile più &lt;strong&gt;dichiarativo&lt;/strong&gt;, in cui il codice proprio della &lt;em&gt;business logic&lt;/em&gt; &amp;ldquo;dichiara l&amp;rsquo;intento&amp;rdquo;, descrivendo il &amp;ldquo;cosa&amp;rdquo; e non il &amp;ldquo;come&amp;rdquo;, è possibile scrivere software più chiaro e leggibile. Tale software sarà probabilmente anche più &lt;em&gt;testabile&lt;/em&gt;, perché basato su &lt;strong&gt;componenti atomici&lt;/strong&gt; a più basso livello, individualmente facili da testare, che sono combinati attraverso strutture di composizione, anch&amp;rsquo;esse agilmente testabili e provabili. L&amp;rsquo;obiettivo finale è quello di realizzare architetture software che siano in grado di &lt;strong&gt;risolvere automaticamente i problemi&lt;/strong&gt;, descritti nel codice sfruttando gli &lt;strong&gt;elementi costruttivi di base&lt;/strong&gt;. Abbiamo infine visto come un approccio misto tra &amp;ldquo;ragionato&amp;rdquo; e &amp;ldquo;empirico&amp;rdquo; possa garantire ottimi risultati; il ragionamento &lt;em&gt;a priori&lt;/em&gt; e la verifica &lt;em&gt;a posteriori&lt;/em&gt; sono entrambi strumenti utili, ma la loro unione risulta essere particolarmente potente: d&amp;rsquo;altronde, ogni disciplina scientifica richiede sia il ragionamento logico-matematico per la definizione delle teorie, sia la verifica sperimentale per poterne testare la validità.&lt;/p&gt;

&lt;p&gt;Gli strumenti sono a disposizione, basta &lt;strong&gt;iniziare ad usarli&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MiniIAD Vimercate 2015: reportage</title>
      <link>/blog/ita/miniiad-vimercate-2015-reportage/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/miniiad-vimercate-2015-reportage/</guid>
      <description>

&lt;p&gt;Lo scorso 23 Maggio 2015, si è tenuto a Vimercate, presso la sede di Alcatel-Lucent all&amp;rsquo;Energy Park, il &lt;a href=&#34;http://www.agileday.it/mini/2015/vimercate/&#34;&gt;Mini Italian Agile Day&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Anche in occasione di questo evento Facile.it si è presentata con una piccola delegazione. Sono andato all&amp;rsquo;incontro cercando di polarizzare bene le mie aspettative della giornata. Da un evento della &lt;strong&gt;comunità Agile&lt;/strong&gt; mi aspetto un &lt;strong&gt;confronto&lt;/strong&gt;, una &lt;strong&gt;crescita&lt;/strong&gt;, nonché l&amp;rsquo;occasione di incontrare qualche volto amico, qualche ex collega o qualche guru a cui chiedere consiglio!&lt;/p&gt;

&lt;p&gt;Parlare di recensione della giornata mi sembra inappropriato. Preferisco soffermarmi su cosa mi ha colpito e cosa mi sono portato a casa da questa esperienza.&lt;/p&gt;

&lt;h2 id=&#34;welcome-coffee:1f5d804dca1b5af8fd406d2b72199bbf&#34;&gt;Welcome coffee&lt;/h2&gt;

&lt;p&gt;Partiamo dal primo impatto: la location. Beh, complimenti ad Alcatel perché ha una sede molto bella! raggiungerla in auto non è stato tanto difficile e tutto quel verde dentro e fuori dagli uffici trasmette una bella sensazione. Come al solito sono in ritardo, giusto il tempo di un caffè, offerto dal nostro host, e qualche stretta di mano e subito si comincia.&lt;/p&gt;

&lt;h2 id=&#34;keynote:1f5d804dca1b5af8fd406d2b72199bbf&#34;&gt;Keynote&lt;/h2&gt;

&lt;p&gt;Il keynote è di &lt;a href=&#34;https://twitter.com/ixhd&#34;&gt;Cliff Hazell&lt;/a&gt;, un ragazzo che fa l&amp;rsquo;agile coach in Spotify. Ha illustrato una &lt;strong&gt;tecnica di visualizzazione&lt;/strong&gt; della conoscenza e dei processi su una grande parete con dei post-it. Un qualcosa che mi ha ricordato l&amp;rsquo;&lt;a href=&#34;http://ziobrando.blogspot.it/2013/11/introducing-event-storming.html&#34;&gt;event storming&lt;/a&gt; che ho visto raccontare da &lt;a href=&#34;http://www.avanscoperta.it/it/author/a-brandolini/&#34;&gt;Alberto Brandolini&lt;/a&gt; a BetterSoftware, tuttavia mi è parso ci siano alcune differenze. In entrambi i metodi il risultato finale è &lt;strong&gt;una parete piena di post-it che spiegano il modello&lt;/strong&gt; da sviluppare. Nell&amp;rsquo;event storming, la creazione partecipata della parete è l&amp;rsquo;evoluzione degli stati del modello sono il punto focale. Non ho mai avuto il piacere di usare event storming, ma tutte le presentazioni che ho visto delineano il modo in cui la parete &amp;ldquo;si riempie&amp;rdquo;, mentre ho poche informazioni su come questa poi si traduca in software. Piuttosto, mi pare di aver colto che Cliff ponga molta enfasi su come man mano la conoscenza che stiamo visualizzando si evolva e man mano si traduca in componenti software. Mi intriga l&amp;rsquo;ipotesi di combinare le due cose!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/miniiad-vimercate-2015-reportage/visualization.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;agile-e-il-business-delle-aziende:1f5d804dca1b5af8fd406d2b72199bbf&#34;&gt;Agile e il business delle aziende&lt;/h2&gt;

&lt;p&gt;La mia giornata prosegue parlando di &lt;strong&gt;&lt;a href=&#34;http://www.ideastartup.it/startupzionario/&#34;&gt;Startup&lt;/a&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;a href=&#34;https://it.wikipedia.org/wiki/Produzione_snella&#34;&gt;Lean&lt;/a&gt;&lt;/strong&gt; con &lt;a href=&#34;https://twitter.com/felicepescatore&#34;&gt;Felice Pescatore&lt;/a&gt;. Una sessione sul percorso &amp;ldquo;&lt;a href=&#34;http://www.agileday.it/mini/2015/vimercate/#leanstartup&#34;&gt;dal garage al grattacielo&lt;/a&gt;&amp;rdquo;. Bello stile, coinvolgente! Ho già letto tanto su Lean, purtroppo non ho portato via nulla di nuovo.
Anche il talk successivo &lt;a href=&#34;http://www.agileday.it/mini/2015/vimercate/#Kanban_experiment&#34;&gt;Kanban experiment&lt;/a&gt;, su &lt;strong&gt;&lt;a href=&#34;https://it.wikipedia.org/wiki/Kanban&#34;&gt;Kanban&lt;/a&gt;&lt;/strong&gt;, non mi ha detto nulla di nuovo. Mi piace però constatare che molti gruppi di lavoro che si stanno avvicinando alle metodologie Agili, scelgono Kanban.&lt;/p&gt;

&lt;h2 id=&#34;large-scaling-scrum:1f5d804dca1b5af8fd406d2b72199bbf&#34;&gt;Large Scaling SCRUM&lt;/h2&gt;

&lt;p&gt;Dopo un buon pranzo, ho assistito ad una &lt;a href=&#34;http://www.agileday.it/mini/2015/vimercate/#LeSS_Adoption&#34;&gt;sessione&lt;/a&gt; su &lt;strong&gt;&lt;a href=&#34;http://less.works/&#34;&gt;Less&lt;/a&gt;&lt;/strong&gt;. E quì rimango veramente sorpreso in positivo. Non conoscevo Less e penso se ne dovrebbe parlare di più, soprattutto in aziende con tanti gruppi di lavoro diversi. &lt;a href=&#34;https://www.youtube.com/watch?v=PTjnw9EXsD4&#34;&gt;Francesco Sferlazza&lt;/a&gt; ha raccontato come in Alcatel hanno introdotto Less (Large Scaling SCRUM). In sostanza, si tratta di un framework per &lt;strong&gt;attuare SCRUM in aziende composte da svariati sottogruppi che fanno SCRUM che però hanno delle dipendenze vicendevoli&lt;/strong&gt;. Con SCRUM si dovrebbero costituire dei gruppi completamente indipendenti, composti da tutte le risorse necessarie per realizzare l&amp;rsquo;obiettivo. In realtà estremamente complesse, come appunto una grandissima azienda di telefonia, non è possibile considerare nello stesso aggregato i manutentori delle centraline telefoniche con gli esperti di design dei dispositivi da installare. In sostanza, si deve armonizzare il lavoro di gruppi diversi in cui in ciascuno si applica SCRUM.
Tutto questo mi ha colpito moltissimo perché anche nella nostra realtà (non certo così grande e complessa) alcuni elementi della filiera non riusciamo a portarli dentro tutti i team. Ad esempio i web designer o il team di marketing. Tutti i team condividono il tempo e le competenze di questi gruppi, che a loro volta fanno iterazioni settimanali (non SCRUM). Il talk mi ha illustrato alcuni dei vantaggi di Less ed ha stuzzicato la mia curiosità. Ora dovrò capire come applicarlo concretamente!&lt;/p&gt;

&lt;h2 id=&#34;retrospettive-creative:1f5d804dca1b5af8fd406d2b72199bbf&#34;&gt;Retrospettive creative&lt;/h2&gt;

&lt;p&gt;Si è andato avanti parlando di &lt;strong&gt;&lt;a href=&#34;http://retrospectivewiki.org/index.php?title=Main_Page&#34;&gt;retrospettive&lt;/a&gt;&lt;/strong&gt; con Marco Di Biase, uno SCRUM Master di Bravofly. Su questo tema, devo dare il merito a Marco di aver &lt;a href=&#34;http://www.agileday.it/mini/2015/vimercate/#Miglioramento_continuo&#34;&gt;condiviso&lt;/a&gt; un sacco di idee e scoperte fatte nel corso della sua esperienza. Io, ad esempio, ho iniziato a fare retrospettive con un certo format e da allora son riuscito a coinvolgere gli interlocutori più disparati del team (facciamo retrospettive tra team di addetti alla vendita e vengono fuori continue azioni di miglioramento come dalle retrospettive tra programmatori). Ma non ho mai provato a fare e farmi delle &lt;strong&gt;domande diverse durante gli incontri&lt;/strong&gt;. Marco accennava che &lt;a href=&#34;https://twitter.com/p_pugliese&#34;&gt;Pierluigi Pugliese&lt;/a&gt; gli abbia mostrato decine di approcci diversi.&lt;/p&gt;

&lt;p&gt;Mi ha colpito in particolare il format della retrospettiva con i cerchi concentrici che Marco suggerisce di usare per le iterazioni o per i periodi in cui le cose non vanno particolarmente bene, per ragionare sui problemi: ogni cerchio è un attore; il cerchio di cosa posso controllare io per fare meglio, di cosa può controllare il team per fare meglio e cosa invece è fuori dal nostro controllo ma sta facendo andare male le cose.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/miniiad-vimercate-2015-reportage/retrospettiva-cerchi.jpg&#34; alt=&#34;Retrospettiva con cerchi&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusioni:1f5d804dca1b5af8fd406d2b72199bbf&#34;&gt;Conclusioni&lt;/h2&gt;

&lt;p&gt;La serata si è poi conclusa con una carrellata di &lt;a href=&#34;http://www.agileday.it/mini/2015/vimercate/#Agile_Coaches&#34;&gt;esperienze&lt;/a&gt; vissute da tre coach. Dalla tastiera al coaching (senza lasciare la tastiera!). Le storie delle persone sono una delle cose di maggiore ispirazione. Per me penso sia bello ripartire da qui, con qualche pillola in più, inseguendo quel miglioramento continuo che ogni giorno sa riempirci di soddisfazioni.&lt;/p&gt;

&lt;p&gt;A presto con i prossimi grandi eventi dell&amp;rsquo;autunno!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programmazione Funzionale: perché preoccuparsi?</title>
      <link>/blog/ita/programmazione-funzionale-perche-preoccuparsi/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/programmazione-funzionale-perche-preoccuparsi/</guid>
      <description>

&lt;p&gt;Nel suo discorso di accettazione del &lt;a href=&#34;http://amturing.acm.org/award_winners/dijkstra_1053701.cfm&#34;&gt;Premio Turing 1972&lt;/a&gt;, dal titolo &amp;ldquo;&lt;a href=&#34;https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html&#34;&gt;The humble programmer&lt;/a&gt;&amp;rdquo;, &lt;strong&gt;Edsger Wybe Dijkstra&lt;/strong&gt;, uno dei più celebri &lt;em&gt;computing scientists&lt;/em&gt; del 20° secolo (morto nel 2002), affrontò le cause della nota &lt;a href=&#34;https://it.wikipedia.org/wiki/Software_crisis&#34;&gt;Software Crisis&lt;/a&gt;, cioè la crisi che colpì l&amp;rsquo;industria del software nella seconda metà degli anni sessanta: la potenza e la capacità di elaborazione dei computer stavano &lt;strong&gt;crescendo esponenzialmente&lt;/strong&gt;, molto più rapidamente dell&amp;rsquo;abilità dei programmatori di &lt;strong&gt;gestire la complessità&lt;/strong&gt; e scrivere software funzionante. Nello stesso discorso, Dijkstra propose anche delle possibili strade da intraprendere che a suo avviso avrebbero portato aziende e università a migliorare la qualità del loro software. Riporto qui una frase che a mio parere riassume abbastanza bene l&amp;rsquo;intero discorso:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I now suggest that we confine ourselves to the design and implementation of intellectually manageable programs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Il suggerimento è quindi il seguente: un programmatore dovrebbe limitarsi a lavorare su programmi &lt;strong&gt;intellettualmente gestibili&lt;/strong&gt;, cioè programmi dei quali è possibile stabilire la correttezza semplicemente &lt;strong&gt;attraverso il ragionamento&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#la-software-crisis-nei-decenni&#34;&gt;La &lt;em&gt;Software Crisis&lt;/em&gt; nei decenni&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cause-di-complessita&#34;&gt;Cause di complessità&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pensare-ad-oggetti&#34;&gt;Pensare ad oggetti&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#un-vecchio-paradigma-programmazione-funzionale&#34;&gt;Un vecchio paradigma: Programmazione Funzionale&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;la-software-crisis-nei-decenni&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;la-software-crisis-nei-decenni:ba51084cbefae16f67c65bf54f6283db&#34;&gt;La &lt;em&gt;Software Crisis&lt;/em&gt; nei decenni&lt;/h2&gt;

&lt;p&gt;Molti anni sono passati da allora, e la pratica dello sviluppo software ha attraversato varie evoluzioni e trasformazioni. Rispetto ai tempi di &lt;a href=&#34;https://it.wikipedia.org/wiki/Fortran&#34;&gt;FORTRAN&lt;/a&gt; e &lt;a href=&#34;https://en.wikipedia.org/wiki/ALGOL_60&#34;&gt;Algol 60&lt;/a&gt;, nuovi linguaggi di programmazione sono emersi e si sono affermati come standard; nuove tecniche e paradigmi, come la programmazione orientata agli oggetti, si sono diffuse nell&amp;rsquo;industria del software dopo un lungo periodo di gestazione in &lt;a href=&#34;https://en.wikipedia.org/wiki/Object-oriented_programming#History&#34;&gt;università e centri di ricerca privati&lt;/a&gt;; diversi modi di gestire il processo di realizzazione del software e il suo ciclo di vita sono stati elaborati nei decenni, dal classico modello &lt;a href=&#34;https://en.wikipedia.org/wiki/Waterfall_model&#34;&gt;Waterfall&lt;/a&gt; alle moderne metodologie &lt;a href=&#34;http://engineering.facile.it/un-flusso-di-lavoro-agile/&#34;&gt;Agile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ma &lt;strong&gt;il problema di fondo&lt;/strong&gt; espresso in &lt;em&gt;The humble programmer&lt;/em&gt; è praticamente &lt;strong&gt;rimasto intatto&lt;/strong&gt; nel corso dei decenni: lo sviluppo di funzionalità elaborate e la progettazione di strutture complesse portano al rilascio di software caratterizzato da molti &lt;em&gt;bug&lt;/em&gt;, o per meglio dire, &lt;strong&gt;errori&lt;/strong&gt; dovuti a una difficile, &lt;strong&gt;a volte apparentemente impossibile&lt;/strong&gt;, gestione della complessità. La possibilità di rilasciare software rapidamente e in maniera iterativa ha portato a &lt;strong&gt;integrare&lt;/strong&gt; del tutto questi errori nel processo di sviluppo e rilascio: questa integrazione è realizzata attraverso diverse tecniche, dal &lt;em&gt;debugging&lt;/em&gt;, praticato già dai primissimi programmatori oltre mezzo secolo fa, al &lt;a href=&#34;http://engineering.facile.it/tag/software-testing/&#34;&gt;&lt;em&gt;software testing&lt;/em&gt;&lt;/a&gt;, che permette, in maniera decisamente più efficace rispetto al &lt;em&gt;debugging&lt;/em&gt;, di &lt;strong&gt;identificare gli errori commessi&lt;/strong&gt; e porvi rimedio. Sfortunatamente il &lt;em&gt;testing&lt;/em&gt;, pur essendo una pratica ottima per verificare se ci siano errori in un particolare software, non è sufficiente a &lt;strong&gt;garantire&lt;/strong&gt; che questi errori non ci siano.&lt;/p&gt;

&lt;p&gt;Notiamo inoltre che l&amp;rsquo;idea di integrare gli errori nel processo di &lt;em&gt;design&lt;/em&gt; è una caratteristica praticamente esclusiva dell&amp;rsquo;ingegneria del software, che &lt;strong&gt;la distingue radicalmente&lt;/strong&gt; dalle altre discipline ingegneristiche: in esse, tipicamente, si progettano componenti usando &lt;strong&gt;metodi matematici rigorosi&lt;/strong&gt; o software di calcolo numerico che permettono comunque di ottenere dati molto precisi, e poi si applicano margini di sicurezza per tener conto della variabilità dei processi di sviluppo dei materiali, delle imperfezioni di assemblaggio e delle oscillazioni nelle condizioni di esercizio. Da una parte questa differenza rappresenta &lt;strong&gt;un grande vantaggio&lt;/strong&gt; per l&amp;rsquo;ingegneria del software: non si può &amp;ldquo;iterare&amp;rdquo; nella costruzione di un grattacielo! D&amp;rsquo;altra parte penso sia necessario evitare che lo sviluppo software si trasformi in un banale processo di &lt;em&gt;trial and error&lt;/em&gt; perché, per quanto esso possa dimostrarsi efficace in alcuni casi, spesso &lt;strong&gt;non ci permette di capire razionalmente cosa stiamo facendo&lt;/strong&gt;, e può portare alla produzione di codice instabile e difficilmente gestibile. La verifica &lt;em&gt;a posteriori&lt;/em&gt; attuata grazie al &lt;em&gt;testing&lt;/em&gt; non dovrebbe essere considerata sufficiente a giudicare un software corretto. A mio parere, inoltre, non dovremmo considerare i &lt;em&gt;bug&lt;/em&gt; come se fossero &lt;strong&gt;concetti filosofici&lt;/strong&gt;, necessari e impossibili da eliminare. Ovviamente gli esseri umani compiono errori, ma la differenza tra un comune errore dovuto alle non perfette abilità di una persona, e un bug causato dall&amp;rsquo;eccessiva complessità di un software, è simile alla differenza che c&amp;rsquo;è tra lo scivolare su un pavimento bagnato perché non si è notato il messaggio di avviso, e lo sfracellarsi al suolo dopo aver tentato una scalata difficilissima senza attrezzatura e senza aver alcuna esperienza di montagna: nel secondo caso, &lt;strong&gt;ce la siamo cercata&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In effetti, in un &lt;em&gt;essay&lt;/em&gt; scritto nel 1997 per il libro &lt;a href=&#34;https://books.google.it/books?id=9P5uwNpP1JAC&amp;amp;redir_esc=y&#34;&gt;Beyond Calculation: The Next Fifty Years of Computing&lt;/a&gt;, pubblicato a celebrazione dei primi 50 anni di vita del computer, lo stesso Dijkstra torna ad affrontare il tema della complessità non gestita, suggerendo che &lt;strong&gt;poco è cambiato&lt;/strong&gt; in merito al problema di fondo che già si era presentato più di 50 anni fa. Raccolgo qui poche parole prese dal &lt;em&gt;essay&lt;/em&gt; che, di nuovo, penso ne distillino il succo (grassetto mio):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Computing&amp;rsquo;s core challenge is &lt;strong&gt;how not to make a mess of it&lt;/strong&gt;. [&amp;hellip;] Because we are dealing with artefacts, all unmastered complexity is of our own making; &lt;strong&gt;there is no one else to blame&lt;/strong&gt; and so we had better learn how &lt;strong&gt;not to introduce the complexity in the first place&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a name=&#34;cause-di-complessita&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cause-di-complessità:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Cause di complessità&lt;/h2&gt;

&lt;p&gt;Ma quali sono le cause di tutta questa complessità? La fonte che, a mio parere, affronta in maniera più completa il problema della complessità nel software, proponendo soluzioni concrete, è il bellissimo (e lungo) articolo di Ben Moseley e Peter Marks &amp;ldquo;Out of the Tar Pit&amp;rdquo;(2006), reperibile &lt;a href=&#34;https://www.dropbox.com/s/nov94b39ikijwqd/tarpit.pdf?dl=0&#34;&gt;QUI&lt;/a&gt;. Per poter identificare i punti principali dell&amp;rsquo;articolo dobbiamo intanto dare &lt;strong&gt;una possibile definizione di &amp;ldquo;complessità&lt;/strong&gt;&amp;rdquo;, almeno per quanto riguarda lo sviluppo software; un primo tentativo potrebbe essere il seguente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;la complessità di un software rappresenta la difficoltà nel ragionare sul suo funzionamento&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In base a questa definizione, ad esempio, nel caso in cui un software presenti un qualche errore potremmo giudicare tale software più o meno complesso in base a quanto sia difficile trovare l&amp;rsquo;errore utilizzando il solo ragionamento. Basandoci su questa definizione, possiamo estrapolare da &lt;em&gt;Out of the Tar Pit&lt;/em&gt; due principali cause di complessità:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lo &lt;strong&gt;stato&lt;/strong&gt; delle variabili nel sistema&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;&lt;strong&gt;ordine&lt;/strong&gt; di esecuzione delle procedure&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In sintesi: la mente umana ha relativa difficoltà a tener traccia del modo in cui &lt;strong&gt;evolve nel tempo lo stato di molti parametri&lt;/strong&gt; in base a vari processi di trasformazione, specialmente se tale stato dipende anche &lt;strong&gt;dall&amp;rsquo;ordine in cui questi processi sono eseguiti&lt;/strong&gt;. In realtà riusciamo tranquillamente a gestire processi relativamente semplici attraverso una serie di trasformazioni di stato, si pensi all&amp;rsquo;atto di &amp;ldquo;fare una torta&amp;rdquo;: gli ingredienti di base &amp;ldquo;diventano&amp;rdquo; torta dopo una serie di stadi di trasformazione, che possiamo tranquillamente a tenere a mente, e se il risultato finale non è quello che ci aspettavamo riusciamo rapidamente a identificare l&amp;rsquo;errore nella procedura (la torta è troppo cotta, o abbiamo usato il sale al posto dello zucchero). In effetti seguire l&amp;rsquo;evoluzione di un processo di trasformazione costituito da una serie di procedure è assolutamente &lt;strong&gt;intuitivo&lt;/strong&gt; per la mente umana ed è alla base del paradigma di programmazione noto come &lt;strong&gt;programmazione procedurale&lt;/strong&gt;: nella mia breve esperienza personale ho potuto notare infatti che il metodo più frequentemente adottato nei corsi base di programmazione è proprio quello basato su alberi di scelte binarie &lt;em&gt;if-else&lt;/em&gt;, iterazioni e cicli con una o più condizioni di uscita. Purtroppo è facile osservare che questo modo di ragionare, sebbene sia perfettamente adatto a risolvere molti problemi pratici nella vita di tutti i giorni, &lt;strong&gt;non costituisca una strategia particolarmente efficace&lt;/strong&gt; quando si parla di programmi corposi e complessi, e con &amp;ldquo;corposi&amp;rdquo; intendo &amp;ldquo;più lunghi di un centinaio di righe&amp;rdquo;. È stato necessario introdurre nuove astrazioni, a più alto livello, per riuscire a superare la sempre incombente &lt;em&gt;software crisis&lt;/em&gt;, abbandonando ciò che appare intuitivo in favore di qualcosa di maggiormente gestibile ed efficiente.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;pensare-ad-oggetti&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pensare-ad-oggetti:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Pensare ad oggetti&lt;/h2&gt;

&lt;p&gt;Vediamo in sintesi come il problema della complessità sia affrontato, a grandi linee, dal più diffuso e importante paradigma di sviluppo software adottato a sostituzione di quello procedurale: la programmazione orientata agli oggetti (&lt;em&gt;Object-Oriented Programming&lt;/em&gt;: &lt;strong&gt;OOP&lt;/strong&gt;). OOP adotta il principio &lt;strong&gt;dell&amp;rsquo;incapsulamento della complessità&lt;/strong&gt;: le varie strutture computazionali del nostro software, individualmente più o meno complesse, sono suddivise in porzioni sufficientemente indipendenti, rinchiuse in contenitori stagni collegati tra loro da interfacce chiare e dichiarative. Si noti intanto che questo &lt;strong&gt;non è&lt;/strong&gt; il modo in cui gli esseri umani agiscono; nel suo classico articolo &lt;a href=&#34;http://c2.com/doc/oopsla89/paper.html&#34;&gt;A Laboratory For Teaching Object-Oriented Thinking (1989)&lt;/a&gt;, il celebre &lt;a href=&#34;https://it.wikipedia.org/wiki/Kent_Beck&#34;&gt;Kent Beck&lt;/a&gt;, noto soprattutto per i fondamentali contributi alle metodologie &lt;a href=&#34;https://it.wikipedia.org/wiki/Extreme_programming&#34;&gt;Extreme Programming&lt;/a&gt; e &lt;a href=&#34;https://it.wikipedia.org/wiki/Test_driven_development&#34;&gt;Test Driven Development&lt;/a&gt;, affronta il problema che si incontra quando si cerca di &lt;strong&gt;insegnare agli studenti a &amp;ldquo;pensare a oggetti&amp;rdquo;&lt;/strong&gt;: come essere umani siamo abituati a pensare allo stato globale di una situazione; a spostarci per comunicare direttamente con chiunque; ad affidarci al modo particolare in cui le persone che conosciamo svolgeranno un certo compito. OOP è invece basato su concetti opposti: ogni oggetto dovrebbe &amp;ldquo;vedere&amp;rdquo; solo i suoi vicini diretti, e di questi non dovrebbe comunque conoscere alcun dettaglio interno. Osserviamo quindi che &lt;strong&gt;il sistema di astrazioni&lt;/strong&gt; su cui OOP è basato non ha nulla a che fare con la vita &amp;ldquo;reale&amp;rdquo; o con il nostro abituale modo di pensare agli oggetti &amp;ldquo;fisici&amp;rdquo;, e a ragione: un software è svariati ordini di grandezza più complesso rispetto a una qualsiasi struttura fisica, e richiede strumenti diversi per poter essere compreso e gestito.&lt;/p&gt;

&lt;p&gt;In effetti un presunto punto di forza di OOP, spesso citato per fornire una prova dell&amp;rsquo;accessibilità di questo paradigma di programmazione, è costituito dall&amp;rsquo;idea che sia possibile trattare gli oggetti nel software come se fossero oggetti reali. Ho potuto osservare, tuttavia, che impostando proprietà e metodi delle classi come se queste fossero &lt;em&gt;template&lt;/em&gt; di oggetti reali, si tende a generare entità eccessivamente interdipendenti e poco flessibili. Questo porta a cadere in &lt;strong&gt;labirinti di complessità&lt;/strong&gt; paragonabili a quelli ottenuti in programmazione procedurale, nei quali lo &lt;strong&gt;stato mutabile&lt;/strong&gt; rende molto difficile la gestione, manutenzione e in generale la comprensibilità del sistema. Quindi spesso i concetti di &amp;ldquo;classe&amp;rdquo; e &amp;ldquo;oggetto&amp;rdquo; sono, purtroppo, &lt;strong&gt;usati in contesti sostanzialmente procedurali&lt;/strong&gt;: non sono rari metodi lunghi centinaia di righe con molti &lt;em&gt;if-else&lt;/em&gt; annidati, o riferimenti a dettagli di implementazione di altri oggetti, che dovrebbero rimanere &amp;ldquo;nascosti&amp;rdquo; al mondo esterno.&lt;/p&gt;

&lt;p&gt;Un tentativo di soluzione a questi problemi è rappresentato dai &lt;strong&gt;design patterns&lt;/strong&gt;, cioè strutture di classi e interfacce che hanno dimostrato &lt;strong&gt;eccellente applicabilità e robustezza&lt;/strong&gt; nell&amp;rsquo;affrontare molti problemi pratici; ma essi sono appunto &lt;em&gt;pattern&lt;/em&gt;, non sono teoremi, la loro capacità di risolvere problemi è verificata dal tempo e dall&amp;rsquo;esperienza, ma essi non permettono in alcun modo di provare in maniera deterministica che un software sia corretto. Il problema di fondo è che, a causa della continua variazione di stato degli oggetti, la struttura di un software scritto in OOP non &lt;strong&gt;può essere rappresentata con un modello matematico&lt;/strong&gt;: funzioni ed equazioni rappresentano relazioni statiche tra variabili dipendenti e indipendenti, con parametri costanti per ogni relazione; variando i parametri, cambia la relazione. Quindi il sistema di astrazioni su cui OOP si basa non può essere descritto dalla matematica. Ma la matematica è proprio l&amp;rsquo;antico e potente strumento utilizzato in qualsiasi disciplina scientifica proprio quando è necessario &lt;strong&gt;fornire prove formali&lt;/strong&gt; della correttezza di sistemi che non possono essere concepiti in maniera dettagliata dalla sola intuizione umana.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;un-vecchio-paradigma-programmazione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;un-vecchio-paradigma-programmazione-funzionale:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Un vecchio paradigma: Programmazione Funzionale&lt;/h2&gt;

&lt;p&gt;La &amp;ldquo;programmazione funzionale&amp;rdquo; (&lt;em&gt;Functional Programming&lt;/em&gt;: &lt;strong&gt;FP&lt;/strong&gt;) è un paradigma di sviluppo software in parte codificato già alla fine degli anni cinquanta, attraverso il noto linguaggio &lt;a href=&#34;https://en.wikipedia.org/wiki/Lisp_(programming_language&#34;&gt;LISP&lt;/a&gt;), e gode di solide basi matematiche nella &lt;a href=&#34;https://en.wikipedia.org/wiki/Combinatory_logic&#34;&gt;logica combinatoria&lt;/a&gt; e nel &lt;a href=&#34;https://en.wikipedia.org/wiki/Lambda_calculus&#34;&gt;lambda calcolo&lt;/a&gt;: malgrado ciò, ha trovato difficoltà nel diffondersi sia nei corsi universitari di base che nelle aziende, forse per &lt;strong&gt;un&amp;rsquo;alta barriera d&amp;rsquo;ingresso&lt;/strong&gt;, dovuta appunto alle forti basi matematiche e alla manipolazione di concetti molto astratti e poco intuitivi.&lt;/p&gt;

&lt;p&gt;FP si basa sull&amp;rsquo;idea che un software possa essere descritto attraverso l&amp;rsquo;applicazione di tre tecniche principali:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la definizione di un gran numero di &lt;strong&gt;funzioni pure&lt;/strong&gt;, cioè funzioni &lt;strong&gt;senza effetti collaterali&lt;/strong&gt;: una funzione pura ritorna &lt;strong&gt;sempre&lt;/strong&gt; un valore, e tale valore è sempre lo stesso &lt;strong&gt;a parità di condizioni di ingresso&lt;/strong&gt;, quindi non potrà mai succedere che una certa funzione ritorni due diversi valori in due diversi momenti nel corso dell&amp;rsquo;esecuzione di un software se non cambiano i dati in ingresso alla funzione;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;applicazione di queste funzioni ai dati soggetti a manipolazione nel nostro software, e la loro combinazione attraverso particolari funzioni note come &lt;strong&gt;funzioni di più altro ordine&lt;/strong&gt;, anch&amp;rsquo;esse pure, che però presentano altre funzioni tra i dati di ingresso e/o di uscita;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;uso di dati &lt;strong&gt;immutabili&lt;/strong&gt; e l&amp;rsquo;assenza di variazione di stato, che permettono di trattare estese porzioni di un software come se fossero &lt;strong&gt;equazioni matematiche&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Funzioni pure, indipendenti dallo stato di esecuzione di un software, rappresentano quindi delle &lt;strong&gt;relazioni statiche tra entità&lt;/strong&gt;: il processo di &lt;em&gt;testing&lt;/em&gt; sarà quindi più semplice perché ogni funzione da testare sarà del tutto indipendente dalle altre. In realtà il &lt;em&gt;testing&lt;/em&gt; in sé non è particolarmente importante in FP, perché tale paradigma si basa sull&amp;rsquo;idea di verificare &lt;em&gt;a priori&lt;/em&gt; che un programma sia corretto. Un software scritto in FP nasce in primo luogo da una costruzione teorica la cui correttezza è verificabile tramite &lt;a href=&#34;http://www.haskellforall.com/2013/12/equational-reasoning.html&#34;&gt;ragionamento equazionale&lt;/a&gt;. Saremo quindi in grado di ottenere un software corretto se:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ciascuna funzione sarà stata implementata correttamente;&lt;/li&gt;
&lt;li&gt;avremo impostato le relazioni corrette tra le entità coinvolte;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In FP le funzioni sono anche &lt;strong&gt;dati&lt;/strong&gt;, nel senso che hanno un &lt;strong&gt;tipo associato&lt;/strong&gt;. Ad esempio, usando la notazione di Swift, possiamo definire il tipo di una funzione &lt;code&gt;square&lt;/code&gt;, che permette di elevare al quadrato un numero intero, nel seguente modo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let square: Int -&amp;gt; Int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Possiamo leggere la definizione di questo &lt;em&gt;type&lt;/em&gt; così: una funzione che prende in ingresso un numero intero e ritorna un numero intero. Se nel software che stiamo scrivendo dovessimo trasformare un &lt;em&gt;array&lt;/em&gt; di numeri interi in un altro array con gli stessi numeri elevati al quadrato, potremmo definire una funzione &lt;code&gt;map&lt;/code&gt; con la seguente notazione:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let map: ([Int], Int -&amp;gt; Int) -&amp;gt; [Int]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Questo &lt;em&gt;type&lt;/em&gt; definisce una funzione che prende in ingresso un &lt;em&gt;array&lt;/em&gt; di numeri interi e una funzione del tipo &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt; (per esempio la funzione &lt;code&gt;square&lt;/code&gt;, definita prima). Abbiamo già visto in un &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;precedente articolo&lt;/a&gt; come &lt;strong&gt;ragionare sui tipi di dati e funzioni coinvolti&lt;/strong&gt; possa semplificare e irrobustire il design di un software: i prossimi articoli di questa serie serviranno da introduzione alla programmazione funzionale, trattando i principali strumenti utilizzati e mostrando un modo meno diffuso &lt;strong&gt;ma forse più efficace&lt;/strong&gt; di gestire la complessità del software.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GIT flow e versionamento semantico</title>
      <link>/blog/ita/git-flow-semantic-versioning/</link>
      <pubDate>Tue, 16 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/git-flow-semantic-versioning/</guid>
      <description>

&lt;p&gt;GIT flow è un &lt;strong&gt;flusso di sviluppo&lt;/strong&gt;, ideato da &lt;a href=&#34;http://nvie.com/about/&#34;&gt;Vincent Driessen&lt;/a&gt;, che descrive un modello di diramazione, (&lt;a href=&#34;http://git-scm.com/docs/git-branch&#34;&gt;branching&lt;/a&gt;), ben preciso costruito intorno al concetto di release software.&lt;/p&gt;

&lt;p&gt;Questo flusso è concepito per sfruttare al meglio le potenzialità del software di versionamento &lt;a href=&#34;https://git-scm.com/&#34;&gt;GIT&lt;/a&gt;, ma affinità concettuali possono essere utili anche per la gestione del lavoro con altri software dediti alla medesima funzionalità.&lt;/p&gt;

&lt;p&gt;Il flusso descritto in GIT flow è finalizzato a mantenere una storia implementativa pulita, dove un rilascio comunica a tutti gli utilizzatori la presenza di una &lt;strong&gt;nuova versione&lt;/strong&gt; del prodotto, definita da un determinato &lt;em&gt;changelog&lt;/em&gt; composto da nuove caratteristiche e correzioni.&lt;/p&gt;

&lt;p&gt;I &lt;strong&gt;vantaggi&lt;/strong&gt; derivanti da questo approccio al versionamento (&lt;a href=&#34;https://en.wikipedia.org/wiki/Software_versioning&#34;&gt;software versioning&lt;/a&gt;), sono anzitutto quello di &lt;strong&gt;tenere una storia pulita&lt;/strong&gt; e leggibile, il che faciliterà la vita a chi decide di usare il nostro software, ma anche quello di poter &lt;strong&gt;concentrare e diversificare gli sforzi&lt;/strong&gt; del team di sviluppo sulle particolari fasi: implementazione, correzione, pulizia, rilascio, concedendo a ciascuna di esse determinati spazi all&amp;rsquo;interno del repository e determinate tempistiche all&amp;rsquo;interno del flusso.&lt;/p&gt;

&lt;p&gt;In questo articolo descriveremo git flow e uniremo l&amp;rsquo;adozione di questo flusso a quello di una strategia di versionamento semantico (semantic versioning) così come proposto e descritta da &lt;a href=&#34;http://tom.preston-werner.com/&#34;&gt;Tom Preston-Werner&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Come vedremo in seguito il punto di incontro fra git e il versionamento semantico ha la sua chiave di volta nella creazione di tag appropriate sulle commit dei nostri rami o &lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Basics-Tagging&#34;&gt;tagging&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Inoltre è bene tenere a mente che diversi software di gestione delle dipendenze basano il proprio flusso operativo sul presupposto una strategia di versionamento semantico simile a quella che andremo a descrivere, come ad esempio &lt;a href=&#34;https://getcomposer.org&#34;&gt;composer&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;branch-storici:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;Branch storici&lt;/h3&gt;

&lt;p&gt;Anzitutto questo modello di workflow prevede la presenza di ben due master branch, &lt;strong&gt;&amp;ldquo;dev&amp;rdquo;&lt;/strong&gt; (o &amp;ldquo;develop&amp;rdquo;) utilizzato per lo sviluppo, ed il buon vecchio &lt;strong&gt;&amp;ldquo;master&amp;rdquo;&lt;/strong&gt; per i rilasci ufficiali.&lt;/p&gt;

&lt;p&gt;Questi due branch assolvono il compito di &amp;ldquo;historical branch&amp;rdquo;, cioè essi devono detenere la storia pulita del progetto, a prescindere dagli sviluppi di nuove feature e hotfix, che altrimenti confluirebbero senza filtri sul ramo principale, rendendo meno comprensibile la storia del progetto e quindi più difficoltose operazioni di reversione (&lt;a href=&#34;https://en.wikipedia.org/wiki/Reversion_%28software_development%29&#34;&gt;revert&lt;/a&gt;) a stati precedenti.&lt;/p&gt;

&lt;h3 id=&#34;branch-di-funzionalità:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;Branch di funzionalità&lt;/h3&gt;

&lt;p&gt;Un branch di funzionalità, ovvero un &lt;strong&gt;&amp;ldquo;feature branch&amp;rdquo;&lt;/strong&gt;, aggiunge una nuova funzionalità (&lt;a href=&#34;https://en.wikipedia.org/wiki/Software_feature&#34;&gt;feature&lt;/a&gt;) al software.
Nel modello proposto dal GIT flow, questi branch &lt;strong&gt;devono sempre essere derivati dal branch &amp;ldquo;develop&amp;rdquo;&lt;/strong&gt; e rappresentano una &lt;strong&gt;feature&lt;/strong&gt;, ovvero una nuova funzionalità che si intende aggiungere al software.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/git-flow-semantic-versioning/feature.png&#34; alt=&#34;Git Flow - Feature branch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Questo branch conterrà tutti i pezzi di storia, le commit, relative alla funzionalità implementata.&lt;/p&gt;

&lt;p&gt;Durante lo sviluppo di questi rami non è strettamente necessario mantenere una storia delle versioni pulite o usare particolari nomenclature per le varie commit (pratica che comunque potrebbe avere i suoi vantaggi come vedremo nell&amp;rsquo;ultimo paragrafo), in quanto prima di riportare il branch su develop, &amp;ldquo;appiattiremo&amp;rdquo; la storia del branch attraverso un&amp;rsquo;operazione di &lt;strong&gt;&lt;a href=&#34;http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html&#34;&gt;squash&lt;/a&gt; delle commit&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In questo modo la storia del branch di sviluppo risulterà pulita, con &lt;strong&gt;una sola commit&lt;/strong&gt;, che conterrà solo l&amp;rsquo;informazione relativa all&amp;rsquo;aggiunta della nuova funzionalità.&lt;/p&gt;

&lt;p&gt;Dopo averlo riportato su develop, è possibile rimuovere il feature branch dal repository:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$&amp;gt; git branch -D feat-nomedelfeaturebranch&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In base alle dimensioni del team è possibile mantenere &lt;strong&gt;più feature branch contemporaneamente&lt;/strong&gt;, a patto di riportarli correttamente e in tempi auspicabilmente brevi sul branch di sviluppo.
Di norma un singolo sviluppatore si concentra sul rilascio di una feature per volta.&lt;/p&gt;

&lt;h3 id=&#34;branch-di-rilascio:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;Branch di rilascio&lt;/h3&gt;

&lt;p&gt;Quando il ramo di sviluppo (develop) contiene abbastanza feature per un &lt;strong&gt;rilascio&lt;/strong&gt; (o in base a qualsiasi altro tipo di scadenza prefissata), da questi viene derivato un nuovo branch detto di rilascio, o &lt;strong&gt;&lt;a href=&#34;http://producingoss.com/en/release-branches.html&#34;&gt;release branch&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;È buona norma distinguere questi rami con un nome significativo e consistente, ad esempio possono tutti iniziare con il prefisso &amp;ldquo;release-&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A questo punto dello sviluppo non possono essere più aggiunte feature e le uniche aggiunte possibili possono essere quelle di bug fixing e documentazione.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/git-flow-semantic-versioning/release-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Il team si concentrerà sull&amp;rsquo;obiettivo di riportare su master la prossima release
quindi non verranno creati altri branch di funzionalità in quanto in questa fase l&amp;rsquo;obiettivo principale è quello di rilasciare.&lt;/p&gt;

&lt;p&gt;Quando il ramo di rilascio sarà maturo e testato, a questo punto verrà eseguita  l’operazione di merge sul branch “master”, contrassegnandola con un’opportuna &lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Basics-Tagging&#34;&gt;tag&lt;/a&gt;, che ne indichi il versionamento.&lt;/p&gt;

&lt;p&gt;Come per il feature branch, la storia completa dalla nascita alla maturazione di questo ramo dovrebbe essere trasparente per i branch storici, quindi anche qui andremo ad operare un&amp;rsquo;operazione di squash.&lt;/p&gt;

&lt;p&gt;Anche durante il ciclo di vita di questi rami, è buona pratica usare nomenclature particolari per i tag delle commit, ma non indispensabile: vedremo questo concetto più avanti nell&amp;rsquo;ultimo paragrafo.&lt;/p&gt;

&lt;p&gt;Allo stesso modo il branch di rilascio verrà eseguita indietro anche sul branch “develop”, tralasciando l&amp;rsquo;aggiunta dei tag di versione.&lt;/p&gt;

&lt;p&gt;Una volta mergiato con i branch storici, il branch di release non ha più motivo di esistere e sarebbe opportuno cancellarlo.&lt;/p&gt;

&lt;h3 id=&#34;branch-di-manutenzione:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;Branch di manutenzione&lt;/h3&gt;

&lt;p&gt;Una migliore organizzazione dei rilasci non scongiura sicuramente l’occorrenza di problemi da risolvere con estrema urgenza.
In questo caso, e solo in questo caso, è possibile derivare (avviare un fork) direttamente da master un branch di manutenzione, contenente la fix necessaria a risolvere il problema insorto.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/git-flow-semantic-versioning/hotfix-2.png&#34; alt=&#34;Mantainance branch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;È buona norma inoltre distinguere questi branch con un nome significativo e consistente, ad esempio possono tutti iniziare con il prefisso “hotfix-”.&lt;/p&gt;

&lt;p&gt;Tale branch sarà ovviamente riportato su “master” il più presto possibile, ed in seguito anche su “develop” per mantenere la situazione dei due branch storici allineata.&lt;/p&gt;

&lt;p&gt;Come nel caso dei branch di rilascio, qundo un branch di manutenzione viene riportato su master, il tag di master verrà contrassegnato appropriatamente.&lt;/p&gt;

&lt;h3 id=&#34;versionamento-semantico:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;Versionamento semantico&lt;/h3&gt;

&lt;p&gt;Il versionamento semantico (semantic versioning) è un semplice schema di denominazione dei rilasci che ruota attorno a tre numeri: major, minor e patch.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/git-flow-semantic-versioning/alltogheter.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Il formato prevede la concatenazione di questi tre numeri attraverso la notazione punto.
Ad es: 1.1.2, indica major version: 1, minor version: 1 e patch: 2.&lt;/p&gt;

&lt;p&gt;Riportato sullo schema prima descritto nel GIT flow, i tre numeri di versionamento  saranno le tag dei branch.&lt;/p&gt;

&lt;p&gt;In pratica:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Se abbiamo rilasciato una hotfix, che sostanzialmente non va ad intaccare le modalità di utilizzo del codice, dovremmo andare a incrementare il numero di &lt;strong&gt;patch&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Se abbiamo implementato una modifica minore, spesso l&amp;rsquo;aggiunta di una feature che non pregiudica la retrocompatibilità del codice, andremo a incrementare il numero di &lt;strong&gt;minor&lt;/strong&gt; versioning.&lt;/li&gt;
&lt;li&gt;Rilasci più consistenti che cambiano in maniera apprezzabile il funzionamento del codice andranno a incrementare il numero di &lt;strong&gt;major&lt;/strong&gt; versioning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Può essere inoltre indicato un &lt;strong&gt;suffisso di build&lt;/strong&gt;, ad esempio una sequenza alfabetica in linguaggio naturale, seguita da un numero incrementale.&lt;/p&gt;

&lt;p&gt;Ad es:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.1.2-snapshot20150602, indica una snapshot di un feature branch di 1.1.2, ovvero una &amp;ldquo;fotografia&amp;rdquo; specifica dello sviluppo di una feature&lt;/li&gt;
&lt;li&gt;1.1.2-rc1, indica una release candidate, ovvero una versione del software &amp;ldquo;papabile&amp;rdquo; per il rilascio&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un suffisso di build come quello indicato nel primo esempio potrebbe essere relativo ad un feature branch, derivato dal tag 1.1.2 del branch di sviluppo e in parole povere indica che quella messa a disposizione è semplicemente un&amp;rsquo;anteprima del codice, in cui è ammissibile una certa instabilità.&lt;/p&gt;

&lt;p&gt;Questo tipo di tag dovrebbero essere provati e installati &lt;strong&gt;solo su ambienti di test&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Quello nel secondo esempio invece potrebbe essere il suffisso di un tag su un branch di release che indica una versione del codice, matura al punto da poter essere inclusa in una prossima release, detta &lt;a href=&#34;https://it.wikipedia.org/wiki/Release_candidate&#34;&gt;release candidate&lt;/a&gt;, a patto di minime correzioni.
Tali modifiche modifiche e correzioni dovrebbero susseguirsi andando a incrementare il suffisso numerico dopo rc delle prossime tag sul ramo di rilascio.&lt;/p&gt;

&lt;p&gt;Questo tipo di tag indicano le versioni del software che generalmente verranno installate sugli ambienti di &lt;a href=&#34;https://en.wikipedia.org/wiki/Deployment_environment#Staging&#34;&gt;staging&lt;/a&gt;, per poterle testare prima di essere riportate su master e andare quindi in &lt;a href=&#34;https://en.wikipedia.org/wiki/Deployment_environment#Production&#34;&gt;produzione&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusioni:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;Conclusioni&lt;/h3&gt;

&lt;p&gt;Alla fine di questa analisi non possiamo affermare che git flow e il versionamento semantico possano essere gli strumenti definitivi per ogni team o progetto, e sicuramente la loro adozione porta vantaggi e svantaggi.
Valutare un trade-off relativo all&amp;rsquo;impiego di git flow sta al buonsenso personale, ci limiteremo perciò ad elencare una serie di pro e contro che potrebbero aiutare nella decisione.&lt;/p&gt;

&lt;h4 id=&#34;a-cosa-non-serve-git-flow:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;A cosa non serve git flow?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Git flow non pone rimedio ad errori tecnici nella gestione del repository e nemmeno prescinde da una conoscenza approfondita di git.&lt;/li&gt;
&lt;li&gt;Git flow de facto &lt;strong&gt;non semplifica il flusso di lavoro&lt;/strong&gt; con git, imponendo una strategia di diramazione complessa.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;a-cosa-serve-git-flow:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;A cosa serve git flow?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Git flow aiuta i vari elementi del team ad avere a colpo d&amp;rsquo;occhio &lt;strong&gt;una visione precisa dello stato degli sviluppi applicativi&lt;/strong&gt; a fronte di una convenzione essenziale e immediata di tagging.&lt;/li&gt;
&lt;li&gt;Il versionamento semantico aiuta gli utilizzatori del software a capire esattamente lo stato di sviluppo del software e cosa aspettarsi, riportandosi a diverse versioni di rilascio.&lt;/li&gt;
&lt;li&gt;Git flow coaudiva la &lt;a href=&#34;https://en.wikipedia.org/wiki/Velocity_(software_development&#34;&gt;velocity&lt;/a&gt;) del team di sviluppo permettendo l&amp;rsquo;attuazione di un piano di &lt;a href=&#34;http://guide.agilealliance.org/guide/cd.html&#34;&gt;continuous deploy&lt;/a&gt; e quindi di poter rilasciare nuove feature e fix in sicurezza.&lt;/li&gt;
&lt;li&gt;Git flow è ottimo per la &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;continuous integration&lt;/a&gt;, permettendo de facto di poter differenziare i rami dedicati ai vari ambienti: sviluppo, staging e produzione&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;risorse-consultabili-online:1dd853596dfead5a0fffb4551b5f2efb&#34;&gt;Risorse consultabili online&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nvie.com/posts/a-successful-git-branching-model/&#34;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt; Vincent Driessen espone GIT Flow&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://semver.org/&#34;&gt;http://semver.org/&lt;/a&gt; Semantic Versioning 2.0.0 proposto da Tom Preston-Werner&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow&#34;&gt;https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow&lt;/a&gt; - Tutorial messo a disposizione da Atlassian&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://datasift.github.io/gitflow/Versioning.html&#34;&gt;https://datasift.github.io/gitflow/Versioning.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Swift testing avanzato: stubbing e test asincroni</title>
      <link>/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/xcode-testing-in-pratica/&#34;&gt;In un precedente articolo&lt;/a&gt; abbiamo visto le impostazioni di base in Xcode per la scrittura dei &lt;strong&gt;test unitari&lt;/strong&gt;: abbiamo evidenziato inoltre &lt;strong&gt;l&amp;rsquo;importanza e l&amp;rsquo;utilità intrinseca dei test&lt;/strong&gt;, attraverso un semplice esempio riguardante un caso d&amp;rsquo;uso tipico. Nel presente articolo vedremo alcune tecniche un po&amp;rsquo; più avanzate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;implementeremo uno &lt;strong&gt;Stub Object&lt;/strong&gt; in Swift;&lt;/li&gt;
&lt;li&gt;analizzeremo un altro caso di test &lt;em&gt;asincrono&lt;/em&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lo-stub-object:4b7c206247a0a425bb1064c53b31df66&#34;&gt;Lo &lt;em&gt;Stub Object&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Uno &lt;em&gt;Stub Object&lt;/em&gt; (per il resto dell&amp;rsquo;articolo, &lt;em&gt;stub&lt;/em&gt;) rappresenta un&amp;rsquo;istanza di una certa classe, la quale &lt;em&gt;mima&lt;/em&gt; una vera classe presente nella nostra &lt;em&gt;code base&lt;/em&gt;:  l&amp;rsquo;istanza si comporta esattamente come una equivalente istanza della classe mimata, tranne alcune differenze, ad esempio &lt;strong&gt;alcuni metodi possono essere sovrascritti&lt;/strong&gt; per poter fornire &lt;strong&gt;un determinato output&lt;/strong&gt; utile per i test. Nell&amp;rsquo;implementare uno &lt;em&gt;stub&lt;/em&gt; non è generalmente consentito modificare dettagli di logica interni relativi alla classe che stiamo mimando, ma &lt;strong&gt;è possibile sovrascrivere metodi pubblici&lt;/strong&gt;, in modo che essi ritornino i valori che vogliamo, oppure che svolgano una particolare procedura necessaria per i test. Tanto per fare un esempio pratico potremmo &lt;em&gt;stubbare&lt;/em&gt; una classe che ci fornisce la data precisa in un certo istante, in modo da ottenere una data diversa da usare nei test, oppure un client che chiede a un server delle informazioni su un utente, in modo da far ritonare al client &lt;em&gt;stub&lt;/em&gt; delle informazioni arbitrarie.&lt;/p&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; fanno parte di una classe di strumenti che sono usati nell&amp;rsquo;ambito dello &lt;em&gt;Unit Testing&lt;/em&gt; per verificare che determinati oggetti rispettino precisi &lt;strong&gt;contratti&lt;/strong&gt; stipulati tra essi: il classico articolo di Martin Fowler &lt;a href=&#34;http://martinfowler.com/articles/mocksArentStubs.html&#34;&gt;Mocks Aren&amp;rsquo;t Stubs&lt;/a&gt; è solitamente considerato un buon punto di riferimento per comprendere i possibili strumenti usati a tal scopo. L&amp;rsquo;idea è che, dal punto di vista dei nostri test unitari, un oggetto risulterà essere &lt;em&gt;correttamente implementato&lt;/em&gt; se avrà rispettato la sua parte del &lt;em&gt;contratto&lt;/em&gt; stipulato con altri oggetti, con la seguente conseguenza:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;se l&amp;rsquo;oggetto A è correttamente implementato e l&amp;rsquo;oggetto B rispetta il contratto stipulato con l&amp;rsquo;oggetto A, allora anche l&amp;rsquo;oggetto B è correttamente implementato&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; permettono di &lt;strong&gt;disaccoppiare le logiche di funzionamento degli oggetti&lt;/strong&gt; perché, se abbiamo verificato il corretto funzionamento dell&amp;rsquo;oggetto A (attraverso appropriati test unitari), possiamo usare uno &lt;em&gt;stub&lt;/em&gt; di tale oggetto per verificare il corretto funzionamento dell&amp;rsquo;oggetto B nei suoi confronti, eliminando qualsiasi dipendenza di B nei confronti della logica interna dell&amp;rsquo;oggetto A. L&amp;rsquo;obiettivo è scrivere quindi dei &lt;strong&gt;test veramente unitari&lt;/strong&gt; per l&amp;rsquo;oggetto B, anche se questo dipende dall&amp;rsquo;oggetto A. Il classico talk &lt;a href=&#34;https://vimeo.com/80533536&#34;&gt;Integration Tests are a scam&lt;/a&gt; di J.B. Rainsberger fornisce un punto di vista particolarmente &amp;ldquo;radicale&amp;rdquo; sull&amp;rsquo;argomento.&lt;/p&gt;

&lt;p&gt;Il classico caso in cui uno &lt;em&gt;stub&lt;/em&gt; risulta utile è quello del client che fa una richiesta al server: se la logica di implementazione del server è sotto il nostro controllo possiamo &lt;strong&gt;testare che il server rispetti il contratto con i suoi client&lt;/strong&gt; generando degli &lt;em&gt;stub&lt;/em&gt; di questi per ogni possibile richiesta; d&amp;rsquo;altra parte, per verificare che i client siano in grado di &lt;strong&gt;gestire correttamente ogni possibile risposta del server&lt;/strong&gt;, possiamo generare uno &lt;em&gt;stub&lt;/em&gt; del server che fornisca ogni possibile risposta: in questo modo possiamo testare in maniera disaccoppiata client e server.&lt;/p&gt;

&lt;h2 id=&#34;un-caso-d-uso-location-services:4b7c206247a0a425bb1064c53b31df66&#34;&gt;Un caso d&amp;rsquo;uso: &lt;em&gt;Location Services&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Il caso d&amp;rsquo;uso che tratteremo è relativo ai &lt;strong&gt;servizi di localizzazione&lt;/strong&gt;, uno strumento frequentemente utilizzato dagli sviluppatori iOS e in generale da chi sviluppa su &lt;strong&gt;smartphone&lt;/strong&gt;: per tali sviluppatori, quello dei servizi di localizzazione è un tema molto importante, &lt;strong&gt;fonte di complessità e sfide&lt;/strong&gt; che caratterizzano tipicamente il mondo &lt;em&gt;mobile&lt;/em&gt;. Non è infatti possibile ottenere l&amp;rsquo;attuale posizione GPS in un preciso momento: l&amp;rsquo;ultima posizione GPS disponibile si basa su una regressione, effettuata dal sistema, dei dati ricevuti da diversi sensori - antenne wifi, cellulare e ovviamente GPS, e spesso anche i sensori di movimento - in diversi momenti; &lt;strong&gt;il sistema può inviare notifiche alla nostra app in qualsiasi momento&lt;/strong&gt;, ed essa deve essere in grado di &amp;ldquo;digerire&amp;rdquo; correttamente i dati ricevuti, interpretando anche eventuali errori. Scrivere dei test unitari per verificare che la nostra app geolocalizzata funzioni correttamente può presentare non poche difficoltà: non possiamo infatti affidarci ai &amp;ldquo;veri&amp;rdquo; sensori del dispositivo, perché probabilmente i test verranno eseguiti sul simulatore, oppure magari su un vero iPhone la cui ricezione GPS in un certo istante potrà essere più o meno buona, ma essa rappresenterà un solo caso possibile rispetto a tanti. Vogliamo essere in grado di &lt;strong&gt;testare ogni possibile risposta&lt;/strong&gt; del sistema GPS del dispositivo, dall&amp;rsquo;assenza totale di segnale al cambiamento frequente di posizione, alla &lt;strong&gt;mancata autorizzazione&lt;/strong&gt; da parte dell&amp;rsquo;utente per l&amp;rsquo;accesso ai servizi di localizzazione.&lt;/p&gt;

&lt;p&gt;Supponiamo ad esempio che una certa classe, diciamo un &lt;code&gt;UIViewController&lt;/code&gt;, esegua delle &lt;strong&gt;azioni che dipendono dalla posizione ricevuta&lt;/strong&gt;. L&amp;rsquo;idea è quella di testare che il nostro &lt;code&gt;UIViewController&lt;/code&gt; si comporti &amp;ldquo;bene&amp;rdquo; rispetto alle notifiche del sistema di localizzazione. Il progetto Xcode contenente il codice mostrato in questo articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/AsyncTestingStubbing&#34;&gt;GitHub&lt;/a&gt;: si consiglia di scaricare il progetto e tenerlo a riferimento per il resto dell&amp;rsquo;articolo.&lt;/p&gt;

&lt;p&gt;Invece di usare direttamente &lt;code&gt;CLLocationManager&lt;/code&gt; per ottenere la posizione GPS del dispositivo, implementeremo una semplice classe che fungerà da &lt;em&gt;wrapper&lt;/em&gt;, chiamata &lt;code&gt;LocationCoordinator&lt;/code&gt;: un&amp;rsquo;istanza di tale classe potrà essere configurata con due semplici funzioni &lt;code&gt;onUpdate&lt;/code&gt; e &lt;code&gt;onFailure&lt;/code&gt;, in modo da evitare l&amp;rsquo;implementazione dei vari metodi di callback del &lt;code&gt;protocol&lt;/code&gt; &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt;. L&amp;rsquo;idea è quella di passare un&amp;rsquo;istanza di &lt;code&gt;LocationCoordinator&lt;/code&gt; al nostro &lt;code&gt;UIViewController&lt;/code&gt;: quest&amp;rsquo;ultimo quindi imposterà le due funzioni di callback indicate sopra, in modo da modificare il suo stato e i dati mostrati all&amp;rsquo;utente.&lt;/p&gt;

&lt;p&gt;Di seguito è riportato il codice della classe &lt;code&gt;LocationCoordinator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import CoreLocation

public class LocationCoordinator: NSObject {
    
    public let locationManager: CLLocationManager
    
    public override init() {
        locationManager = CLLocationManager()
        super.init()
        locationManager.delegate = self
        locationManager.requestWhenInUseAuthorization()
    }
    
    private var updated: (CLLocation -&amp;gt; ())?
    public func onUpdate(value: CLLocation -&amp;gt; ()) {
        updated = value
    }
    
    private var failed: (NSError -&amp;gt; ())?
    public func onFailure(value: NSError -&amp;gt; ()) {
        failed = value
    }
}

extension LocationCoordinator: CLLocationManagerDelegate {
    
    public func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) {
        let location = locations.last as! CLLocation
        if let updated = self.updated {
            updated(location)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didFailWithError error: NSError!) {
        if let failed = self.failed {
            failed(error)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
        switch status {
        case .AuthorizedWhenInUse:
            locationManager.startUpdatingLocation()
        default:
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la classe è configurata per richiedere l&amp;rsquo;autorizzazione a leggere la posizione GPS del dispositivo quando l&amp;rsquo;app è in uso, ma non sarà necessario fornire questa autorizzazione per i test: creeremo infatti uno &lt;em&gt;stub&lt;/em&gt; che genererà posizioni arbitrarie, senza usare i sensori di sistema. Si ricorda inoltre che usando iOS SDK &amp;gt;= 8.0, per usare i servizi di localizzazione sarà necessario inserire nel file Info.plist una chiave che descrive il motivo per il quale l&amp;rsquo;app chiede l&amp;rsquo;autorizzazione ad accedere a tali servizi:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/content/images/2015/06/Schermata-2015-06-03-alle-08-44-25-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sebbene l&amp;rsquo;aggiunta della chiave &lt;code&gt;NSLocationWhenIsUseUsageDescription&lt;/code&gt; non sia necessaria per eseguire i test, senza questa chiave l&amp;rsquo;app non potrà funzionare in iOS8 nel caso in cui provassimo ad avviarla normalmente.&lt;/p&gt;

&lt;p&gt;La classe di cui vogliamo testare il corretto funzionamento è indicata nel progetto con il nome di &lt;code&gt;LocationViewController&lt;/code&gt;, e il suo scopo è mostrare le attuali coordinate GPS dell&amp;rsquo;utente o mostrare un messaggio in caso di errore: un sua istanza è, in ogni instante, caratterizzata da un &lt;code&gt;LocationState&lt;/code&gt; che rappresenta in quale stato essa si trova rispetto alla ricerca della posizione GPS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum LocationState {
    case Searching
    case Found
    case Error(CLError)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementiamo-i-test:4b7c206247a0a425bb1064c53b31df66&#34;&gt;Implementiamo i test&lt;/h2&gt;

&lt;p&gt;Per testare la classe verificheremo che, a seconda dei diversi possibili risultati ottenibili dalla ricerca della posizione GPS, un&amp;rsquo;istanza di essa &lt;strong&gt;aggiorni correttamente il suo stato attuale&lt;/strong&gt;. È quindi necessario fare in modo che un&amp;rsquo;istanza del &lt;code&gt;LocationCoordinator&lt;/code&gt; ignori le notifiche ricevute da &lt;code&gt;CLLocationManager&lt;/code&gt;, in modo da forzare posizioni ed errori comodi per i nostri test; per farlo dichiariamo una sottoclasse di &lt;code&gt;LocationCoordinator&lt;/code&gt; chiamata &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt; che modifichi la &lt;em&gt;parent class&lt;/em&gt; nel seguente modo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ignora le notifiche del &lt;code&gt;locationManager&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;locationManager.stopUpdatingLocation()
locationManager.delegate = nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dichiara 4 funzioni per forzare posizione GPS e/o errori:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forceLocation
forceError
forceRandomDelayedLocations
forceDelayedErrorLocationUnknown
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ciascuna di queste funzioni genera le stesse notifiche che normalmente genererebbe &lt;code&gt;CLLocationManager&lt;/code&gt;. Le prime due funzioni, &lt;code&gt;forceLocation&lt;/code&gt; e &lt;code&gt;forceError&lt;/code&gt; forzano immediatamente una certa posizione GPS o un certo errore, mentre la funzione &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; genera una serie di posizioni casuali dopo un certo ritardo e a intervalli regolari, e la funzione &lt;code&gt;forceDelayedErrorLocationUnknown&lt;/code&gt; forza un errore del tipo &lt;code&gt;.LocationUnknown&lt;/code&gt; dopo un certo ritardo.&lt;/p&gt;

&lt;p&gt;Prima di procedere con i test osserviamo che nel file &lt;code&gt;AsyncTestingStubbingTests.swift&lt;/code&gt; c&amp;rsquo;è una sezione &lt;em&gt;utility&lt;/em&gt; nella quale sono implementate alcune funzioni comode per &lt;strong&gt;rendere  il codice dei test più espressivo&lt;/strong&gt;. Ad esempio la funzione &lt;code&gt;mainViewController&lt;/code&gt; ritorna l&amp;rsquo;istanza del LocationViewController utilizzata nell&amp;rsquo;interfaccia grafica nell&amp;rsquo;app. Il &lt;em&gt;testing framework&lt;/em&gt; integrato in Xcode è chiamato &lt;code&gt;XCTest&lt;/code&gt;, e per quanto adeguatamente completo nelle sue funzionalità, esso è principalmente basato su funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt; che verificano che una qualche condizione sia vera, e se non lo è stampano in console un messaggio di errore passato alla stessa funzione &lt;code&gt;XCTAssert&lt;/code&gt; nel momento in cui essa è chiamata: questo può portare alla scrittura di &lt;strong&gt;test verbosi e poco espressivi&lt;/strong&gt;. Ci sono diverse librerie facilmente integrabili nei progetti Xcode che semplificano la scrittura dei nostri &lt;em&gt;assert&lt;/em&gt;, come ad esempio &lt;a href=&#34;https://github.com/Quick/Nimble&#34;&gt;Nimble&lt;/a&gt;, ma come si può vedere dalle poche funzioni di utility implementate nel progetto associato a questo articolo, basta poco per migliorare consistentemente la leggibilità dei nostri test.&lt;/p&gt;

&lt;p&gt;A questo punto possiamo procedere all&amp;rsquo;implementazione dei test. Le funzioni &lt;code&gt;testLocation&lt;/code&gt; e &lt;code&gt;testError&lt;/code&gt; testano semplicemente che lo stato del &lt;code&gt;mainViewController&lt;/code&gt; sia corretto prima e dopo la generazione di una posizione GPS e di un errore arbitrari. Tuttavia questi test non permettono di rappresentare correttamente un caso d&amp;rsquo;uso tipico, perché &lt;strong&gt;le notifiche sulla posizione GPS posso arrivare in qualsiasi momento&lt;/strong&gt;, e il &lt;code&gt;LocationViewController&lt;/code&gt; deve essere in grado di &lt;em&gt;reagire&lt;/em&gt; alle notifiche nel momento in cui queste si presentano. Per simulare la cosa useremo due test &lt;em&gt;asincroni&lt;/em&gt;, cioè test il cui risultato non è ottenuto immediatamente, ma dopo un certo tempo: l&amp;rsquo;idea è quella di &amp;ldquo;mettere in pausa&amp;rdquo; i test per un certo numero di secondi, finché non si verifica una certa condizione oppure non scade il tempo: in quest&amp;rsquo;ultimo caso il test verrà considerato &lt;strong&gt;fallito&lt;/strong&gt; da &lt;code&gt;XCTest&lt;/code&gt; perché la condizione attesa non si è verificata entro il tempo richiesto.&lt;/p&gt;

&lt;p&gt;Riportiamo ad esempio il codice della funzione &lt;code&gt;testDelayedLocation&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDelayedLocation() {
        if let vc = mainViewController() {
            let locationExpectation = expectationWithDescription(&amp;quot;locationExpectation&amp;quot;)
            let coordinator = STUB_LocationCoordinator()
            vc.showLocationWithCoordinator(coordinator)
            vc.locationState.assertState(.Searching)
            coordinator.forceRandomDelayedLocations(0.25, times:3)
            after(0.5) {
                vc.locationState.assertState(.Found)
                after(0.25) {
                    vc.locationState.assertState(.Found)
                    locationExpectation.fulfill()
                }
            }
            vc.locationState.assertState(.Searching)
            waitForExpectationsWithTimeout(1, handler: nil)
        }
        else {
            fail(&amp;quot;this will never happen&amp;quot;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione di utility &lt;code&gt;after&lt;/code&gt; semplicemente esegue del codice dopo un certo numero di secondi: in base all&amp;rsquo;implementazione di &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; presente in &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt;, il &lt;code&gt;LocationViewController&lt;/code&gt; dovrebbe  ricevere alcune posizioni GPS a intervalli regolari dopo un certo ritardo, e per verificarlo inseriamo due &lt;em&gt;assert&lt;/em&gt;, dopo mezzo secondo e poi ancora un quarto di secondo. Per realizzare il test asincrono  definiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt;, quindi una &amp;ldquo;aspettativa&amp;rdquo;, chiamata &lt;code&gt;locationExpectation&lt;/code&gt;: in coda al codice di test chiamiamo la funzione &lt;code&gt;waitForExpectationsWithTimeout&lt;/code&gt; che fa continuare la funzione di test - senza che essa &lt;em&gt;ritorni&lt;/em&gt; - fino alla &amp;ldquo;realizzazione&amp;rdquo; delle aspettative, tenendo conto di un certo tempo di timeout. Quindi, per &amp;ldquo;realizzare&amp;rdquo; un&amp;rsquo;aspettativa, chiamiamo la funzione &lt;code&gt;fulfill&lt;/code&gt; su &lt;code&gt;locationExpectation&lt;/code&gt;, ma solo dopo aver verificato che lo stato del &lt;code&gt;LocationViewController&lt;/code&gt; sia quello corretto.&lt;/p&gt;

&lt;p&gt;Possiamo estendere ulteriormente la &lt;em&gt;test suite&lt;/em&gt; implementando altri test che simulano ogni tipo di errore possibile, oppure che simulano una situazione in cui posizioni GPS e errori si alternano: una volta compresa la struttura di base per realizzare &lt;em&gt;stub&lt;/em&gt; e test asincroni sarà facile migliorare la &lt;a href=&#34;http://engineering.facile.it/software-testing-coverage-vs-efficacia/&#34;&gt;coverage&lt;/a&gt; dei nostri test.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Facile.it devs @ PHP Day 2015</title>
      <link>/blog/ita/php-day-2015/</link>
      <pubDate>Tue, 19 May 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/php-day-2015/</guid>
      <description>

&lt;p&gt;Anche quest&amp;rsquo;anno si è svolto il &lt;strong&gt;&lt;a href=&#34;http://2015.phpday.it/&#34;&gt;PHP Day&lt;/a&gt; a Verona, il 15 e 16 maggio&lt;/strong&gt;. Noi sviluppatori di Facile.it abbiamo partecipato con un folto gruppo e seguito i vari talks.&lt;/p&gt;

&lt;p&gt;In questo breve articolo vorremmo citare quelli che in qualche maniera &lt;strong&gt;ci hanno colpito&lt;/strong&gt;, per motivi tecnici e non, per dare l&amp;rsquo;opportunità a chi non ha potuto partecipare di sapere qualcosa di più, o per dare &lt;strong&gt;un assaggio della conferenza&lt;/strong&gt; a chi non ha mai partecipato a qualcosa del genere e, speriamo, invogliarlo a far parte della community!&lt;/p&gt;

&lt;p&gt;Ovviamente non pretendiamo di fare una recensione, né quanto meno una classifica&amp;hellip; I talk che abbiamo scelto di citare sono stati scelti per puro &lt;strong&gt;gusto personale&lt;/strong&gt;, o ci hanno semplicemente colpito perché si avvicinavano di più alla nostra esperienza di sviluppatori, o perché toccavano più da vicino lo &lt;strong&gt;stack tecnologico&lt;/strong&gt; da noi utilizzato.&lt;/p&gt;

&lt;p&gt;I talk sono in ordine cronologico. Buona lettura!&lt;/p&gt;

&lt;h4 id=&#34;indice:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Indice&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#prophecy&#34;&gt;PHP object mocking framework world: let&amp;rsquo;s compare Prophecy and PHPUnit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#containerize&#34;&gt;Containerize your PHP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#varnish&#34;&gt;Going crazy with Symfony2 and Varnish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#psr-7&#34;&gt;Hello, PSR-7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#php7-data-structures&#34;&gt;PHP Data Structures (and the impact of PHP 7 on them)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#doctrine&#34;&gt;Doctrine ORM Good Practices and Tricks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;keynotes:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Keynotes&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#coderabbi&#34;&gt;Talmudic Maxims to Maximize Your Growth as a Developer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#calevans&#34;&gt;Down the Rabbit Hole: Lessons Learned combining Career and Community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#seldaek&#34;&gt;Behind the Scenes of Maintaining an Open Source Project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;talk-tecnici:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Talk tecnici&lt;/h1&gt;

&lt;p&gt;&lt;a name=&#34;prophecy&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;php-object-mocking-framework-world-let-s-compare-prophecy-and-phpunit:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;PHP object mocking framework world: let&amp;rsquo;s compare Prophecy and PHPUnit&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Sarah Khalil (&lt;a href=&#34;http://twitter.com/saro0h&#34;&gt;@saro0h&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 1 - 14:30 – 15:30 - track 1 (&lt;a href=&#34;https://speakerdeck.com/saro0h/php-day-verona-2015-php-object-mocking-framework-world&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/134728681&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Una buona esposizione su &lt;a href=&#34;https://github.com/phpspec/prophecy-phpunit&#34;&gt;prophecy&lt;/a&gt; la nuova tecnologia per effetuare mocking e stubbing. In questo talk sono state illustrate le API di prophecy e si è parlato di come questo strumento sarà sempre più integrato con phpunit (è già presente nella nuova versione 4.6) sino ad arrivare ad un completo rimpiazzo dei metodi nativi del famoso testing framework.&lt;/p&gt;

&lt;p&gt;Ricordatevi di aggiungere qualche altra parola (oltre a prophecy) chiave nelle vostre ricerche su google per evitare riferimenti biblici.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;containerize&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;containerize-your-php:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Containerize your PHP&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Marek Jelen (&lt;a href=&#34;http://twitter.com/marek_jelen&#34;&gt;@marek_jelen&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 1 - 15:30 – 16:30 - track 2&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/134728683&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Si è parlato tanto nelle Conferences dell&amp;rsquo;ultimo anno di &lt;strong&gt;Docker e i container&lt;/strong&gt; come strumento di sviluppo, ma questo talk si è rivelato interessante, spiegando come fosse possibile utilizzare i container &lt;strong&gt;come strumento di deploy&lt;/strong&gt; e di creazione di immagini, in modo tale da contenere anche il sorgente del proprio progetto; abbiamo scoperto il tool &lt;a href=&#34;http://github.com/openshift/source-to-image&#34;&gt;Source to Image&lt;/a&gt;, che permette di creare queste immagini in maniera personalizzata e automatizzata partendo dal proprio codice (e dal &lt;code&gt;composer.json&lt;/code&gt;), e il progetto &lt;a href=&#34;http://www.openshift.com/&#34;&gt;Openshift&lt;/a&gt;, portato avanti da RedHat.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;varnish&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;going-crazy-with-symfony2-and-varnish:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Going crazy with Symfony2 and Varnish&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;David De Boer&lt;/li&gt;
&lt;li&gt;Day 1 - 17:30 – 18:00 - track 1&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/134814726&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Prima di ascoltare questo talk, pensavamo che la &lt;strong&gt;cache HTTP&lt;/strong&gt; (e Varnish) fossero praticamente inutilizzabili in un &lt;strong&gt;ambito di sito non-pubblico&lt;/strong&gt;, dove i contenuti vanno serviti (e variano in base) ad utenti sempre autenticati.&lt;/p&gt;

&lt;p&gt;Abbiamo scoperto il &lt;a href=&#34;http://github.com/FriendsOfSymfony/FOSHttpCacheBundle&#34;&gt;FOSHttpCacheBundle&lt;/a&gt;, e il trucco che permette di fare caching anche di questo tipo di contenuti: Varnish prende il cookie e controlla la cache non in base a quello, ma in base ad un hash che viene fornito dall&amp;rsquo;applicazione stessa tramite un altra chiamata; questo permette di &lt;strong&gt;mappare i contenuti cachati&lt;/strong&gt; non sui singoli utenti, ma &lt;strong&gt;con logiche più ottimizzate&lt;/strong&gt; (gruppi di utenti? set di permessi?) ed eventualmente più legate alla business logic dell&amp;rsquo;applicazione stessa.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;psr-7&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;hello-psr-7:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Hello, PSR-7&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Beau Simensen (&lt;a href=&#34;http://www.twitter.com/beausimensen&#34;&gt;@beausimensen&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 2 - 11:00 – 12:00 - track 2 (&lt;a href=&#34;https://beau.io/talks/2015/05/16/hello-psr-7-phpday-2015/&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/134281520&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;In questo talk abbiamo potuto conoscere da vicino la genesi dello &lt;strong&gt;standard PSR-7&lt;/strong&gt; (di cui abbiamo già scritto in un &lt;a href=&#34;http://engineering.facile.it/php-fig-standard-psr-7-http-message-interfaces/&#34;&gt;altro articolo&lt;/a&gt;), raccontata da una delle persone che hanno seguito da vicino e contribuito alla scrittura della proposta stessa.&lt;/p&gt;

&lt;p&gt;Lo standard sarà approvato a brevissimo (solo 3 giorni dopo il talk!) e molti aspettano di vedere cosa comporterà a livello di framework PHP.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;php7-data-structures&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;php-data-structures-and-the-impact-of-php-7-on-them:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;PHP Data Structures (and the impact of PHP 7 on them)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Patrick Allaert (&lt;a href=&#34;http://www.twitter.com/patrick_allaert&#34;&gt;@patrick_allaert&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 2 - 12:00 – 13:00 - track 1 (&lt;a href=&#34;http://www.slideshare.net/patrick.allaert/php-data-structures-and-the-impact-of-php-7-on-them-php-days-2015&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/134070469&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Questo talk, dal sapore molto tecnico, ci ha fatto addentrare negli internals degli &lt;strong&gt;array PHP&lt;/strong&gt;, e in quanto siano talmente specializzati a far tutto, da essere &lt;strong&gt;inefficienti&lt;/strong&gt; in moltissimi casi; abbiamo visto numerose &lt;strong&gt;alternative più specialistiche&lt;/strong&gt; per i vari casi d&amp;rsquo;uso (&lt;a href=&#34;http://php.net/manual/en/class.splfixedarray.php&#34;&gt;SplFixedArray&lt;/a&gt;, &lt;a href=&#34;http://php.net/manual/en/class.splqueue.php&#34;&gt;SplQueue&lt;/a&gt;, &lt;a href=&#34;http://php.net/manual/en/class.splstack.php&#34;&gt;SplStack&lt;/a&gt;&amp;hellip;); sfruttare gli uni piuttosto che gli altri impatta fortemente sulle &lt;strong&gt;prestazioni&lt;/strong&gt; nei tempi e nell&amp;rsquo;uso della memoria, e abbiamo visto nel dettaglio alcuni benchmark che mostrano come questi costi diminuiscono (spesso di gran lunga) &lt;strong&gt;tra PHP 5.6 e PHP 7&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;doctrine&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;doctrine-orm-good-practices-and-tricks:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Doctrine ORM Good Practices and Tricks&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Marco Pivetta (&lt;a href=&#34;http://www.twitter.com/Ocramius&#34;&gt;@Ocramius&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 2 - 15:30 – 16:30 - track 1&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src=&#34;https://player.vimeo.com/video/134178140&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Usiamo &lt;strong&gt;Doctrine&lt;/strong&gt; tutti i giorni, ma questo talk, sebbene marcato come di livello &lt;strong&gt;beginner&lt;/strong&gt;, si è rivelato molto interessante e fonte di numerose discussioni e &lt;strong&gt;riflessioni&lt;/strong&gt; tra colleghi. Lo speaker è uno dei principali contributors al progetto &lt;a href=&#34;https://github.com/doctrine/doctrine2&#34;&gt;doctrine-orm&lt;/a&gt;, e ci ha elencato una serie di &lt;strong&gt;best practices&lt;/strong&gt;, partendo dal chiedersi se e quando è il caso di usare un ORM, passando poi a problemi quali l&amp;rsquo;uso e l&amp;rsquo;implementazione di entità, la loro consistenza, l&amp;rsquo;evitare di usare setter brutali o di esporre le ArrayCollection che rappresentano le nostre relazioni.&lt;/p&gt;

&lt;h1 id=&#34;keynotes-1:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Keynotes&lt;/h1&gt;

&lt;p&gt;Abbiamo voluto citare in questo articolo anche i &lt;strong&gt;3 keynote&lt;/strong&gt; della conferenza: sono stati tutti piuttosto interessanti, profondamente motivazionali e coinvolgenti.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;coderabbi&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;talmudic-maxims-to-maximize-your-growth-as-a-developer:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Talmudic Maxims to Maximize Your Growth as a Developer&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Yitzchok Willroth (&lt;a href=&#34;http://www.twitter.com/coderabbi&#34;&gt;@coderabbi&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 1 - keynote di apertura&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yitz, studente rabbinico poi passato alla programmazione, molto famoso nella community PHP, ci ha spinto a considerare alcuni suoi consigli su come poterci &lt;strong&gt;migliorare come sviluppatori&lt;/strong&gt; e come membri della community stessa: cercare e coltivare un mentore, essere pazienti ed accettare i consigli, aiutare gli altri per ripagare tutto questo, partecipare nell&amp;rsquo;open source&amp;hellip;&lt;/p&gt;

&lt;p&gt;Personalmente, mi ha anche fatto scoprire tre siti piuttosto interessanti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://phpmentoring.org/&#34;&gt;PHP Mentoring&lt;/a&gt; e &lt;a href=&#34;http://hackpledge.org&#34;&gt;Hackpledge&lt;/a&gt;, per chi è in cerca di un &lt;strong&gt;mentore&lt;/strong&gt; o vuole diventarlo per aiutare altri a diventare programmatori migliori&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://up-for-grabs.net/&#34;&gt;Up for grabs&lt;/a&gt;, un sito raccoglitore di &lt;strong&gt;issue su GitHub *semplici&lt;/strong&gt;*, un ottimo punto di inizio per chi vorrebbe partecipare a progetti open source, ma non sa da dove cominciare&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;calevans&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;down-the-rabbit-hole-lessons-learned-combining-career-and-community:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Down the Rabbit Hole: Lessons Learned combining Career and Community&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Cal Evans (&lt;a href=&#34;http://www.twitter.com/calevans&#34;&gt;@CalEvans&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 2 - keynote di apertura&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cal è il community manager (ma non chiamatelo così!) per Zend, e ci ha raccontato con estrema passione, qualche lacrima e in maniera molto divertente la sua storia, come è nata la sua carriera di programmatore e come il suo percorso si è intrecciato con la community PHP e il mondo dell&amp;rsquo;open source.&lt;/p&gt;

&lt;p&gt;Tutto questo per spiegarci come &lt;strong&gt;far parte della community è un valore&lt;/strong&gt; importante per tutti ma soprattutto per noi stessi, e come la nostra sia così grande, forte e basata su uno &lt;strong&gt;spirito positivo&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;seldaek&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;behind-the-scenes-of-maintaining-an-open-source-project:2ae40b845e02f26c759cfa0e911c81d0&#34;&gt;Behind the Scenes of Maintaining an Open Source Project&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Jordi Boggiano (&lt;a href=&#34;http://twitter.com/seldaek&#34;&gt;@seldaek&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Day 2 - keynote di chiusura&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jordi è il creatore e mantainer di &lt;a href=&#34;https://getcomposer.org/&#34;&gt;Composer&lt;/a&gt;, uno dei principali tool per un programmatore PHP. Nel suo keynote ci ha raccontato con franchezza la sua esperienza in prima persona nel &lt;strong&gt;gestire un progetto open source&lt;/strong&gt; così vasto e popolare, come spesso sia difficile accontentare tutti, e alcuni retroscena e dettagli di qualche curiosa pull request.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Type First Development in Swift</title>
      <link>/blog/ita/type-first-development-in-swift/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/type-first-development-in-swift/</guid>
      <description>

&lt;p&gt;Con &lt;em&gt;Type First Development&lt;/em&gt; può intendersi un approccio allo sviluppo di nuove funzionalità o moduli di un software partendo dai &lt;strong&gt;tipi&lt;/strong&gt; di dati coinvolti: non si tratta quindi di un pattern o una pratica codificata, ma solo di &lt;strong&gt;un possibile punto di partenza&lt;/strong&gt; per iniziare il ragionamento. Ragionando esclusivamente sui tipi, prima ancora di pensare alle singole specifiche implementazioni dei vari blocchi di codice, è possibile costruire più facilmente una mappa dei vari di flussi di dati che attraversano il nostro software, e verificare immediatamente se stiamo scrivendo qualcosa di sensato, solido ed adeguatamente estendibile.&lt;/p&gt;

&lt;p&gt;Ragionare sui tipi di dato è un classico approccio usato nel paradigma di programmazione noto come &lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_programming&#34;&gt;&lt;em&gt;programmazione funzionale&lt;/em&gt;&lt;/a&gt;, e il presente articolo adotta tale paradigma in maniera piuttosto pura.&lt;/p&gt;

&lt;h2 id=&#34;indice:9546cc279181b22e90a8ccdde798a866&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#il-type-system-di-swift&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#costruiamo-un-form-il-tipo-field&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#funzioni-generiche-e-composizione-funzionale&#34;&gt;Funzioni generiche e composizione funzionale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#il-tipo-form&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;Modifica di un form e ricerca di un campo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusione&#34;&gt;Conclusione&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;il-type-system-di-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-type-system-di-swift:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/h2&gt;

&lt;p&gt;Il linguaggio &lt;strong&gt;Swift&lt;/strong&gt;, usato nello sviluppo di software per Mac OSX e iOS, si presta molto bene all&amp;rsquo;approccio basato sui tipi illustrato in questo articolo, a causa di due particolari caratteristiche del linguaggio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Type_system#Static_type-checking&#34;&gt;staticamente tipizzato&lt;/a&gt;, cioè ogni parametro, costante o variabile che sia, è caratterizzato da uno specifico tipo, e se una funzione vuole in ingresso un valore di un certo tipo, chiamare la funzione con un valore di un altro tipo risulterà in un errore di compilazione;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Strong_and_weak_typing&#34;&gt;fortemente tipizzato&lt;/a&gt;, cioè non esiste alcuna conversione implicita tra i tipi: ad esempio, in Swift &lt;code&gt;1&lt;/code&gt; è diverso da &lt;code&gt;true&lt;/code&gt; e i due valori non posso essere usati indifferentemente nello stesso contesto;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift è molto rigido, ma è in tale rigore che risiede la sua potenza: usare tipi errati provoca un errore di compilazione, e manipolando adeguatamente i tipi di dato nella costruzione di funzioni è possibile verificare gran parte della correttezza del proprio codice già nella fase di compilazione, evitando potenziali problemi in fase di esecuzione.&lt;/p&gt;

&lt;p&gt;Swift usa molti termini ereditati da C, come &lt;code&gt;struct&lt;/code&gt; e &lt;code&gt;enum&lt;/code&gt;, ma il loro significato è completamente diverso, ad esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;una &lt;code&gt;struct&lt;/code&gt; in Swift può dichiarare metodi ed essere estesa con interfacce;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enum&lt;/code&gt; in Swift è ciò che in altri linguaggi è spesso chiamato &amp;ldquo;sum type&amp;rdquo; o &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Tagged_union&#34;&gt;tagged union&lt;/a&gt;&amp;rdquo;, e a ogni &lt;code&gt;case&lt;/code&gt; possono essere assegnati dei valori associati, ad esempio &lt;code&gt;case Text(String)&lt;/code&gt; rappresenta il caso &lt;code&gt;Text&lt;/code&gt; e ha un valore &lt;code&gt;String&lt;/code&gt; associato.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per illustrare un modo per applicare l&amp;rsquo;approccio &lt;em&gt;Type First&lt;/em&gt; nello sviluppo in Swift inizieremo a scrivere una libreria per gestire &lt;strong&gt;form&lt;/strong&gt;, quindi liste strutturate di campi valorizzati, utili per raccogliere dati degli utenti tramite moduli da compilare, per effettuare sondaggi o inserire i parametri di query a un server.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;costruiamo-un-form-il-tipo-field&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;costruiamo-un-form-il-tipo-field:9546cc279181b22e90a8ccdde798a866&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Un possibile tipo di dato da cui partire è &lt;strong&gt;Field&lt;/strong&gt;, il campo, cioè il mattone costruttivo di base di un form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: String
    let name: String
    let value: String
    let visible: Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Questa definizione di Field è molto basilare, il ché non è un problema nelle prime fasi dello sviluppo, ma &lt;strong&gt;sembra poco estendibile&lt;/strong&gt;, per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; è definito come &lt;code&gt;String&lt;/code&gt; - ad esempio testo inserito dall&amp;rsquo;utente - ma un campo potrebbe contenere altri tipi di valori, ad esempio un checkbox si/no, oppure un preciso valore selezionato da una lista;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;visibile&lt;/code&gt; è definito come &lt;code&gt;Bool&lt;/code&gt;, e vuole indicare se il campo è visibile oppure nascosto, ma se volessimo assegnare altri valori di visibilità, ad esempio &amp;ldquo;evidenziato&amp;rdquo; o &amp;ldquo;oscurato&amp;rdquo; dovremmo aggiungere altri parametri &lt;code&gt;Bool&lt;/code&gt;, che alla fine potrebbero andare in contrasto l&amp;rsquo;uno con l&amp;rsquo;altro;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo risolvere immediatamente il problema, &lt;strong&gt;senza cadere nell&amp;rsquo;eccessiva ottimizzazione preventiva&lt;/strong&gt;, semplicemente modificando il tipo di &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visible&lt;/code&gt; con degli &lt;code&gt;enum&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum FieldValue: Equatable {
    case Text(String)
    case Empty
}

func == (lhs: FieldValue, rhs: FieldValue) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Empty, .Empty):
        return true
    case (.Text(let lhsText), .Text(let rhsText)):
        return lhsText == rhsText
    default:
        return false
    }
}

enum FieldVisibility: Equatable {
    case Visible
    case Hidden
}

func == (lhs: FieldVisibility, rhs: FieldVisibility) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Visible, .Visible), (.Hidden, .Hidden):
        return true
    default:
        return false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo fatto adottare il protocollo &lt;code&gt;Equatable&lt;/code&gt; a entrambi i tipi, in modo da poter confrontare &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visibility&lt;/code&gt; di due campi per verificare se sono uguali: il vantaggio degli &lt;code&gt;enum&lt;/code&gt; è che &lt;strong&gt;possiamo facilmente aggiungere nuovi casi&lt;/strong&gt; senza rompere il codice esistente, ci basterà gestire i nuovi &lt;code&gt;case&lt;/code&gt; via via che vengono aggiunti.&lt;/p&gt;

&lt;p&gt;Un&amp;rsquo;altra piccola modifica utile corrisponde a ridefinire il tipo del parametro &lt;code&gt;id&lt;/code&gt;: a tale parametro deve essere assegnata &lt;strong&gt;una chiave univoca&lt;/strong&gt;, diversa per ogni campo, quindi può convenire definire un tipo &lt;code&gt;UniqueKey&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias UniqueKey = String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift, la keyword &lt;code&gt;typealias&lt;/code&gt; ci permette di definire un &lt;em&gt;alias&lt;/em&gt; di un tipo, cioè un termine che corrisponde esattamente a quel tipo, e permette di:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;migliorare la leggibilità&lt;/strong&gt;, la chiarezza e la compattezza del codice;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;facilitare la manipolazione dei tipi&lt;/strong&gt;, come vedremo a breve;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ogni volta in cui una funzione richiederà &lt;code&gt;UniqueKey&lt;/code&gt; sapremo che in quel campo sarà necessario inserire una stringa univoca, che identifica un particolare campo.&lt;/p&gt;

&lt;p&gt;Definiamo nuovamente &lt;code&gt;Field&lt;/code&gt; incorporando i nuovi tipi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: UniqueKey    
    let name: String
    let value: FieldValue
    let visibility: FieldVisibility
    init (_ id: Key, _ name: String, _ value: FieldValue, _ visibility: FieldVisibility) {
        self.id = id
        self.name = name
        self.value = value
        self.visibility = visibility
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo aggiunto anche un costruttore di convenienza che ci permetterà di creare un &lt;code&gt;Field&lt;/code&gt; semplicemente passando i 4 dati richiesti.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/h2&gt;

&lt;p&gt;La prima e più semplice operazione che vogliamo poter effettuare su &lt;code&gt;Field&lt;/code&gt; è quella di modificarlo in qualche modo: ogni operazione di questo tipo, in Swift, può essere indicata con &lt;code&gt;Field -&amp;gt; Field&lt;/code&gt;, cioè una trasformazione che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e produce un &lt;code&gt;Field&lt;/code&gt; in uscita:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChange = Field -&amp;gt; Field
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;operatore &lt;code&gt;-&amp;gt;&lt;/code&gt; ha lo stesso significato che ha già in &lt;a href=&#34;http://en.wikipedia.org/wiki/Haskell_(programming_language&#34;&gt;Haskell&lt;/a&gt;): definisce il tipo di una funzione che prende in ingresso un dato del tipo indicato a sinistra dell&amp;rsquo;operatore, e ritorna un dato del tipo indicato a destra dell&amp;rsquo;operatore (in questo caso entrambi i dati sono di tipo &lt;code&gt;Field&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;È da evidenziare che &lt;code&gt;FieldChange&lt;/code&gt; non rappresenta un tipo di &amp;ldquo;dato&amp;rdquo; in senso stretto, ma &lt;strong&gt;un tipo di &amp;ldquo;funzione&lt;/strong&gt;&amp;ldquo;: in effetti, definendo &lt;code&gt;FieldChange&lt;/code&gt;, possiamo trattare le funzioni di quel tipo come se fossero dati.&lt;/p&gt;

&lt;p&gt;Per fare un esempio potremmo definire la funzione &lt;code&gt;setVisibility&lt;/code&gt;, che prende in ingresso un valore di &lt;code&gt;FieldVisibility&lt;/code&gt; e ritorna, appunto, un &lt;code&gt;FieldChange&lt;/code&gt;, cioè un&amp;rsquo;altra funzione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibility (visibility: FieldVisibility) -&amp;gt; FieldChange {
    return { field in
        return Field (
            field.id,
            field.name,
            field.value,
            visibility
        )
    }
}

/// alcuni esempi
let setHidden = setVisibility(.Hidden)
let visibleField1 = Field (&amp;quot;&amp;quot;,&amp;quot;&amp;quot;, .Empty, .Visible)
let isTrue1 = visibleField1.visibility == .Visible
let hiddenField1 = setHidden(visibleField1)
let isTrue2 = hiddenField1.visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Negli esempi mostrati, &lt;code&gt;setHidden&lt;/code&gt; è una funzione ma dal punto di vista sintattico è indistinguibile da un qualsiasi altro valore, e il suo tipo (cioè &lt;code&gt;FieldChange&lt;/code&gt;) è dedotto dal compilatore di Swift in base alla definizione della funzione.&lt;/p&gt;

&lt;p&gt;Una funzionalità che vogliamo certamente introdurre nella libreria corrisponde al poter operare una trasformazione su un campo in base a un qualche parametro definito in un altro campo: ad esempio, un particolare campo mostra un check che permette di mostrare/nascondere altri campi. Definiamo quindi un nuovo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChangeGenerator = Field -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è il tipo di una funzione dalla quale otteniamo, in base allo stato un certo campo origine, una certa trasformazione di tipo &lt;code&gt;FieldChange&lt;/code&gt;, cioè qualcosa che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e ritorna un &lt;code&gt;Field&lt;/code&gt; in uscita: si tratta quindi di una funzione che ritorna un&amp;rsquo;altra funzione, di tipo diverso. Vorremmo ad esempio poter scrivere una funzione del tipo &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, che imposta un valore di visibilità in base allo stato di un campo origine: ok, ma quale valore di visibilità? Dipende dal campo origine, e possiamo risolvere il problema definendo un nuovo tipo di funzione, che prende in ingresso un campo, e ritorna un valore di visibilità:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition = Field -&amp;gt; FieldVisibility
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La nostra funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt; semplicemente prenderà ingresso un dato di tipo &lt;code&gt;FieldCondition&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition) -&amp;gt; FieldChangeGenerator {
    return { origin in
        let newVisibility = condition(origin)
        return setVisibility(newVisibility)
    }
}

/// alcuni esempi

let setVisibleIfNotEmpty = setVisibilityIfOrigin { field in
    switch field.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
}

let nonEmptyField = Field (&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, .Text(&amp;quot;something&amp;quot;), .Visible)

let anotherVisibleField = setVisibleIfNotEmpty(nonEmptyField)(invisibleField)

let isTrue3 = anotherVisibleField.visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;funzioni-generiche-e-composizione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;funzioni-generiche-e-composizione-funzionale:9546cc279181b22e90a8ccdde798a866&#34;&gt;Funzioni generiche e composizione funzionale&lt;/h2&gt;

&lt;p&gt;In realtà la nostra &lt;code&gt;FieldCondition&lt;/code&gt; sembra essere un po&amp;rsquo; limitata: ritorna un valore di &lt;code&gt;FieldVisibility&lt;/code&gt;, mentre una vera &lt;em&gt;condition&lt;/em&gt; &lt;strong&gt;dovrebbe ritornare un valore generico&lt;/strong&gt;, a seconda dei casi: ad esempio, potrebbe cambiare il &lt;strong&gt;valore&lt;/strong&gt; di un campo bersaglio in base allo stato di un campo origine. L&amp;rsquo;ideale sarebbe scrivere qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition&amp;lt;T&amp;gt; = Field -&amp;gt; T
/// errore di compilazione!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sfortunatamente in Swift non è possibile scrivere dei &lt;code&gt;typealias&lt;/code&gt; generici, ma possiamo facilmente aggirare l&amp;rsquo;ostacolo costruendo una &lt;code&gt;struct&lt;/code&gt; generica che contiene un solo parametro, al quale è assegnata una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct FieldCondition&amp;lt;T&amp;gt; {
    let apply: Field -&amp;gt; T
    init(_ apply: Field -&amp;gt; T) {
        self.apply = apply
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se prima abbiamo scritto semplicemente una funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, l&amp;rsquo;idea è riuscire ora a scrivere &lt;strong&gt;una funzione generica&lt;/strong&gt; &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; che ritorna un &lt;code&gt;FieldChangeGenerator&lt;/code&gt; che trasforma un campo bersaglio rispetto a un certo parametro, definito in base allo stato di un campo origine: come scrivere questa funzione? &lt;strong&gt;Ragioniamo sui tipi&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FieldCondition&amp;lt;T&amp;gt;&lt;/code&gt; è un contenitore per una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è un alias per &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;per completare la catena abbiamo bisogno di una trasformazione del tipo &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; perché unendo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt; e &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; otteniamo appunto &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo scrivere quindi la funzione generica di cui sopra:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setTargetIfOrigin&amp;lt;T&amp;gt; (condition: FieldCondition&amp;lt;T&amp;gt;, generate: T -&amp;gt; FieldChange) -&amp;gt; FieldChangeGenerator {
    return { field in
        return generate(condition.apply(field))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se tutto sembra molto astratto è perché &lt;strong&gt;lo è&lt;/strong&gt;: stiamo gradualmente costruendo degli strumenti di manipolazione dei dati (e delle funzioni, che sono anch&amp;rsquo;esse dati) operando su astrazioni successive.&lt;/p&gt;

&lt;p&gt;Nella funzione &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; c&amp;rsquo;è un parametro &lt;code&gt;generate&lt;/code&gt; che è definito come &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt;: cosa è &lt;code&gt;T&lt;/code&gt;? È semplicemente lo stesso tipo di dato con il quale viene passata la condizione in &lt;code&gt;condition&lt;/code&gt;; se passiamo una condizione sulla visibilità, ad esempio, &lt;code&gt;T&lt;/code&gt; sarà &lt;code&gt;FieldVisibility&lt;/code&gt;: &lt;strong&gt;una funzione generica si specializza nel momento in cui è definito il tipo concreto da assegnare ai tipi generici&lt;/strong&gt;. Volendo fare un esempio concreto, possiamo ridefinire la funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition&amp;lt;FieldVisibility&amp;gt;) -&amp;gt; FieldChangeGenerator {
    return setTargetIfOrigin (condition) { visibility in setVisibility(visibility) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione chiama &lt;code&gt;setTargetIfOrigin&lt;/code&gt;, passando una condizione del tipo &lt;code&gt;FieldCondition&amp;lt;FieldVisibility&amp;gt;&lt;/code&gt;: il secondo parametro dovrà essere quindi una funzione del tipo &lt;code&gt;FieldVisibility -&amp;gt; FieldChange&lt;/code&gt;, e possiamo usare la funzione &lt;code&gt;setVisibility&lt;/code&gt; definita prima. Vediamo qualche altro esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let setVisibleIfNotEmpty = setVisibilityIfOrigin (FieldCondition { origin in
    switch origin.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
})

let copyValue = setTargetIfOrigin (FieldCondition { $0.value}) { value in
    return { target in
        return Field(target.id,target.name,value,target.visibility)
    }
}

let field1 = Field(&amp;quot;field1&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;1&amp;quot;),.Visible)
let field2 = Field(&amp;quot;field2&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;2&amp;quot;),.Visible)

let newField1 = copyValue(field2)(field1)

let isTrue4 = newField1.value == .Text(&amp;quot;2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Può essere interessante spendere qualche parola per la funzione &lt;code&gt;copyValue&lt;/code&gt; definita nell&amp;rsquo;esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la condizione è chiaramente del tipo &lt;code&gt;FieldCondition&amp;lt;FieldValue&amp;gt;&lt;/code&gt; perché la &lt;em&gt;closure&lt;/em&gt; passata ritorna il &lt;code&gt;value&lt;/code&gt; del campo;&lt;/li&gt;
&lt;li&gt;nella seconda &lt;em&gt;closure&lt;/em&gt; passata, il valore è usato per costruire un nuovo campo, uguale al bersaglio tranne proprio per quel valore;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quindi &lt;code&gt;copyValue&lt;/code&gt;, che ricordiamo è di tipo &lt;code&gt;FieldChangeGenerator&lt;/code&gt;, è una trasformazione che prende il valore di un campo origine e lo assegna a un campo bersaglio.&lt;/p&gt;

&lt;p&gt;Nel caso in cui avessimo una serie di campi e volessimo applicare una certa trasformazione a un solo campo particolare, avremmo bisogno di un check sul campo bersaglio. Come al solito, pensiamo prima al &lt;strong&gt;tipo&lt;/strong&gt; di questo check: sarà qualcosa che prende un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un altro &lt;code&gt;FieldChange&lt;/code&gt;, che potrebbe essere uguale a quello in ingresso, oppure diverso in base a una certa condizione applicata al campo bersaglio.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCheck = FieldChange -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per quanto riguarda la condizione, possiamo usare lo stesso FieldCondition&lt;T&gt; di prima, ma in questo caso lo specializzeremo direttamente in &lt;code&gt;FieldCondition&amp;lt;Bool&amp;gt;&lt;/code&gt; perché quello che ci interessa sapere è se un certo campo bersaglio è interessato oppure no da una certa trasformazione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldConditionBool = FieldCondition&amp;lt;Bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Definiamo quindi una funzione &lt;code&gt;checkTarget&lt;/code&gt; che prende in ingresso una condizione, e ritorna un &lt;code&gt;FieldCheck&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func checkTarget (condition: FieldConditionBool) -&amp;gt; FieldCheck {
    return { change in
        return { field in
            if condition.apply(field) {
                return change(field)
            }
            else {
                return field
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nel definire &lt;code&gt;checkTarget&lt;/code&gt; possiamo vedere un altro caso in cui ragionare solo sui tipi ci aiuta a capire cosa poi dobbiamo effettivamente fare nel codice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la funzione deve ritornare un dato di tipo &lt;code&gt;FieldCheck&lt;/code&gt;, che è una funzione che prende in ingresso un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, quindi la prima riga della funzione è appunto &lt;code&gt;return { change in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldCheck&lt;/code&gt; è una funzione che ritorna un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, che come definito prima corrisponde a una funzione che prende in ingresso un &lt;code&gt;Field&lt;/code&gt;, quindi la seconda riga è &lt;code&gt;return { field in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChange&lt;/code&gt; deve ritornare un &lt;code&gt;Field&lt;/code&gt;, ma a questo punto possiamo applicare la nostra condizione sul campo in ingresso: se la condizione è verificata allora ritorniamo il campo trasformato, mentre se non lo è &amp;ldquo;facciamo uscire&amp;rdquo; il campo esattamente come è &amp;ldquo;entrato&amp;rdquo;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Come si può vedere, abbiamo iniziato a implementare funzioni ragionando quasi esclusivamente sui tipi coinvolti. Vediamo alcuni esempi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ifTargetId (id: UniqueKey) -&amp;gt; FieldCheck {
    return checkTarget (FieldCondition { $0.id == id })
}

let visibleField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field1)
let hiddenField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field2)

let isTrue5 = visibleField.visibility == .Visible
let isTrue6 = hiddenField.visibility == .Hidden

let fields = [field1,field2]
let newFields = fields.map(ifTargetId(&amp;quot;field2&amp;quot;)(setHidden))

let isTrue7 = newFields[0].visibility == .Visible
let isTrue8 = newFields[1].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;il-tipo-form&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-tipo-form:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Abbiamo implementato quindi alcuni strumenti per manipolare i singoli campi: a questo punto proviamo a unire il tutto definendo un &lt;code&gt;Form&lt;/code&gt; come contenitore strutturato di campi, insieme ad alcune funzioni di manipolazione. Intanto &lt;strong&gt;pensiamo al tipo da assegnare al nostro form&lt;/strong&gt;: una possibilità è quella di definire alcuni blocchi costruttivi che ne descrivono la struttura:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// sezione: è una semplice lista di campi
struct Section {
    let fields: [Field]
}

/// step: un gruppo di sezioni, ad esempio una pagina
struct Step {
    let sections: [Section]
}

/// form: un insieme di pagine
struct Form {
    let steps: [Step]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ci sono però due problemi con questo approccio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stiamo prematuramente fornendo al nostro form &lt;strong&gt;una struttura rigida&lt;/strong&gt;: se in futuro decidessimo di voler creare una sottostruttura rispetto a &lt;code&gt;Section&lt;/code&gt; sarebbe probabilmente molto complesso modificare il tutto;&lt;/li&gt;
&lt;li&gt;nello scrivere le logiche di ricerca e manipolazione dei campi ci ritroveremmo a dover gestire le &lt;code&gt;struct&lt;/code&gt; appena definite: stiamo quindi automaticamente &lt;strong&gt;accoppiando&lt;/strong&gt; un particolare modello di dati con la logica di manipolazione dei form, che &lt;strong&gt;dovrebbero essere adattabili a più modelli, senza cambiare la logica&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per evitare questi problemi gli approcci possibili sono molti: un&amp;rsquo;opzione, ad esempio, è quella definire un tipo di dato corrispondente a un contenitore &lt;em&gt;ricorsivo&lt;/em&gt; per un valore generico, che chiameremo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Un valore di tipo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; definisce due casi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;branch&lt;/em&gt;, cioè una lista di valori di tipo T;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;root&lt;/em&gt;, cioè una lista di altri &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;enum Node&amp;lt;T&amp;gt; {
    case Branch([T])
    case Root([Node&amp;lt;T&amp;gt;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possiamo quindi definire un &lt;code&gt;Form&lt;/code&gt; come una versione specializzata di &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; dove &lt;code&gt;T&lt;/code&gt; è &lt;code&gt;Field&lt;/code&gt;, e definiremo un paio di funzioni di convenienza per generare un &lt;em&gt;branch&lt;/em&gt; di &lt;code&gt;Field&lt;/code&gt; o una &lt;em&gt;root&lt;/em&gt; di &lt;code&gt;Form&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias Form = Node&amp;lt;Field&amp;gt;

func branch (fields: [Field]) -&amp;gt; Form {
    return Node.Branch(fields)
}

func root (nodes: [Form]) -&amp;gt; Form {
    return Node.Root(nodes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modifica-di-un-form-e-ricerca-di-un-campo:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modifica di un form e ricerca di un campo&lt;/h2&gt;

&lt;p&gt;Come accadeva per &lt;code&gt;Field&lt;/code&gt;, la prima operazione che vogliamo poter effettuare su &lt;code&gt;Form&lt;/code&gt; è quella modificarlo; definiamo quindi il tipo &lt;code&gt;FormChange&lt;/code&gt; in maniera a simile a come avevamo definito &lt;code&gt;FieldChange&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FormChange = Form -&amp;gt; Form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supponiamo ad esempio di avere un form, e voler applicare una modifica a un campo presente nel form, ottenendo un nuovo form con il campo modificato: abbiamo bisogno di una funzione che potremmo chiamare &lt;code&gt;changeFromFieldChange&lt;/code&gt; che prende in ingresso un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un &lt;code&gt;FormChange&lt;/code&gt;; grazie alla struttura ricorsiva del tipo &lt;code&gt;Form&lt;/code&gt; definito, possiamo scrivere in poche righe una funzione che attraversa un form nei suoi vari livelli e lo ricostruisce applicando la modifica passata in ingresso a ogni campo, tenendo eventualmente conto di una certa condizione per verificare se un certo campo è interessato dalla modifica o meno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeFromFieldChange (fieldChange: FieldChange) -&amp;gt; FormChange {
    return { form in
        switch form {
        case .Branch (let fields):
            return branch(fields.map(fieldChange))
        case .Root (let subforms):
            return root(subforms.map(changeFromFieldChange(fieldChange)))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione verifica se un form è del tipo &lt;code&gt;.Branch&lt;/code&gt; o &lt;code&gt;.Root&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nel primo caso, ricostruisce il &lt;em&gt;branch&lt;/em&gt; applicando la funzione &lt;code&gt;FieldChange&lt;/code&gt; in ingresso a ogni campo nel &lt;em&gt;branch&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;nel secondo caso, ricostruisce il &lt;em&gt;root&lt;/em&gt; applicando ricorsivamente la stessa funzione &lt;code&gt;changeFromFieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per migliorare la leggibilità possiamo definire una nuova funzione &lt;code&gt;updateField&lt;/code&gt; identica a &lt;code&gt;changeFromFieldChange&lt;/code&gt; che dichiara &lt;strong&gt;in maniera più espressiva&lt;/strong&gt; il tipo di operazione che vogliamo poter effettuare su un form, e cioè aggiornare un certo campo in base a una certa trasformazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let updateField = changeFromFieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vediamo quindi un esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let form = branch([field1,field2])

let newForm = updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere dall&amp;rsquo;esempio, otteniamo &lt;code&gt;newForm&lt;/code&gt; componendo alcune funzioni definite in precedenza con &lt;code&gt;updateField&lt;/code&gt;: se l&amp;rsquo;id del campo bersaglio è &amp;ldquo;field1&amp;rdquo;, nascondiamo il campo.&lt;/p&gt;

&lt;p&gt;Come verificare se il campo con id &amp;ldquo;field1&amp;rdquo; è effettivamente nascosto? Come ultima operazione vogliamo definire una funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; che ci permetta di cercare uno o più campi in un form in base a una certa condizione: la condizione sarà ancora di tipo &lt;code&gt;FieldConditionBool&lt;/code&gt;, cioè da un campo otteniamo un valore &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt;. Per scrivere la funzione ragioniamo sul tipo di dato ritornato: esso deve corrispondere a una funzione che prende un form e ritorna un array di campi; chiameremo questo tipo &lt;code&gt;FieldGet&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldGet = Form -&amp;gt; [Field]

func fieldsWithCondition (condition: FieldConditionBool) -&amp;gt; FieldGet {
    return { form in
        switch form {
        case .Branch(let fields):
            return fields.filter(condition.apply)
        case .Root(let subforms):
            return subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; opera ricorsivamente, come è ovvio che sia considerando la natura ricorsiva del tipo di dato &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Vediamo qualche applicazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fieldsWithId (id: UniqueKey) -&amp;gt; FieldGet {
    return fieldsWithCondition (FieldConditionBool { $0.id == id })
}

let allFields: FieldGet = fieldsWithCondition (FieldConditionBool { _ in true })

let twoFields = allFields(form)

let isTrue9 = count(twoFields) == 2

let isTrue10 = fieldsWithId(&amp;quot;field1&amp;quot;)(form)[0].visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithId&lt;/code&gt; prende una &lt;code&gt;UniqueKey&lt;/code&gt; e permette di ottenere tutti i campi con quell&amp;rsquo;id (presumibilmente l&amp;rsquo;array risultante conterrà un solo elemento); &lt;code&gt;allFields&lt;/code&gt; genera semplicemente un array con tutti i campi: da notare che la &lt;em&gt;closure&lt;/em&gt; &lt;code&gt;{ _ in true }&lt;/code&gt; ignora il valore in ingresso e ritorna sempre &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Usando &lt;code&gt;fieldsWithId&lt;/code&gt; possiamo infine verificare che il campo con id &amp;ldquo;field1&amp;rdquo; sia effettivamente nascosto, in base alle manipolazioni precedenti:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isTrue11 = fieldsWithId(&amp;quot;field1&amp;quot;)(newForm)[0].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;conclusione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusione:9546cc279181b22e90a8ccdde798a866&#34;&gt;Conclusione&lt;/h2&gt;

&lt;p&gt;Per concludere, abbiamo visto come partendo da &lt;strong&gt;tipi&lt;/strong&gt;, che siano essi relativi a singoli valori o a funzioni, è stato possibile iniziare a scrivere una libreria composta da semplici tipi di base e funzioni elementari che vengono composte via via a livelli di astrazione più alti. Definendo tipi specifici per molte astrazioni siamo riusciti a &lt;strong&gt;gestire meglio la complessità&lt;/strong&gt; inerente nel manipolare e comporre funzioni, al punto da poter &lt;strong&gt;trattare funzioni complesse come semplici dati&lt;/strong&gt; da passare ad altre funzioni. In un articolo successivo vedremo come estendere la libreria qui iniziata, abbracciando completamente la composizione funzionale e usando operatori specificamente definiti per migliorare la chiarezza del codice e rendere più semplice la manipolazione e combinazione delle funzioni.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;Nello scrivere questo articolo si è scelto specificamente di non definire operatori su misura per comporre le funzioni, per evitare un ulteriore appesantimento legato alla presenza di codice dalla sintassi poco familiare. La chiamata di una funzione in Swift è c-like: si scrive il nome della funzione e poi si inseriscono i dati di ingresso tra due parentesi tonde; questo purtroppo può portare a diverse chiamate in parentesi annidate; inoltre, può non risultar chiara una chiamata del tipo &lt;code&gt;updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)&lt;/code&gt;: come accennato, in un articolo futuro vedremo come usare operatori personalizzati per rendere il tutto più semplice e leggibile.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;La chiamata &lt;code&gt;subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)&lt;/code&gt;, nella funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt;, è piuttosto inefficiente dal punto di vista della performance: l&amp;rsquo;inefficienza è dovuta al fatto che a ogni chiamata vengono generati array intermedi dovuti alle varie mappature dei dati; non è in realtà necessario creare questi array intermedi: basta utilizzare procedure &amp;ldquo;lazy&amp;rdquo;, che vedremo in un articolo futuro.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;riferimenti:9546cc279181b22e90a8ccdde798a866&#34;&gt;Riferimenti&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tomas Petricek - &lt;a href=&#34;http://tomasp.net/blog/type-first-development.aspx&#34;&gt;Why type-first development matters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Michael Feathers - &lt;a href=&#34;http://www.infoq.com/presentations/Type-Functional-Design&#34;&gt;A Type Driven Approach to Functional Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Johannes Weiß - &lt;a href=&#34;https://speakerdeck.com/johannesweiss/type-driven-development-in-swift&#34;&gt;Type Driven Development in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Luca Cardelli - &lt;a href=&#34;http://www.lucacardelli.name/Papers/TypefulProg.pdf&#34;&gt;Typeful Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il codice mostrato nell&amp;rsquo;articolo è disponibile su &lt;a href=&#34;https://gist.github.com/broomburgo/ba8e5dd6cd509fdfd781&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Un flusso di lavoro agile</title>
      <link>/blog/ita/un-flusso-di-lavoro-agile/</link>
      <pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/un-flusso-di-lavoro-agile/</guid>
      <description>

&lt;p&gt;Parlare di &lt;strong&gt;metodologie di lavoro&lt;/strong&gt; in azienda è una cosa piuttosto complessa, soprattutto perché non è possibile generalizzare un modo di lavoro che sia universalmente valido. Sento sempre più persone dire &amp;ldquo;con &lt;a href=&#34;http://it.wikipedia.org/wiki/Scrum_%28informatica%29&#34;&gt;SCRUM&lt;/a&gt; avrai risultati assicurati&amp;rdquo;. Lo trovo piuttosto riduttivo.&lt;/p&gt;

&lt;p&gt;In sostanza, sempre più persone hanno tradotto i &lt;a href=&#34;http://agilemanifesto.org/iso/it/&#34;&gt;valori&lt;/a&gt; ed i &lt;a href=&#34;http://agilemanifesto.org/iso/it/principles.html&#34;&gt;princìpi&lt;/a&gt; promossi dal manifesto agile in una serie di &amp;ldquo;ricette&amp;rdquo; pronte da seguire fedelmente per ottenere buoni risultati. Cosa c’è di &amp;ldquo;&lt;a href=&#34;http://it.wikipedia.org/wiki/Metodologia_agile&#34;&gt;agile&lt;/a&gt;&amp;rdquo; in tutto ciò? E’ come cucinare con un robot da cucina&amp;hellip;
Ecco perché sono sempre più convinto che la vera ricetta del successo nei progetti sia qualcosa che si scopre &amp;ldquo;assaggiando&amp;rdquo; gli ingredienti che mettiamo nella ricetta (andrò avanti con la metafora della cucina, siete avvisati!).&lt;/p&gt;

&lt;p&gt;Ad alcuni possono piacere le ricette semplici, come una bella grigliata. Come quei gruppi che apprezzano un manager molto presente, che dica a tutti cosa debbano fare, passo dopo passo. Qualcosa di &amp;ldquo;semplice&amp;rdquo; ma efficace.
Altri amano qualcosa di creativo, come una ricetta raffinata di un ristorante stellato. Un complesso artifizio di procedure di comunicazione per la gestione del lavoro. Penso ai gruppi che si coordinano da remoto con svariati tool. Li ammiro molto, io avrei difficoltà.
Infine, i gruppi che adorano il fast food. Quello sempre uguale ovunque tu sia, e che piace a quasi tutti i palati. Si perché, diciamocelo, piace a tutti. Come &lt;a href=&#34;http://it.wikipedia.org/wiki/Scrum_%28informatica%29&#34;&gt;SCRUM&lt;/a&gt;!
Quindi, uscendo dalla metafora, potremmo dire che &lt;a href=&#34;http://it.wikipedia.org/wiki/Scrum_%28informatica%29&#34;&gt;SCRUM&lt;/a&gt; è la ricetta perfetta perché piace a tutti (o quasi). Ma siamo sicuri che il famoso panino della nota catena americana sia anche il miglior modo di mangiare?&lt;/p&gt;

&lt;h3 id=&#34;imparare-dai-propri-errori:214cf69b6178c9bc5e93f15a08785e9d&#34;&gt;Imparare dai propri errori&lt;/h3&gt;

&lt;p&gt;Il nostro gruppo di lavoro, ad esempio, ha passato mesi cercando di applicare la ricetta di &lt;a href=&#34;http://it.wikipedia.org/wiki/Scrum_%28informatica%29&#34;&gt;SCRUM&lt;/a&gt;. Un mezzo disastro. Ci siamo chiesti dove stessimo sbagliando, finché non abbiamo definitivamente fatto indigestione. Piccoli o grandi conflitti interni al team ed una dose di stress altissima. Le nostre &lt;a href=&#34;http://en.wikipedia.org/wiki/Retrospective#Software_development&#34;&gt;retrospettive&lt;/a&gt; (retaggio dell’agile, non certo perché avessimo capito di cosa si trattasse veramente!) sembravano più sedute di terapia di gruppo, che momenti di condivisione e confronto. Col senno di poi siamo in grado di fare la lista delle cose che non andavano:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;il nostro cliente interno aveva &lt;strong&gt;bisogni che cambiavano&lt;/strong&gt; ad una velocità tale da vanificare qualsiasi iterazione pianificata. Questo generava grande frustrazione nel gruppo che sentiva di disattendere il valore dell’abbracciare il cambiamento;&lt;/li&gt;
&lt;li&gt;il gruppo aveva appena perso delle pedine storiche che avevano lasciato in eredità un software costruito su un &lt;strong&gt;dominio complesso&lt;/strong&gt;. Non c’era la seniority necessaria per fare delle stime attendibili. Ogni iterazione era un bagno di sangue &lt;strong&gt;contro il tempo&lt;/strong&gt;, a danno della qualità del codice o della vita dei programmatori che lavoravano troppo;&lt;/li&gt;
&lt;li&gt;non avevamo capito &lt;strong&gt;l’importanza dello SCRUM Master&lt;/strong&gt;, qualcuno che sappia proteggere i valori e le cerimonie di questa pratica. Passavamo da un’iterazione all’altra senza prenderci nemmeno il tempo di celebrare i successi. Fare i panini della nota catena, in casa, senza il particolare controllo qualità che la catena impone ai propri franchise è un esperimento fallito in partenza.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cambiare-ricetta:214cf69b6178c9bc5e93f15a08785e9d&#34;&gt;Cambiare ricetta&lt;/h3&gt;

&lt;p&gt;Penso che essere agili sia, in primo luogo, non lasciarsi intrappolare da preconcetti. Ecco perché un giorno ho riunito il team ed ho detto che non mi riconoscevo in quel modo di lavorare!
Abbiamo iniziato a pensare ad &lt;strong&gt;una ricetta diversa&lt;/strong&gt;, qualcosa che fosse più adatto al nostro palato. Guardando le caratteristiche del nostro gruppo e del contesto in cui lavoriamo abbiamo osservato che:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ogni giorno le &lt;strong&gt;priorità&lt;/strong&gt; sono potenzialmente rimesse in discussione;
vogliamo fare qualità e vogliamo che il progetto sia al passo con la tecnologia;&lt;/li&gt;
&lt;li&gt;abbiamo un team con una buona esperienza ma deve entrare nelle dinamiche di un &lt;strong&gt;dominio complesso&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;dobbiamo ancora scoprire &lt;strong&gt;la nostra velocity, che comunque cambierà&lt;/strong&gt; man mano che prendiamo confidenza col dominio. Insomma, la velocity non sarebbe un parametro utile per le stime;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;non possiamo rallentare&lt;/strong&gt; perché il cliente ha bisogno di noi;
abbiamo un elevato numero di bug;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il nostro gruppo è composto da &lt;strong&gt;5 programmatori ed un product specialist&lt;/strong&gt;, una persona che si occupa di tracciare i bisogni degli utenti, i bug e ci aiuta a far in modo che il prodotto sia bello e curato.
Ricevendo continue richieste, la prima cosa da fare è non perderne traccia. Abbiamo aperto un foglio di calcolo condiviso su Google Drive in cui scriviamo le storie che arrivano al product specialist, assegnamo un’etichetta che mostri al volo di cosa si tratti (frontend, fatture, bug, etc.) e facciamo una stima estremamente generica (è una storia piccola, epica, etc); di fatto si tratta del nostro &lt;strong&gt;backlog&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ogni inizio del mese facciamo una &lt;strong&gt;revisione del backlog&lt;/strong&gt; insieme al manager per capire se ci sono delle cose più prioritarie di altre e facciamo pulizia.
Uno dei capisaldi della nostra ricetta è la &lt;strong&gt;prioritizzazione continua&lt;/strong&gt;. Ingrediente di base, dunque, il &lt;a href=&#34;http://it.wikipedia.org/wiki/Kanban&#34;&gt;Kanban&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Abbiamo aperto una board su &lt;a href=&#34;http://www.trello.com&#34;&gt;Trello&lt;/a&gt; dove far evolvere &lt;strong&gt;le storie (i task)&lt;/strong&gt; da una colonna all’altra. Si parte dalla colonna &amp;ldquo;&lt;em&gt;prossime cose da fare&lt;/em&gt;&amp;rdquo;, che carichiamo man mano che si svuota, dal backlog o, molto più spesso, con le cose che scopriamo giorno dopo giorno parlando con il cliente (ecco la &lt;em&gt;prioritizzazione continua&lt;/em&gt;!). Esempio tipico: &amp;ldquo;se metteste anche quella statistica nella pagina dei report delle vendite avremmo più controllo su quel target di clienti&amp;rdquo;&amp;hellip; fatto!&lt;/p&gt;

&lt;p&gt;Ogni storia riporta l’etichetta già indicata nel backlog, così un programmatore ha il polso di quale sia il dominio legato alla storia. Un nuovo arrivato avrebbe più difficoltà a lavorare sul dominio della contabilità. E’ meglio che si concentri su altre storie, col tempo prenderà confidenza anche con quel mondo.&lt;/p&gt;

&lt;p&gt;Quando un programmatore è libero &lt;strong&gt;&amp;ldquo;adotta&amp;rdquo; una storia&lt;/strong&gt;, la porta nella colonna con le cose che stiamo facendo e ci appiccica il proprio avatar. Durante lo sviluppo si occupa di tutto: la raccolta delle informazioni, verifica i mockup, prepara la demo con il cliente, etc.
Quando ha finito ed è pronto a metterla in produzione la sposta nella colonna &amp;ldquo;&lt;em&gt;da provare in produzione&lt;/em&gt;&amp;rdquo;. Il task resta là finché un caso reale non ci permette di dire &amp;ldquo;funziona!&amp;rdquo;. A quel punto va nelle cose &amp;ldquo;&lt;em&gt;fatte&lt;/em&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;In tutte le storie cerchiamo di metterci quanta &lt;strong&gt;più qualità possibile&lt;/strong&gt;, facciamo i &lt;strong&gt;test funzionali ed unitari&lt;/strong&gt; e teniamo sotto controllo il nostro tool di &lt;strong&gt;continuous integration&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Le storie su &lt;strong&gt;nuovi domini&lt;/strong&gt; sono quelle più critiche, perché portano a fare molte nuove scelte di architettura. Io sono convinto che il &lt;strong&gt;&lt;a href=&#34;http://it.wikipedia.org/wiki/Pair_programming&#34;&gt;pair programming&lt;/a&gt;&lt;/strong&gt; non sia una tecnica per raddoppiare la velocità, piuttosto un modo per &lt;strong&gt;dimezzare la stupidità&lt;/strong&gt;! Si può sempre sbagliare, ma prendere una cantonata in due è raro. E’ più probabile che si faccia challenge a vicenda per le scelte importanti. Quindi in questi casi mettiamo insieme due programmatori e facciamo in modo che si confrontino.&lt;/p&gt;

&lt;p&gt;Se una storia stenta ad andare in &amp;ldquo;&lt;em&gt;fatto&lt;/em&gt;&amp;rdquo; siamo pronti a metterci anche in 2 o 3 pur di portare la storia a risultato, come ci insegna il &lt;a href=&#34;http://it.wikipedia.org/wiki/Kanban&#34;&gt;Kanban&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A rotazione (ruotiamo ogni 2 settimane), uno o più programmatori nel team ci aiutano a gestire uno dei problemi che rischiano di compromettere i nostri piani. Li chiamiamo i &lt;strong&gt;wallman&lt;/strong&gt;! Ci proteggono dalle &lt;strong&gt;continue interruzioni&lt;/strong&gt; che altrimenti il team subirebbe, per gestire i bug o le varie richieste che vengono dal cliente.
Nel tempo &amp;ldquo;libero&amp;rdquo; (per fortuna oggi è tanto!) fanno una cosa estremamente importante per la salute del progetto: il &lt;strong&gt;refactoring&lt;/strong&gt;! Il team, in pieno spirito &lt;a href=&#34;http://en.wikipedia.org/wiki/Lean_software_development&#34;&gt;Lean&lt;/a&gt;, rilascia tante feature sperimentali a grande velocità. Alcune di queste sono dei piccoli accrocchi su pezzi di codice preesistenti. Quando la prova del mercato ci da un feedback positivo, un wallman ci aiuta a ripulire il codice. In questo modo, il team può concentrarsi sul rilasciare tanto valore per il business, consapevole che qualcuno copre le spalle.&lt;/p&gt;

&lt;p&gt;Questa ricetta, come ogni grande ricetta, è una lenta e ragionata combinazione di ingredienti per soddisfare il nostro gusto. &lt;strong&gt;A noi piace!&lt;/strong&gt; Non è detto che vada bene con tutti, ma sicuramente rispetta i valori fondamentali di collaborazione, creazione del valore e rispetto che sono propri del manifesto agile.&lt;/p&gt;

&lt;h3 id=&#34;la-ricetta-ideale:214cf69b6178c9bc5e93f15a08785e9d&#34;&gt;La ricetta ideale&lt;/h3&gt;

&lt;p&gt;Un po&amp;rsquo; come nella cucina, dove ogni buona ricetta ha una parte dolce ed una nota acida, ogni combinazione di pratiche agili deve rispettare i princìpi fondamentali. Calateli nella vostra realtà! Tutto si migliora confrantandosi, facendo &lt;a href=&#34;http://en.wikipedia.org/wiki/Retrospective#Software_development&#34;&gt;retrospettive&lt;/a&gt;. Alla fine arriva la giusta combinazione che vi farà dimenticare il fast food. E’ decisamente più gustoso un bel panino artigianale!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduzione al tracciamento di eventi lato server</title>
      <link>/blog/ita/tracciamento-di-eventi-lato-server/</link>
      <pubDate>Tue, 21 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/tracciamento-di-eventi-lato-server/</guid>
      <description>

&lt;p&gt;L’adozione di strategie &lt;em&gt;DevOps&lt;/em&gt; ha portato negli ultimi anni ad incrementare le aree coperte da &lt;strong&gt;tool di monitoring&lt;/strong&gt; in maniera tale da avere un feedback in tempo reale dello stato dell’infrastruttura su cui si basa la propria applicazione, così da poter rispondere pro-attivamente a situazioni critiche. Su tale fronte infatti si sono visti comparire i tool più disparati che permettono la raccolta di informazioni, sia dei &lt;strong&gt;server&lt;/strong&gt; o delle istanze su cui vengono eseguite le applicazioni (ad esempio CPU, memoria o disco), che le &lt;strong&gt;applicazioni&lt;/strong&gt; stesse (ad esempio tempi medi di risposta, numero di query eseguite, tempo di esecuzione delle query, ecc. ecc.).&lt;/p&gt;

&lt;p&gt;Per entrambi i casi lo sviluppatore ha a disposizione sia soluzioni &lt;strong&gt;open source&lt;/strong&gt; che soluzioni &lt;strong&gt;SaaS&lt;/strong&gt;: la differenza sostanziale, a parità di feature principali, rimane la gestione dell’infrastruttura aggiuntiva, necessaria a supportare le operazioni per la raccolta dei dati inviati dai sensori predisposti a monitorare le metriche che interessano. Nonostante gli strumenti si facciano sempre più abbondanti (basti pensare a tutte le soluzioni recenti per il salvataggio di time series) e user-friendly, volersi affidare a provider terzi può essere un modo per concentrarsi maggiormente sul valore aggiunto che si vuole dare all’utente finale con la propria applicazione, senza doversi preoccupare di questioni di contorno.&lt;/p&gt;

&lt;p&gt;Tra i principali prodotti SaaS presenti sul mercato troviamo &lt;em&gt;&lt;a href=&#34;http://newrelic.com/&#34;&gt;NewRelic&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&#34;http://www.appdynamics.com/&#34;&gt;AppDynamics&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&#34;https://www.serverdensity.com&#34;&gt;ServerDensity&lt;/a&gt;&lt;/em&gt; e &lt;em&gt;&lt;a href=&#34;https://www.ruxit.com&#34;&gt;Ruxit&lt;/a&gt;&lt;/em&gt;, ciascuno con i propri prezzi e le proprie peculiarità, ma tutti che permettono di avere un costante monitoraggio della propria applicazione, dal browser dell’utente fino alla query per salvare i dati, gratis o con costi mensili contenuti e proporzionali alla dimensione della propria infrastruttura.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;Facile.it&lt;/strong&gt; viene utilizzato &lt;strong&gt;NewRelic&lt;/strong&gt; non solo per il monitoraggio base dei servizi che compongono il sito ma, grazie a &lt;strong&gt;NewRelic Insights&lt;/strong&gt;, perché viene data la possibilità di salvare eventi personalizzati che possono dare maggiori informazioni sia agli sviluppatori che ai business analysts. Per poter accedere a &lt;strong&gt;NewRelic Insights&lt;/strong&gt; bisogna avere un account a pagamento, ma è comunque possibile sperimentare l’eventuale utilità per le proprie esigenze grazie al periodo di prova di 14 giorni.&lt;/p&gt;

&lt;p&gt;La raccolta dei dati può avvenire in due modi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tramite &lt;strong&gt;&lt;em&gt;custom attributes&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;tramite &lt;strong&gt;&lt;em&gt;eventi personalizzati&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;custom-attributes:0fc835fee623e5d493f15e3070958a9c&#34;&gt;Custom Attributes&lt;/h4&gt;

&lt;p&gt;I &lt;em&gt;custom attributes&lt;/em&gt; sono delle coppie di chiave-valore da aggiungere alla transazione corrente (Web e Non-Web) già tracciata dagli strumenti di &lt;em&gt;NewRelic&lt;/em&gt; per i principali linguaggi di programmazione (&lt;strong&gt;PHP&lt;/strong&gt;, &lt;strong&gt;NodeJs&lt;/strong&gt;, &lt;strong&gt;Ruby&lt;/strong&gt;, &lt;strong&gt;Python&lt;/strong&gt;, &lt;em&gt;Java&lt;/em&gt;, &lt;em&gt;.NET&lt;/em&gt;). Possiamo aggiungere ad esempio l’utente attualmente collegato che sta effettuando tale transazione, il numero di oggetti presenti nel carrello o ancora il loro valore.&lt;/p&gt;

&lt;p&gt;Ad esempio, tramite l&amp;rsquo;estensione di &lt;em&gt;NewRelic&lt;/em&gt; disponibile per &lt;strong&gt;PHP&lt;/strong&gt;, è possibile aggiungere i dettagli dell&amp;rsquo;utente attualmente collegato chiamando la funzione &lt;code&gt;newrelic_add_custom_parameter (&#39;userID&#39;, $userId)&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;eventi-personalizzati:0fc835fee623e5d493f15e3070958a9c&#34;&gt;Eventi personalizzati&lt;/h4&gt;

&lt;p&gt;Gli &lt;em&gt;eventi personalizzati&lt;/em&gt; vanno inviati ad un &lt;strong&gt;webservice REST&lt;/strong&gt; in formato &lt;strong&gt;JSON&lt;/strong&gt;. Ci mettono in grado di tracciare un qualsiasi evento all’interno di una normale transazione già tracciata da NewRelic, come ad esempio i tempi di risposta di un servizio esterno utilizzato dall’applicazione.&lt;/p&gt;

&lt;p&gt;Gli eventi personalizzati possono essere registrati richiamando la relativa funzione &lt;code&gt;newrelic_record_custom_event(&#39;DNDServiceCall&#39;,[&#39;business&#39; =&amp;gt; &#39;telefonia&#39;, &#39;responseTime&#39; =&amp;gt; 1500])&lt;/code&gt; disponibile nelle ultime versioni dell&amp;rsquo;estensione &lt;strong&gt;PHP&lt;/strong&gt; oppure tramite una semplice chiamata cURL come indicato dalla &lt;a href=&#34;https://docs.newrelic.com/docs/insights/new-relic-insights/adding-querying-data/inserting-custom-events-insights-api&#34;&gt;documentazione&lt;/a&gt; sui &lt;em&gt;custom events&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una volta che i dati vengono raccolti da &lt;em&gt;NewRelic&lt;/em&gt; è possibile analizzarli tramite delle semplici query in un linguaggio simil-&lt;em&gt;SQL&lt;/em&gt;, in questo caso chiamato &lt;strong&gt;NRQL&lt;/strong&gt; (&lt;em&gt;NewRelic Query Language&lt;/em&gt;). La sintassi base di una SELECT in SQL viene mantenuta, ma vengono forniti strumenti per meglio gestire le serie temporali, tramite &lt;strong&gt;TIMESERIES&lt;/strong&gt;, &lt;strong&gt;SINCE&lt;/strong&gt;, &lt;strong&gt;UNTIL&lt;/strong&gt;: una trattazione più approfondita è disponibile alla relativa pagina della &lt;a href=&#34;https://docs.newrelic.com/docs/insights/new-relic-insights/using-new-relic-query-language/nrql-reference&#34;&gt;documentazione&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I risultati delle &lt;em&gt;query&lt;/em&gt; vengono resi disponibili in formato &lt;strong&gt;JSON&lt;/strong&gt;, oppure come widget da poter integrare poi in una dashboard, in maniera da tenere sempre sotto controllo le metriche più importanti per la conduzione del proprio business. Inoltre tramite &lt;a href=&#34;https://docs.newrelic.com/docs/insights/new-relic-insights/using-insights-interface/exploring-your-data&#34;&gt;Data Explorer&lt;/a&gt; è possibile consultare un campione degli eventi recentemente inviati dalla nostra applicazione a &lt;em&gt;NewRelic&lt;/em&gt;, così da poter eventualmente raffinare le strutture dati con cui vengono raccolti.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Il principio OPEN/CLOSE le sue origini e i casi d&#39;uso</title>
      <link>/blog/ita/principio-open-close-le-sue-origini-e-i-casi-d-uso/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/principio-open-close-le-sue-origini-e-i-casi-d-uso/</guid>
      <description>

&lt;h2 id=&#34;definizione:4d43e339c52ffe85c41a2012c2e2301f&#34;&gt;Definizione:&lt;/h2&gt;

&lt;p&gt;Il principio &lt;em&gt;OPEN/CLOSE&lt;/em&gt; fa riferimento all&amp;rsquo;acronimo &lt;a href=&#34;http://en.wikipedia.org/wiki/SOLID_(object-oriented_design&#34;&gt;SOLID&lt;/a&gt;).  introdotto da  Michael Feathers che riporta alcune &lt;em&gt;buone pratiche&lt;/em&gt; di programmazione ad oggetti ancora di forte attualità.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;OPEN/CLOSE&lt;/em&gt; (la &lt;strong&gt;O&lt;/strong&gt; dell&amp;rsquo;acronimo), nella sua definizione più generale indica che:  un modulo (un oggetto, una classe o un gruppo di funzioni) debba essere &lt;strong&gt;aperto alle estensioni&lt;/strong&gt; ma &lt;strong&gt;chiuso alle modifiche&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Questo principio tuttavia non è altro che la formalizzazione e il raggruppamento di concetti e linee guida già presenti da tempo nella programmazione ad oggetti.&lt;/p&gt;

&lt;h3 id=&#34;chiuso-alle-modifiche:4d43e339c52ffe85c41a2012c2e2301f&#34;&gt;Chiuso alle modifiche&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Chiuso alle modifiche che potrebbero aver effetto sul client&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Possiamo esprimere questa linea guida anche come  un evoluzione di Single responsibility: Un modulo prodotto con un buon design avrà una responsabilità precisa, definita e, quindi, non vi sarà la necessita di modificare il suo comportamento, &lt;strong&gt;anche alla luce di nuove specifiche&lt;/strong&gt;.
Per chiarire ancora di più il concetto dobbiamo fare riferimento ad un altro famoso acronimo della programmazioni ad aggetti: GRASP e, in particolare, all&amp;rsquo;idea di &lt;a href=&#34;http://www.martinfowler.com/ieeeSoftware/protectedVariation.pdf&#34;&gt;Protected Variations&lt;/a&gt; (da ora in poi &lt;em&gt;PV&lt;/em&gt;) e di &lt;a href=&#34;http://en.wikipedia.org/wiki/Loose_coupling&#34;&gt;Low coupling&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In un articolo di &lt;a href=&#34;http://en.wikipedia.org/wiki/Craig_Larman&#34;&gt;Craig Larman&lt;/a&gt; si parla di &lt;em&gt;PV&lt;/em&gt; come la necessità di:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nascondere l&amp;rsquo;implementazione (&lt;a href=&#34;http://en.wikipedia.org/wiki/Information_hiding&#34;&gt;information hiding&lt;/a&gt;) e le informazioni legate al design (hidden implementation) agli altri moduli in particolar modo al presentarsi di scelte difficili o cambiamenti molto frequenti.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Questo garantisce, in generale, un livello di flessibilità superiore, si pensi a questo semplice esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** Questa classe è esposta al client **/
class ClasseEsterna 
{
  private var $oggettoInterno;

  public function incrementa()       {
    [...]           
    return $this-&amp;gt;oggettoInterno-&amp;gt;complessaFunzioneDiIncremento();
  }     
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si può notare come :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L&amp;rsquo;implementazione della &lt;em&gt;complessa&lt;/em&gt; funzione interna è nascosta al client;&lt;/li&gt;
&lt;li&gt;All&amp;rsquo;evolvere della &lt;strong&gt;complessaFunzioneDiIncremento&lt;/strong&gt; il nostro client sarà ==protetto== dalle modifiche;&lt;/li&gt;
&lt;li&gt;Abbiamo realizzato un &lt;em&gt;low coupling&lt;/em&gt; fra la l&amp;rsquo;&lt;strong&gt;oggettoInterno&lt;/strong&gt; e il client che utilizza la &lt;strong&gt;ClasseEsterna&lt;/strong&gt;, promuovendo, di fatto, il ==riuso== di &lt;strong&gt;oggettoInterno&lt;/strong&gt; in altri contesti.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;aperto-alle-estensioni:4d43e339c52ffe85c41a2012c2e2301f&#34;&gt;Aperto alle estensioni:&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Aperto ad essere esteso ed adattato&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Le modalità tramite le quali è possibile modificare il comportamento di un modulo per accogliere le nuove esigenze ed evoluzioni è tramite le estensioni.&lt;/p&gt;

&lt;p&gt;In questo caso il concetto di estensione può essere visto sia in senso stretto (Ereditarietà) sia in senso lato come aggiunta di nuove classi, attributi metodi etc..&lt;/p&gt;

&lt;p&gt;Sembrerebbe che questi due attributi siano in contrapposizione; Il modo classico per estendere il comportamento di un modulo è effettuare modifiche al modulo stesso.
Un modulo che non può cambiare è solitamente considerato qualcosa che ha un comportamento fisso e che non può evolvere.&lt;/p&gt;

&lt;p&gt;Un esempio è il pattern chain of responsibility che vediamo di seguito.&lt;/p&gt;

&lt;h3 id=&#34;chain-of-responsibility:4d43e339c52ffe85c41a2012c2e2301f&#34;&gt;Chain of responsibility:&lt;/h3&gt;

&lt;p&gt;Questo pattern risolve un’ampia classe di situazioni nelle quali vi sia la necessità di eseguire operazioni &lt;strong&gt;sequenziali&lt;/strong&gt; e &lt;strong&gt;condizionali&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;La chain of responsibility è composta da 2 soggetti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; gestore.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;n&lt;/strong&gt; anelli.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;GESTORE:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nella definizione teorica della catena questo soggetto non esiste!
Tuttavia, per avvicinarci ad  un implementazione di questo pattern, è necessario utilizzare un vigile della catena che è a conoscenza dello stato globale dell’esecuzione.
Il gestore ha la responsabilità di chiamare in causa i singoli anelli e di restituire il risultato dell’esecuzione globale.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;
class Gestore
{

    /**
     * Il metodo execute chiama in causa tutti gli anelli della catena.
     * @param Object $oggetto
     * @return Object
     **/
    public function execute(Object $oggetto)
    {

        // [...]

        foreach ($listaAnelli as $anello) {
            $anello-&amp;gt;handle($oggetto);
        }

        // [...]

        return $oggetto;

    }


}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ANELLI:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I singoli anelli implementano un interfaccia comune che solitamente espone un solo metodo pubblico esempio &lt;em&gt;handle&lt;/em&gt; .&lt;strong&gt;Non possono&lt;/strong&gt; tener conto del risultato di precedenti anelli, non sono a conoscenza dello stato globale dell’esecuzione e possono, quindi, prendere solo decisioni locali.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;interface AnelloInterface {

 /**
  * Il metodo handle effettua delle operazioni sull&#39;oggetto in esame.
  * @param Object $oggetto
  * @return void
  **/
 function handle(Object $oggetto);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Come rispettiamo PV ? Ovvero, come proteggiamo il client da future evoluzione del sistema?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Il client utilizzerà sempre &lt;strong&gt;la stessa API&lt;/strong&gt; esposta dal gestore della catena. Le modifiche non interesseranno, infatti, il contratto fra client e gestore.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Il sistema è aperto alle estensioni?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;All&amp;rsquo;evoluzione della catena verranno inseriti nuovi anelli che copriranno ulteriori casi d&amp;rsquo;uso o funzionalità. Sebbene i nuovi anelli dovranno implementare la stessa interfaccia potranno avere una logica interna completamente personalizzabile.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Esiste una forte separazione fra i moduli del sistema?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Il low coupling in questa caso è garantito da 2 aspetti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Il client non conosce gli elementi della catena perché ha una relazione diretta solamente con il gestore.&lt;/li&gt;
&lt;li&gt;È presente coesione fra l&amp;rsquo;interfaccia dei singoli anelli e il gestore. Purché si rispetti questo contratto è possibile esprimere anche logiche complesse.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;conclusione:4d43e339c52ffe85c41a2012c2e2301f&#34;&gt;Conclusione:&lt;/h3&gt;

&lt;p&gt;È necessario &lt;strong&gt;scegliere le proprie battaglie&lt;/strong&gt; quando si parla di design, sia che si tratti di scelte macro-architetturali che piccole scelte sulla singola istanza.&lt;/p&gt;

&lt;p&gt;I principi che non stati esposti non sono applicabili in tutte le situazioni, un bravo sviluppatore cercherà di utilizzare PV e low coupling in &lt;strong&gt;aree strategiche del sistema&lt;/strong&gt;, &lt;strong&gt;spesso soggette a cambiamento&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Se non si riesce ad identificare correttamente queste aree non si farà altro che introdurre una maggiore complessità generale che, in certe situazioni può essere deleteria.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;obbiettivo finale dovrebbe essere sempre minimizzare l&amp;rsquo;impatto sul sistema dei (naturali) cambiamenti; Open/Close PV e low coupling sono alcune delle strategie più efficaci.&lt;/p&gt;

&lt;h4 id=&#34;bibliografia:4d43e339c52ffe85c41a2012c2e2301f&#34;&gt;Bibliografia&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Craig Larman - &lt;a href=&#34;http://www.utdallas.edu/~chung/SP/applying-uml-and-patterns.pdf&#34;&gt;Applying UML and Patterns – An Introduction to Object-Oriented Analysis and Design and Iterative Development (3rd ed.)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parnas, D.L. - &lt;a href=&#34;https://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf&#34;&gt;&amp;ldquo;On the Criteria To Be Used in Decomposing Systems into Modules&amp;rdquo;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Craig Larman - &lt;a href=&#34;http://www.martinfowler.com/ieeeSoftware/protectedVariation.pdf&#34;&gt;&amp;ldquo;Protected Variation: The Importance of Being Closed&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SIGS Publications - &lt;a href=&#34;http://www.objectmentor.com/resources/articles/ocp.pdf&#34;&gt;The Open-Closed Principle: C++ Report&lt;/a&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Information_hiding&#34;&gt;Information Hiding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Xcode Testing in pratica</title>
      <link>/blog/ita/xcode-testing-in-pratica/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/xcode-testing-in-pratica/</guid>
      <description>

&lt;p&gt;Tra i molti strumenti utili presenti in Xcode, il testing framework &lt;strong&gt;XCTest&lt;/strong&gt; è certamente uno dei più rilevanti, non solo per l&amp;rsquo;importanza intrinseca dello Unit Testing in generale, ma soprattutto per la facilità con la quale è possibile scrivere ed eseguire test direttamente dall&amp;rsquo;IDE &lt;em&gt;out-of-the-box&lt;/em&gt;, &lt;strong&gt;senza la necessità di installare componenti di terze parti&lt;/strong&gt; o impostare una particolare configurazione per i progetti.&lt;/p&gt;

&lt;p&gt;In effetti Xcode, al momento della creazione di un nuovo progetto, oltre a creare un target per il binario principale crea automaticamente anche un &lt;strong&gt;target di test&lt;/strong&gt;, cioè un bundle aggiuntivo che può essere caricato nel bundle principale per poter fisicamente eseguire i test una volta avviata l&amp;rsquo;app. Nell&amp;rsquo;immagine seguente è possibile vedere come, in un progetto appena creato, sia già presente il test bundle, in questo caso chiamato &lt;em&gt;AwesomeAppTests.xctest&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xcode-testing-in-pratica/image_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Come mostrato nell&amp;rsquo;immagine, Xcode ha anche creato automaticamente il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, all&amp;rsquo;interno del quale potremo iniziare a scrivere i nostri test.&lt;/p&gt;

&lt;h2 id=&#34;setup-dell-ambiente-di-test:8e547c1c6819d235540b10fca98b5c29&#34;&gt;Setup dell&amp;rsquo;ambiente di test&lt;/h2&gt;

&lt;p&gt;Al di là del meccanismo con il quale il testing avviene, è importante capire che il codice con il quale i test sono stati scritti è compilato in un bundle diverso, e per far sì che i test &amp;ldquo;vedano&amp;rdquo; il resto dell&amp;rsquo;app, è necessario seguire le &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html&#34;&gt;regole di access control tra i moduli in Swift&lt;/a&gt;; quindi classi, struct, funzioni, costanti e così via che abbiamo dichiarato e implementato nella nostra app, o libreria che sia, &lt;strong&gt;dovranno essere marcati con la keyword *public&lt;/strong&gt;*:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func sumOfInts (x: Int, y: Int) -&amp;gt; Int {
    return x + y
}
    
public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo modo, qualsiasi modulo esterno che importerà il modulo costituito dalla nostra app potrà vedere la firma della funzione &lt;code&gt;sumOfInts&lt;/code&gt; e della classe &lt;code&gt;AwesomeItem&lt;/code&gt;. Per importare nei file di testing nel modulo dell&amp;rsquo;app sarà sufficiente scrivere &lt;code&gt;import AwesomeApp&lt;/code&gt; all&amp;rsquo;inizio del file. Aggiungiamo al progetto un file .swift, inserendo il codice appena visto: useremo questo file per scrivere tutto il codice da testare.&lt;/p&gt;

&lt;p&gt;Apriamo quindi il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, importiamo il modulo &lt;code&gt;AwesomeApp&lt;/code&gt;, eliminiamo le due funzioni di test di esempio, che hanno il solo scopo di presentare la sintassi di base dei test all&amp;rsquo;utente, e scriviamo un test banale per la funzione &lt;code&gt;sumOfInts&lt;/code&gt;; avremo quindi qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
    override func setUp() {
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        super.tearDown()
    }
    
    func testSumOfInts() {
        /// test the sumOfIntsFunction
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xcode ha identificato la funzione &lt;code&gt;testSumOfInts&lt;/code&gt; come &lt;strong&gt;una funzione di test&lt;/strong&gt; perché il suo nome inizia con &amp;ldquo;test&amp;rdquo;, e ha posizionato un pulsante di avvio test proprio di fianco alla sua dichiarazione:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xcode-testing-in-pratica/image_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per far eseguire a Xcode questo test, e solo questo, sarà sufficiente cliccare su quel pulsante. In alternativa sarà possibile selezione &amp;ldquo;Test&amp;rdquo; dal menu &amp;ldquo;Product&amp;rdquo; per far eseguire a Xcode tutti i test che l&amp;rsquo;IDE ha riconosciuto. Xcode offre anche un &lt;strong&gt;Test Navigator&lt;/strong&gt;, che mostra il nome di tutti i test implementati, raggruppati per &lt;em&gt;Test Case&lt;/em&gt;: spostando il puntatore del mouse su un test apparirà un pulsante a forma di freccia che permetterà di avviare singolarmente i test, oppure tutti i test relativi a un particolare &lt;em&gt;Test Case&lt;/em&gt;, o anche tutti i test scritti.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xcode-testing-in-pratica/image_3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per poter eseguire i test, Xcode deve effettivamente avviare l&amp;rsquo;app: selezioniamo uno dei simulatori disponibili in modo che a ogni avvio di test Xcode apra automaticamente il simulatore scelto.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/xcode-testing-in-pratica/image_4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;xctestcase-e-xctassert:8e547c1c6819d235540b10fca98b5c29&#34;&gt;XCTestCase e XCTAssert&lt;/h2&gt;

&lt;p&gt;Nel framework &lt;strong&gt;XCTest&lt;/strong&gt; un &lt;em&gt;Test Case&lt;/em&gt; è rappresentato da una sottoclasse della classe &lt;code&gt;XCTestCase&lt;/code&gt;: al momento dell&amp;rsquo;avvio dei test viene automaticamente generata un&amp;rsquo;istanza di ciascun Test Case che abbiamo implementato, e vengono eseguiti uno a uno tutti i test dichiarati, avviando le funzioni &lt;code&gt;testSomething()&lt;/code&gt; che li implementano. Anche i metodi &lt;code&gt;setUp()&lt;/code&gt; e &lt;code&gt;tearDown()&lt;/code&gt; sono chiamati automaticamente nel corso dei test: come indicano i commenti inseriti da Xcode, il metodo &lt;code&gt;setUp()&lt;/code&gt; è chiamato immediatamente prima di ogni test, e permette di inizializzare eventuali attributi d&amp;rsquo;istanza, o variabili globali; come è intuibile, il metodo &lt;code&gt;tearDown()&lt;/code&gt; permette di ripristinare eventualmente lo stato iniziale dopo ciascun test. L&amp;rsquo;implementazione di questi due metodi è comunque del tutto opzionale: essi rappresentano semplicemente degli strumenti in più.&lt;/p&gt;

&lt;p&gt;Poiché &lt;strong&gt;i nostri Test Case sono effettivamente delle classi&lt;/strong&gt;, possiamo implementare anche altri metodi e attributi per ciascuna classe, che possono facilmente essere richiamati nei singoli test, come nel seguente esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
		var firstInt = 0
		var secondInt = 0
		var expectedSum = 0

    override func setUp() {
        super.setUp()
        
				self.firstInt = 1
				self.secondInt = 2
				self.expectedSum = 3
    }
    
    override func tearDown() {
        self.firstInt = 0
				self.secondInt = 0
				self.expectedSum = 0
        super.tearDown()
    }
   	
    func testSumOfInts() {
				let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si vede dall&amp;rsquo;esempio, per testare la funzione &lt;code&gt;sumOfInts&lt;/code&gt; si è impiegata la funzione &lt;code&gt;XCTAssert&lt;/code&gt;: tale funzione rappresenta il blocco costruttivo di base per poter scrivere i nostri unit test, e prende in ingresso da 1 a 4 parametri: il primo parametro, l&amp;rsquo;unico obbligatorio, deve essere un&amp;rsquo;espressione la cui valutazione restituisce un valore Booleano true/false, mentre gli altri parametri, del tutto opzionali poiché caratterizzati da valori di default, rappresentano rispettivamente:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un messaggio testuale che verrà mostrato in console nel caso in cui il test fallisca;&lt;/li&gt;
&lt;li&gt;il file all&amp;rsquo;interno del quale è presente il test fallito;&lt;/li&gt;
&lt;li&gt;la linea di codice in corrispondenza della quale è presente la funzione XCTAssert relativa al test fallito;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La libreria &lt;code&gt;XCTest&lt;/code&gt; dichiara molte diverse funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt;, &lt;strong&gt;i cui casi di utilizzo sono chiaramente dedotti dal nome delle funzioni&lt;/strong&gt;: ad esempio la funzione &lt;code&gt;XCTAssertNil&lt;/code&gt; verifica che l&amp;rsquo;argomento, cioè il primo parametro, sia &lt;code&gt;nil&lt;/code&gt;; la funzione &lt;code&gt;XCTAssertGreaterThan&lt;/code&gt; prende due espressioni invece di una, la cui valutazione deve restituire un valore di tipo &lt;code&gt;Comparable&lt;/code&gt; - cioè che può essere confrontato con altri valori tramite gli operatori maggiore/minore e derivati - e verifica che il risultato della prima espressione sia maggiore del risultato della seconda.&lt;/p&gt;

&lt;p&gt;Sfruttando le altre funzioni &lt;code&gt;XCTAssert&lt;/code&gt;, possiamo estendere &lt;code&gt;testSumOfInts&lt;/code&gt; per includere altre verifiche su &lt;code&gt;sumOfInts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testSumOfInts() {
        
        XCTAssertEqual(sumOfInts(self.firstInt, self.secondInt), sumOfInts(self.secondInt, self.firstInt))

        let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
        if self.firstInt &amp;lt; 0 &amp;amp;&amp;amp; self.secondInt &amp;lt; 0 {
            XCTAssertLessThan(sum, 0)
        }
        else {
            if self.firstInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.secondInt)
            }
            if self.secondInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.firstInt)
            }
            if self.firstInt &amp;gt;= 0 &amp;amp;&amp;amp; self.secondInt &amp;gt;= 0 {
                XCTAssertGreaterThanOrEqual(sum, 0)
                XCTAssertGreaterThanOrEqual(sum, self.firstInt)
                XCTAssertGreaterThanOrEqual(sum, self.secondInt)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-asincroni:8e547c1c6819d235540b10fca98b5c29&#34;&gt;Test asincroni&lt;/h2&gt;

&lt;p&gt;La libreria XCTest include alcuni strumenti per eseguire &lt;strong&gt;test su computazioni asincrone&lt;/strong&gt;, cioè eseguite da funzioni che non ritornano immediatamente un valore ma che potrebbero chiamare una funzione di callback a un certo punto nel futuro. Per testare una funzione asincrona è necessario:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;creare un&amp;rsquo;istanza di &lt;code&gt;XCTestExpectation&lt;/code&gt;, un oggetto che rappresenta l&amp;rsquo;&lt;strong&gt;aspettativa&lt;/strong&gt; che ad un certo punto nel futuro accada qualcosa;&lt;/li&gt;
&lt;li&gt;informare l&amp;rsquo;istanza del &lt;code&gt;XCTestCase&lt;/code&gt;, generata automaticamente all&amp;rsquo;avvio dei test, che nel corso di un certo test è necessario che le &lt;em&gt;aspettative&lt;/em&gt; vengano &lt;em&gt;soddisfatte&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Per fare un esempio, aggiungiamo una semplice funzione pubblica a &lt;em&gt;AwesomeItem.swift&lt;/em&gt; che permette di scaricare un&amp;rsquo;immagine presente a un certo URL, e chiama una funzione callback restituendo appunto una &lt;code&gt;UIImage&lt;/code&gt; che rappresenti l&amp;rsquo;immagine scaricata: per semplicità non gestiremo gli errori, e nel caso in cui qualcosa vada storto otterremo semplicemente &lt;code&gt;nil&lt;/code&gt; al posto dell&amp;rsquo;immagine (quindi l&amp;rsquo;oggetto effettivamente ottenuto sarà di tipo &lt;code&gt;UIImage?&lt;/code&gt;, cioè un oggetto opzionale). Per poter manipolare &lt;code&gt;UIImage&lt;/code&gt; dobbiamo importare &lt;code&gt;UIKit&lt;/code&gt; in &lt;em&gt;AwesomeItem.swift&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import UIKit

public func sumOfInts (a: Int, b: Int) -&amp;gt; Int {
    return a + b
}

public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
}

public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Che si riesca a meno a scaricare l&amp;rsquo;immagine, la funzione di callback deve comunque essere chiamata in un tempo ragionevole, e l&amp;rsquo;obbiettivo del test asincrono sarà proprio quello di verificare che la tale funzione venga chiamata, ignorando  l&amp;rsquo;oggetto ottenuto per l&amp;rsquo;immagine. Segue una possibile implementazione per questo test, nella quale creiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt; e impostiamo un&amp;rsquo;attesa di 5 secondi: è ovviamente possibile sincronizzare il tempo di attesa con il tempo di timeout della sessione di download creata, ma per semplicità imposteremo un tempo forfettario.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDownloadImageCallback() {
        
        let downloadImageCallbackExpectation = self.expectationWithDescription(&amp;quot;downloadImageCallbackExpectation&amp;quot;)
        
        let imageUrl = NSURL(string: &amp;quot;http://goo.gl/XYwppm&amp;quot;)!
        
        downloadImage(imageUrl) { image in
            downloadImageCallbackExpectation!.fulfill();
        }
        
        self.waitForExpectationsWithTimeout(5.0, handler: nil)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se proviamo ad avviare il test cliccando sull&amp;rsquo;icona di avvio apparsa in Xcode proprio a sinistra della riga di dichiarazione della funzione, analogamente a quando mostrato prima, vedremo che Xcode rimarrà bloccato per 5 secondi prima di mostrare il messaggio &lt;code&gt;Asynchronous wait failed: Exceeded timeout of 5 seconds, with unfulfilled expectations: &amp;quot;downloadImageCallbackExpectation&amp;quot;.&lt;/code&gt;: come mai? Il fallimento del test ci informa subito del fatto che la funzione di download dell&amp;rsquo;immagine che abbiamo scritto ha qualche problema: è facile vedere che esso è dovuto al fatto che non abbiamo chiamato &lt;code&gt;resume()&lt;/code&gt; sulla task di download creata. Correggiamo quindi la nostra funzione &lt;code&gt;downloadImage&lt;/code&gt; nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
    task.resume()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Il test ci ha immediatamente informati dell&amp;rsquo;errore&lt;/strong&gt;, e ci ha permesso di evitare una possibile sorgente di bug nel nostro codice, e diversi mal di testa. Grazie al modo &lt;em&gt;seamless&lt;/em&gt; nel quale il framework XCTest è integrato in Xcode, risulta facile e veloce scrivere test che permettano di verificare immediatamente se il nostro codice funziona come dovrebbe, ed &lt;strong&gt;è Xcode stesso a incoraggiare la scrittura di test&lt;/strong&gt; nel corso della realizzazione di un&amp;rsquo;app o di una libreria generando automaticamente un target di test ogni volta in cui si crea un nuovo progetto: non ci sono più scuse quindi per non iniziare a scrivere test completi ed efficienti che permettano di &lt;strong&gt;realizzare software migliore&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il progetto Xcode contenente tutto il codice mostrato nell&amp;rsquo;articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/xcode-testing-in-pratica&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>