<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional programming on Facile Engineering</title>
    <link>/categories/functional-programming/</link>
    <description>Recent content in Functional programming on Facile Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/functional-programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Codice riusabile: un primer</title>
      <link>/blog/ita/codice-riusabile-un-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/codice-riusabile-un-primer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/optionals-in-objective-c-ita/&#34;&gt;L&amp;rsquo;ultima volta&lt;/a&gt; abbiamo visto una possibile implementazione del tipo &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optional&lt;/a&gt; in Objective-C; l&amp;rsquo;obiettivo primario dell&amp;rsquo;articolo era quello di importare in Objective-C uno strumento frequentemente utilizzato in Swift, ma usare una classe come &lt;code&gt;Optional&lt;/code&gt; può essere considerato un&amp;rsquo;applicazione di un concetto molto più generale: il &lt;strong&gt;riutilizzo del codice&lt;/strong&gt;. In effetti, &lt;code&gt;Optional&lt;/code&gt; non è legato a un particolare dominio, e può essere riutilizzato più e più volte in molti progetti: questo è esattamente ciò che accade in Swift. Ma a pensarci bene, questo è ciò che accade per una grande varietà di &lt;em&gt;classi&lt;/em&gt; in Objective-C (e di &lt;em&gt;tipi&lt;/em&gt; in Swift): ad esempio, &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; sono entrambi costrutti che espongono una specifica interfaccia, possiedono una certa implementazione, e vengono riutilizzati continuamente in metodi e funzioni. &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; non sono legati a un particolare dominio, e possiedono due importanti caratteristiche:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sono &lt;strong&gt;generici&lt;/strong&gt;, quindi non sono legati a un particolare sottotipo: un array di numeri e un array di stringhe funzioneranno esattamente allo stesso modo per quanto riguarda le funzioni strettamente associate agli array, come il conteggio degli elementi, rimuovere o aggiungere un elemento, mappare, filtrare, ridurre e così via;&lt;/li&gt;
&lt;li&gt;sono &lt;strong&gt;componibili&lt;/strong&gt;, quindi possono essere combinati tra loro e con altri oggetti più specifici, mantenendo comunque lo stesso &lt;strong&gt;comportamento predicibile&lt;/strong&gt;: un array di &lt;em&gt;clienti&lt;/em&gt;, ciascuno con il suo array &lt;em&gt;prodotti acquistati&lt;/em&gt;, può essere mappato in un array di array di &lt;em&gt;prodotti&lt;/em&gt;, che può essere appiattito in un array di &lt;em&gt;prodotti&lt;/em&gt;, che può essere ridotto a un numero che rappresenta il costo totale;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;, come &lt;code&gt;Optional&lt;/code&gt;, è un ottimo esempio di codice perfettamente riutilizzabile, ma ci sono molti altri costrutti che soddisfano le regole di cui sopra, cioè &lt;em&gt;genericità&lt;/em&gt; e &lt;em&gt;componibilità&lt;/em&gt;. Gli oggetti specifici di dominio, invece, tipicamente non soddisfano queste regole, anche quando un oggetto sembra essere sufficientemente generico da poter essere riutilizzato. Una classe &lt;code&gt;Cliente&lt;/code&gt;, ad esempio, potrebbe sembrare un buon candidato, ma cercare di usare la stessa classe in due diversi progetti si rivelerebbe &lt;strong&gt;una pessima idea&lt;/strong&gt;: probabilmente saremo costretti a &lt;strong&gt;specializzare&lt;/strong&gt; la classe per ciascun progetto, portando a divergenza tra le implementazioni, o usare diversi livelli di &lt;strong&gt;indirezione&lt;/strong&gt;, perché stiamo inserendo a forza un oggetto in un dominio che non gli appartiene.&lt;/p&gt;

&lt;p&gt;C&amp;rsquo;è un&amp;rsquo;altra cosa da considerare: se davvero vogliamo riutilizzare del codice, dovremo anche stare attenti alle nostre &lt;strong&gt;scelte di design&lt;/strong&gt;, perché non tutti i design permettono l&amp;rsquo;utilizzo di codice generico. Potrei dimenticarmi dell&amp;rsquo;esistenza dei tipi &lt;code&gt;Optional&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt;, e creare classi che non espongono mai i loro componenti di base; ad esempio, potrei creare una classe che rappresenta una collezione di oggetti opzionali, senza mai esporre nell&amp;rsquo;interfaccia il fatto che sto utilizzando &lt;code&gt;Array&lt;/code&gt; e &lt;code&gt;Optional&lt;/code&gt; nell&amp;rsquo;implementazione: ne risulterebbe una certa &lt;strong&gt;complicazione&lt;/strong&gt; della firma dei metodi, ma è possibile. Ma, a pensarci bene, è una buona idea? &lt;strong&gt;Ne dubito&lt;/strong&gt;. Creare una nuova e specifica classe, non componibile, per ogni possibile necessità produrrà migliaia di linee di codice &lt;strong&gt;boilerplate&lt;/strong&gt;, interfacce complicate, e nomi di classi assurdamente lunghi. Se vogliamo scrivere codice riutilizzabile, oltre a seguire le due regole già viste, dobbiamo anche prestare attenzione al modo in cui architettiamo le nostre app, e il principio di design da seguire in questo caso è il principio di &lt;strong&gt;composizione&lt;/strong&gt;, che può essere sintetizzato con la seguente frase:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Costrutti e comportamenti specifici del dominio dovrebbero essere realizzati componendo blocchi costruttivi atomici e generici.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ciò significa sostanzialmente che, invece di creare di volta in volta una specifica implementazione per ovviare alle nostre necessità, dovremmo costruire le nuove funzionalità aggregando oggetti atomici già definiti. Sembra un&amp;rsquo;idea complessa, e forse dovremmo fermarci un attimo e chiederci se scrivere codice riutilizzabile sia davvero una buona idea. La mia risposta è un definitivo &lt;strong&gt;si&lt;/strong&gt;, per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scrivendo componenti riutilizzabili possiamo &lt;strong&gt;incapsulare&lt;/strong&gt; uno specifico comportamento, evitando di dover riscrivere di continuo sostanzialmente lo stesso codice;&lt;/li&gt;
&lt;li&gt;potremmo disporre di &lt;strong&gt;linee guida&lt;/strong&gt; per progettare l&amp;rsquo;architettura delle nostre app, perché non avremmo bisogno di definire sempre nuove interfacce per rappresentare gli stessi comportamenti;&lt;/li&gt;
&lt;li&gt;un componente riutilizzabile è molto facile da &lt;strong&gt;testare&lt;/strong&gt;, perché piccolo e atomico, quindi usandolo potremmo confidare maggiormente sulla correttezza del nostro codice;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Questi stessi vantaggi si ottengono, infatti, proprio usando oggetti come &lt;code&gt;Array&lt;/code&gt; e &lt;code&gt;Optional&lt;/code&gt;. Ma, come ho detto, esistono molti altri componenti di questo tipo, e in effetti definire le loro interfacce è un problema a sé, di non facile soluzione: lo trovo tuttavia un problema molto interessante. Seguendo le regole &lt;em&gt;generico&lt;/em&gt; e &lt;em&gt;componibile&lt;/em&gt; abbiamo già una linea guida per definire nuovi componenti riusabili, ma per chiudere il cerchio abbiamo bisogno di una terza regola, non meno importante:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un oggetto riusabile deve essere &lt;strong&gt;semplice&lt;/strong&gt;, cioè deve avere una unica responsabilità, lineare e facile da descrivere;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; segue questa regola: è un contenitore generico per un oggetto che potrebbe esserci, oppure no. &lt;code&gt;Array&lt;/code&gt; segue questa regola: rappresenta una collezione ordinata di oggetti, ai quali posso accedere in un tempo costante. Proviamo a creare un nuovo componente riutilizzabile applicando le regole.&lt;/p&gt;

&lt;p&gt;Consideriamo questo caso d&amp;rsquo;uso reale (piuttosto frequente): diversi oggetti devono essere notificati quando un certo oggetto cambia il suo stato, o compie qualche azione. Un modo per risolvere il problema è rappresentato dall&amp;rsquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;, che consiste nel far implementare ai nostri oggetti un&amp;rsquo;interfaccia che indica un comportamento di tipo &lt;a href=&#34;https://it.wikipedia.org/wiki/Publish/subscribe&#34;&gt;publish-subscribe&lt;/a&gt;. Tuttavia, far implementare agli oggetti un&amp;rsquo;interfaccia &lt;strong&gt;non è riusabile&lt;/strong&gt;: ogni volta in cui useremo questo pattern finiremo per &lt;strong&gt;riscrivere&lt;/strong&gt; codice molto simile. Vogliamo invece incapsulare il comportamento alla base di questo pattern in un oggetto generico, e riutilizzare quell&amp;rsquo;oggetto. Quanto segue è una possibile implementazione di tale oggetto, quella che personalmente uso in produzione, ma ce ne sono molte altre: in effetti, l&amp;rsquo;idea di trovare un modo generico e componibile di rappresentare e manipolare &lt;em&gt;flussi&lt;/em&gt; di segnali osservabili ha fatto nascere un intero paradigma di programmazione, chiamato &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;functional reactive programming&lt;/a&gt;. Ma nel nostro caso siamo interessati a creare un ben più semplice oggetto &lt;strong&gt;Signal&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;La classe &lt;code&gt;Signal&lt;/code&gt; che vogliamo implementare deve rappresentare un &lt;em&gt;aggiornamento&lt;/em&gt; per un certo oggetto: l&amp;rsquo;aggiornamento può riguardare qualsiasi cosa, per esempio un nuovo valore per un attributo, o il fatto che una certa azione è stata compiuta. Useremo il linguaggio Swift, grazie al quale potremo godere anche di ottima sicurezza sulla manipolazione dei &lt;strong&gt;tipi&lt;/strong&gt; coinvolti. Ecco in sintesi cosa chiediamo alla classe &lt;code&gt;Signal&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;deve avere un sottotipo &lt;strong&gt;parametrico&lt;/strong&gt;, che sarà appunto il tipo del valore segnalato ad ogni aggiornamento;&lt;/li&gt;
&lt;li&gt;deve dichiarare un metodo &lt;code&gt;observe&lt;/code&gt;, che prende in ingresso una &lt;em&gt;closure&lt;/em&gt; che rappresenta l&amp;rsquo;azione da compiere a ogni aggiornamento;&lt;/li&gt;
&lt;li&gt;deve dichiarare un metodo &lt;code&gt;send&lt;/code&gt;, che prende in ingresso un nuovo valore del tipo sottostante;&lt;/li&gt;
&lt;li&gt;deve dichiarare semplici metodi di composizione, che seguano le convenzioni classiche per i nomi, come &lt;code&gt;map&lt;/code&gt; per generare un nuovo &lt;code&gt;Signal&lt;/code&gt; da uno esistente trasformando il valore osservato, e &lt;code&gt;forwardTo&lt;/code&gt; per fare in modo che un altro &lt;code&gt;Signal&lt;/code&gt;, quando produce un nuovo valore, &lt;em&gt;attivi&lt;/em&gt; il segnale di partenza;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dal punto di vista semantico, possiamo descrivere un &lt;code&gt;Signal&lt;/code&gt; come un contenitore di un valore che esisterà a un certo punto nel futuro, e continuerà ad aggiornarsi indefinitamente.&lt;/p&gt;

&lt;p&gt;Segue l&amp;rsquo;intera implementazione della classe &lt;code&gt;Signal&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum SignalContinuation
{
  case Continue
  case Stop
}

public class Signal&amp;lt;Subtype&amp;gt;
{
  private var observers: [(Subtype -&amp;gt; SignalContinuation)] = []

  public init() {}

  public func observe (observeFunction: Subtype -&amp;gt; SignalContinuation)
  {
    observers.append(observeFunction)
  }

  public func send (value: Subtype)
  {
    var continuations: [(Subtype -&amp;gt; SignalContinuation)] = []
    while observers.count &amp;gt; 0
    {
      let observer = observers.removeFirst()
      let continuation = observer(value)
      switch continuation
      {
      case .Continue:
        continuations.append(observer)
      case .Stop: break
      }
    }
    observers = continuations
  }

  public func forwardTo (otherSignal: Signal&amp;lt;Subtype&amp;gt;) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(action)
      return .Continue
    }
    return self
  }

  public func forwardTo &amp;lt;OtherSubtype&amp;gt; (
    otherSignal: Signal&amp;lt;OtherSubtype&amp;gt;,
    mappingFunction: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(mappingFunction(action))
      return .Continue
    }
    return self
  }

  public func map &amp;lt;OtherSubtype&amp;gt; (transform: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt;
  {
    let mappedSignal = Signal&amp;lt;OtherSubtype&amp;gt;()
    forwardTo(mappedSignal, mappingFunction: transform)
    return mappedSignal
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;implementazione è semplice, ma potente. Un problema affrontato di frequente quando si implementa l&amp;rsquo;&lt;em&gt;observer pattern&lt;/em&gt; è la gestione delle disiscrizioni; è responsabilità di chi osserva smettere di farlo, e in questa implementazione di &lt;code&gt;Signal&lt;/code&gt; la cosa è gestita direttamente nella &lt;em&gt;closure&lt;/em&gt; passata al metodo &lt;code&gt;observe&lt;/code&gt;: la &lt;em&gt;closure&lt;/em&gt; deve ritornare un valore di tipo &lt;code&gt;SignalContinuation&lt;/code&gt; che può essere appunto &lt;code&gt;.Continue&lt;/code&gt; o &lt;code&gt;.Stop&lt;/code&gt;. Un altro problema è la gestione della memoria: dobbiamo assicurarci che quando la memoria di un osservatore è rilasciata, questo debba anche smettere di osservare i segnali, o il messaggio verrà inviato a un puntatore non valido, con conseguente crash dell&amp;rsquo;app. Swift definisce alcuni descrittori di &lt;em&gt;memory ownership&lt;/em&gt;, e &lt;code&gt;weak&lt;/code&gt; fa al caso nostro: sarà sufficiente inserire una &lt;em&gt;guard clause&lt;/em&gt; all&amp;rsquo;inizio della &lt;em&gt;closure&lt;/em&gt; passata al metodo &lt;code&gt;observe&lt;/code&gt;; se l&amp;rsquo;oggetto è diventato &lt;code&gt;nil&lt;/code&gt;, la &lt;em&gt;closure&lt;/em&gt; ritornerà &lt;code&gt;.Stop&lt;/code&gt;. L&amp;rsquo;esempio seguente mostra un possibile utilizzo della classe &lt;code&gt;Signal&lt;/code&gt;, incluso il meccanismo appena descritto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Sender
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func sendNew(value: Int)
  {
    signal.send(value)
  }
}

class Receiver&amp;lt;Type: CustomStringConvertible&amp;gt;
{
  func startObserving(signal: Signal&amp;lt;Type&amp;gt;)
  {
    signal.observe { [weak self] value in
      guard let this = self else { return .Stop }
      this.printNewValue(value)
      return .Continue
    }
  }

  func printNewValue(value: Type)
  {
    print(value)
  }
}

let sender = Sender()
let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(sender.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 3, 5, 10, 20 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nell&amp;rsquo;esempio possiamo osservare l&amp;rsquo;applicazione dei concetti introdotti all&amp;rsquo;inizio dell&amp;rsquo;articolo: invece di creare una nuova interfaccia per lo stesso comportamento, stiamo direttamente usando e riusando l&amp;rsquo;oggetto &lt;code&gt;Signal&lt;/code&gt;. Un esempio più complesso potrebbe essere rappresentato dall&amp;rsquo;aggiunta di un &lt;em&gt;resonator&lt;/em&gt;, cioè di un oggetto che possiede un segnale che risuona con un altro, quindi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class DoublingResonator
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func resonateWith(otherSignal: Signal&amp;lt;Int&amp;gt;)
  {
    otherSignal.forwardTo(signal) { $0*2 }
  }
}

let resonator = DoublingResonator()
resonator.resonateWith(sender.signal)

let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(resonator.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 6, 10, 20, 40 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ci sono molte altre opzioni per comporre segnali, ma finché non ne avremo bisogno sarà meglio mantenere la classe &lt;strong&gt;semplice&lt;/strong&gt;: gradualmente nel tempo potremo aggiungere nuove funzionalità, e fintanto che queste saranno sufficientemente generiche e propriamente testate, saremo in grado di usarle in tutti i nostri progetti.&lt;/p&gt;

&lt;p&gt;Per concludere, definire le giuste astrazioni per conseguire riusabilità del codice non è un problema di semplice soluzione: molte pubblicazioni accademiche affrontano il problema (il classico articolo &lt;a href=&#34;http://www.biglever.com/papers/Krueger_AcmReuseSurvey.pdf&#34;&gt;Software Reuse&lt;/a&gt; di Charles W. Krueger fornisce una buona panoramica delle tecniche considerate), e il motivo per il quale la &lt;a href=&#34;https://it.wikipedia.org/wiki/Teoria_delle_categorie&#34;&gt;teoria delle categorie&lt;/a&gt; ha trovato molte applicazioni in programmazione funzionale è perché essa offre un eccellente insieme di astrazioni per affrontare diverse classi di problemi. Tuttavia sono convinto che i vantaggi legati allo scrivere codice riutilizzabile siano molti, e che poter basare un design sulla composizione di oggetti atomici sia &lt;strong&gt;un degno obiettivo&lt;/strong&gt; da perseguire.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Optionals in Objective-C</title>
      <link>/blog/eng/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/eng/optionals-in-objective-c/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Objective-C is not going anywhere&lt;/strong&gt;. While Swift is most certainly the new hotness for iOS and OS X programming, there are some concrete reasons to stick with Objective-C for a while:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Objective-C based projects still need maintenance and new features to be added, and mixing Swift and Objective-C, while possible, &lt;strong&gt;can be tricky&lt;/strong&gt; and possibly unconvenient, due to the dynamic nature of the latter;&lt;/li&gt;
&lt;li&gt;Swift is changing rapidly, has still some bugs and &lt;strong&gt;performance problems&lt;/strong&gt;, and still lacks some features that professionals need, while Objective-C is mature and has a strong community;&lt;/li&gt;
&lt;li&gt;some may &lt;strong&gt;prefer a more dynamic language&lt;/strong&gt;, and Objective-C support from Apple &lt;a href=&#34;https://netguru.co/blog/objective-c-generics&#34;&gt;is still strong&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Personally, while I naturally lean towards a more static, &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;type-first&lt;/a&gt; approach to programming, from time to time I like to work in a more dynamic environment, so both for preference and for business needs, I still didn&amp;rsquo;t put Objective-C completely away. But just after a few weeks of Swift I found myself missing one of the most powerful features of the language: &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optionals&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;table-of-contents:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Table of contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-optional-type&#34;&gt;The &lt;code&gt;Optional&lt;/code&gt; type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optionals-in-swift&#34;&gt;Optionals in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#back-to-objective-c&#34;&gt;Back to Objective-C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-a-json-parser&#34;&gt;Example: a JSON parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;the-optional-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-optional-type:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;The &lt;code&gt;Optional&lt;/code&gt; type&lt;/h2&gt;

&lt;p&gt;A Optional is a &lt;em&gt;generic&lt;/em&gt; type, that is, a type that&amp;rsquo;s dependent  (actually, &lt;em&gt;parametric&lt;/em&gt;) on another &lt;strong&gt;subtype&lt;/strong&gt;, so whe can have, for example, a &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt; or a &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt;: thanks to some syntactic sugar, those types are written in Swift as &lt;code&gt;String?&lt;/code&gt; and &lt;code&gt;Int?&lt;/code&gt;. So, what is an &lt;code&gt;Optional&lt;/code&gt;? It&amp;rsquo;s a representation   of a value that could be there, and be of a particular subtype, or could not, therefore being &lt;strong&gt;nil&lt;/strong&gt;: by &lt;em&gt;wrapping&lt;/em&gt; the subtype into an &lt;code&gt;Optional&lt;/code&gt;, the Swift compiler knows that the value could be nil, and complain in the cases where we are using an &lt;code&gt;Optional&lt;/code&gt; where a value that&amp;rsquo;s &lt;strong&gt;never&lt;/strong&gt; nil is expected. By itself, this simple feature grants us a lot of type-safety for free: for example, in Swift we can&amp;rsquo;t initialize a non-optional value with nil, and considering that, for the Swift&amp;rsquo;s compiler, a value cannot be used before being initialized, by saying that a value&amp;rsquo;s type is &lt;code&gt;String&lt;/code&gt; the compiler will assure us that the value will &lt;strong&gt;always&lt;/strong&gt; be a string, no matter what.&lt;/p&gt;

&lt;p&gt;In contrast, Objective-C objects can always be nil, and if we expect something not to be nil, we are forced to check for the actual existence of everything at any time. But actually, that&amp;rsquo;s not necessarily a big deal: it&amp;rsquo;s a classic &lt;strong&gt;tradeoff&lt;/strong&gt; of dynamic languages, and it can be even considered a &lt;em&gt;feature&lt;/em&gt; by some people: in using a dynamically typed language, we are always expected to design our APIs with &lt;a href=&#34;https://en.wikipedia.org/wiki/Late_binding&#34;&gt;late binding&lt;/a&gt; in mind. Also, the new &lt;a href=&#34;https://developer.apple.com/swift/blog/?id=25&#34;&gt;Objective-C nullability specifiers&lt;/a&gt; will help the compiler trigger warnings when nil is passed to a property or method parameter when &lt;code&gt;nonnull&lt;/code&gt; is expected. But the problem is still there: we need a lot of boilerplate to always check for &lt;em&gt;nullness&lt;/em&gt;, and that can produce error-prone, less readable code. The need for this boilerplate is missing in Swift, and that&amp;rsquo;s thanks to the nature of the &lt;code&gt;Optional&lt;/code&gt; type: in fact, it works in the same way as the &lt;code&gt;Maybe&lt;/code&gt; type in Haskell, or the &lt;code&gt;Option&lt;/code&gt; type in Scala, that is, &lt;code&gt;Optional&lt;/code&gt; is actually a &lt;strong&gt;monad&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The concept of &lt;em&gt;monad&lt;/em&gt; is inherited by functional programming from &lt;a href=&#34;https://en.wikipedia.org/wiki/Category_theory&#34;&gt;category theory&lt;/a&gt; and there are plenty of &lt;a href=&#34;https://wiki.haskell.org/Monad&#34;&gt;introductions&lt;/a&gt; &lt;a href=&#34;https://www.haskell.org/tutorial/monads.html&#34;&gt;about it&lt;/a&gt; &lt;a href=&#34;http://learnyouahaskell.com/a-fistful-of-monads&#34;&gt;on the web&lt;/a&gt;, so I&amp;rsquo;m not going into the specifics here: let me just say that a monad is a &lt;em&gt;computational context&lt;/em&gt;, that is, a specification for the way some &lt;em&gt;computations&lt;/em&gt; need to be resolved. Applying a certain transformation to a monad will result in another instance of the same monad, different from the first, based on the specific kind of monad. For example, applying some transformation to an &lt;code&gt;Optional&lt;/code&gt; monad will result in applying the same transformation to the contained value if it&amp;rsquo;s there, or absolutely nothing if the &lt;code&gt;Optional&lt;/code&gt; contains nil: in both cases, the transformation&amp;rsquo;s output will be another &lt;code&gt;Optional&lt;/code&gt;, possibly of different subtype.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;optionals-in-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;optionals-in-swift:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Optionals in Swift&lt;/h2&gt;

&lt;p&gt;Consider the following Swift code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalString = optionalInt.map(toString)
print(optionalString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example, &lt;code&gt;optionalInt&lt;/code&gt; is a &lt;code&gt;Int&lt;/code&gt; wrapped into an &lt;code&gt;Optional&lt;/code&gt;, thus having type &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt; (Swift&amp;rsquo;s syntactic sugar allows us to write &lt;code&gt;Int?&lt;/code&gt;), and by applying the &lt;code&gt;toString&lt;/code&gt; function to that &lt;code&gt;Optional&lt;/code&gt; we get an instance of &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt;. We can see that, to actually apply the &lt;code&gt;toString&lt;/code&gt; function to the &lt;code&gt;Optional&lt;/code&gt;, we passed the function to the &lt;code&gt;map&lt;/code&gt; method: this operation is usually called &lt;a href=&#34;https://wiki.haskell.org/Lifting&#34;&gt;&lt;em&gt;lifting&lt;/em&gt; a function&lt;/a&gt;, because the function &lt;code&gt;toString&lt;/code&gt;, of type &lt;code&gt;Int -&amp;gt; String&lt;/code&gt;, is &lt;em&gt;lifted&lt;/em&gt; into the type &lt;code&gt;Optional&amp;lt;Int&amp;gt; -&amp;gt; Optional&amp;lt;String&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As we can see, no conditional statements were used in manipulating the optional integer: by &lt;em&gt;lifting&lt;/em&gt; our transformations with the &lt;code&gt;map&lt;/code&gt; method, we can apply them directly to the &lt;code&gt;Optional&lt;/code&gt; instances, and we can also chain them pretty easily, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let doubled: Int -&amp;gt; Int = { $0*2 }

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalDoubledString = optionalInt.map(doubled).map(toString)
print(optionalDoubledString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to express the opposite operation, we run into a problem: transforming a &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Int&lt;/code&gt; is not always considered possible by Swift (for example, no numbers in the string), therefore the operation is optional. In fact:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalStringFrom(value: String, ifTrue: Bool) -&amp;gt; String?
{
  return ifTrue ? value : nil
}

let toInt: String -&amp;gt; Int? = { Int($0) }

let anotherOptionalString = makeOptionalStringFrom(&amp;quot;3&amp;quot;, ifTrue: true)

let anotherOptionalInt = anotherOptionalString.map(toInt).map(doubled)
/// this won&#39;t compile!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that &lt;code&gt;toInt&lt;/code&gt; is a function of type &lt;code&gt;String -&amp;gt; Optional&amp;lt;Int&amp;gt;&lt;/code&gt;, and lifting the function to the &lt;code&gt;Optional&lt;/code&gt; &amp;ldquo;world&amp;rdquo; will turn its type into something like &lt;code&gt;Optional&amp;lt;String&amp;gt; -&amp;gt; Optional&amp;lt;Optional&amp;lt;Int&amp;gt;&amp;gt;&lt;/code&gt;, that is, an optional integer wrapped into another optional: in &lt;em&gt;monadic&lt;/em&gt; terminology, to lift functions that transforms the wrapped type into another instance of the same monad, we need a &lt;code&gt;flatMap&lt;/code&gt; operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let anotherOptionalInt = anotherOptionalString.flatMap(toInt).map(doubled)
/// this is fine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, for the &lt;code&gt;Optional&lt;/code&gt; type, &lt;code&gt;flatMap&lt;/code&gt; works like &lt;code&gt;map&lt;/code&gt; but for functions that transform the wrapped type into another &lt;code&gt;Optional&lt;/code&gt;. In reading the code, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; can be basically treated as the same: they both indicate a transformation, and the fact that computations passed to &lt;code&gt;flatMap&lt;/code&gt; are of slightly different type can be considered an implementation detail.&lt;/p&gt;

&lt;p&gt;Actually, Swift treats these types &lt;strong&gt;a little differently&lt;/strong&gt; than in other languages: for example, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; are usually &lt;em&gt;free functions&lt;/em&gt; in most &lt;em&gt;functional&lt;/em&gt; languages, while in Swift they are &lt;strong&gt;methods&lt;/strong&gt;. In general, Swift encourages the use of methods and &lt;strong&gt;method chaining&lt;/strong&gt; instead of free functions composed with special operators: it&amp;rsquo;s mostly a matter of philosophy, but in bringing these features back to Objective-C, the method-based approach is going to be really useful because there&amp;rsquo;s no easy syntax for free functions in the language, while methods have the signature clean and readable syntax that we&amp;rsquo;re used to.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;back-to-objective-c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;back-to-objective-c:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Back to Objective-C&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement the &lt;code&gt;Optional&lt;/code&gt; class in Objective-C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface Optional : NSObject

+ (Optional*)with:(id _Nullable)value;

- (Optional*)map:(id(^)(id))mapBlock;
- (Optional*)flatMap:(Optional*(^)(id))flatMapBlock;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

#import &amp;quot;Optional.h&amp;quot;

@interface Optional ()

@property (strong, nonatomic, nullable) id value;

@end

@implementation Optional

+ (Optional*)with:(id _Nullable)value
{
  Optional* optional = [Optional new];
  optional.value = value;
  return optional;
}

- (Optional *)map:(id  _Nonnull (^)(id _Nonnull))mapBlock
{
  if (self.value != nil)
  {
    return [Optional with:mapBlock(self.value)];
  }
  return self;
}

- (Optional *)flatMap:(Optional* _Nonnull (^)(id _Nonnull))flatMapBlock
{
  if (self.value != nil)
  {
    return flatMapBlock(self.value);
  }
  return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, the &lt;code&gt;with:&lt;/code&gt; class method will create an &lt;code&gt;Optional&lt;/code&gt; object by wrapping some other object, of unspecified class: because there&amp;rsquo;s no true &lt;em&gt;generics&lt;/em&gt; in Objective-C, we won&amp;rsquo;t be able to make our Optional type as type-safe as in Swift, but as we&amp;rsquo;ll see, it won&amp;rsquo;t be a big deal and we&amp;rsquo;ll still be able to get some really &lt;strong&gt;powerful features&lt;/strong&gt;. The &lt;code&gt;map:&lt;/code&gt; method will check if the wrapped object is not nil, and apply the transformation expressed by the &lt;code&gt;mapBlock&lt;/code&gt; block only if the object is actually there: in this case, Objective-C nullability specifiers really help us in designing our APIs, because we clearly specified that &lt;code&gt;mapBlock&lt;/code&gt; will accept and will return non-nil objects only. The &lt;code&gt;flatMapBlock&lt;/code&gt; block will return instead another &lt;code&gt;Optional&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can test this by essentially recreating the same Swift example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Test : NSObject

+ (void)testOptional;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.m

#import &amp;quot;Test.h&amp;quot;
#import &amp;quot;Optional.h&amp;quot;

@implementation Test

+ (void)testOptional
{
  Optional* optionalInt = [self makeOptionalIntFrom:@3 ifTrue:YES];
  Optional* optionalDoubledString = [[optionalInt
                                      map:[self doubled]]
                                     map:[self toString]];
  NSLog(@&amp;quot;%@&amp;quot;, optionalDoubledString);
}

+ (Optional*)makeOptionalIntFrom:(NSNumber*)fromInt ifTrue:(BOOL)ifTrue
{
  return [Optional with:ifTrue ? fromInt : nil];
}


+ (NSNumber*(^)(NSNumber*))doubled
{
  return ^NSNumber*(NSNumber* value)  {
    return @(value.integerValue*2);
  };
}

+ (NSString*(^)(NSNumber*))toString
{
  return ^NSString*(NSNumber* value)  {
    return [NSString stringWithFormat:@&amp;quot;%@&amp;quot;, value];
  };
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we applied our transformations, we need a way to &lt;em&gt;unwrap&lt;/em&gt; the object inside our &lt;code&gt;Optional&lt;/code&gt;: in Swift this is done at language level, with some syntactic sugar, while in Objective-C we can follow the standard conventions of the functional programming community, that is, we can &lt;em&gt;get&lt;/em&gt; the wrapped object via a &lt;code&gt;get&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id _Nullable)get;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)get
{
  return self.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course the &lt;code&gt;get&lt;/code&gt; method will return an &lt;code&gt;id _Nullable&lt;/code&gt;, which means that the returned object can (obviously) be nil. A frequent pattern when dealing with &lt;code&gt;nil&lt;/code&gt; objects is replacing them with &amp;ldquo;default&amp;rdquo; versions: that can be useful when we don&amp;rsquo;t really care about the data contained in an object, but we don&amp;rsquo;t want to be exposed to the risk of possibly null references. Once again, with the &lt;code&gt;Optional&lt;/code&gt; class we can avoid conditional statements and express the &amp;ldquo;defaulting&amp;rdquo; mechanism in a more declarative way: we just need to add a &lt;code&gt;getOrElse:&lt;/code&gt; method, that will return the wrapped object if it&amp;rsquo;s there, or will return a default object, that we&amp;rsquo;ll pass to the method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id)getOrElse:(id(^)())elseBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)getOrElse:(id  _Nonnull (^)())elseBlock
{
  if (self.value != nil)
  {
    return self.value;
  }
  return elseBlock();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, &lt;code&gt;getOrElse:&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; return a &lt;code&gt;_Nullable&lt;/code&gt; object, and that&amp;rsquo;s thanks to &lt;code&gt;elseBlock&lt;/code&gt;: we&amp;rsquo;re not passing the actual default object here, but a block that will produce one; this way, we can get the default object &lt;strong&gt;lazily&lt;/strong&gt;, because if the wrapped object is not nil, the default object doesn&amp;rsquo;t need to be allocated.&lt;/p&gt;

&lt;p&gt;For the rest of the article we&amp;rsquo;ll work on a more real-world example, and in doing so we&amp;rsquo;ll add more features to the &lt;code&gt;Optional&lt;/code&gt; class, making it more and more powerful.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;example-a-json-parser&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;example-a-json-parser:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Example: a JSON parser&lt;/h2&gt;

&lt;p&gt;Suppose we want to create an app that shows movie informations: we are retrieving those informations in JSON format from a website like &lt;a href=&#34;http://api.myapifilms.com&#34;&gt;myapifilms&lt;/a&gt;. Each movie has a JSON representation like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
    &amp;quot;countries&amp;quot;: [
        &amp;quot;USA&amp;quot;
    ],
    &amp;quot;directors&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;filmingLocations&amp;quot;: [
        &amp;quot;St. Croix&amp;quot;,
        &amp;quot;U.S. Virgin Islands&amp;quot;
    ],
    &amp;quot;genres&amp;quot;: [
        &amp;quot;Crime&amp;quot;,
        &amp;quot;Drama&amp;quot;
    ],
    &amp;quot;idIMDB&amp;quot;: &amp;quot;tt0111161&amp;quot;,
    &amp;quot;languages&amp;quot;: [
        &amp;quot;English&amp;quot;
    ],
    &amp;quot;metascore&amp;quot;: &amp;quot;80/100&amp;quot;,
    &amp;quot;originalTitle&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;plot&amp;quot;: &amp;quot;Andy Dufresne is a young and successful banker whose life changes drastically when he is convicted and sentenced to life imprisonment for the murder of his wife and her lover. Set in the 1940s, the film shows how Andy, with the help of his friend Red, the prison entrepreneur, turns out to be a most unconventional prisoner.&amp;quot;,
    &amp;quot;ranking&amp;quot;: 1,
    &amp;quot;rated&amp;quot;: &amp;quot;R&amp;quot;,
    &amp;quot;rating&amp;quot;: &amp;quot;9.3&amp;quot;,
    &amp;quot;releaseDate&amp;quot;: &amp;quot;19941014&amp;quot;,
    &amp;quot;runtime&amp;quot;: [
        &amp;quot;142 min&amp;quot;
    ],
    &amp;quot;simplePlot&amp;quot;: &amp;quot;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;The Shawshank Redemption&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;Movie&amp;quot;,
    &amp;quot;urlIMDB&amp;quot;: &amp;quot;http://www.imdb.com/title/tt0111161&amp;quot;,
    &amp;quot;urlPoster&amp;quot;: &amp;quot;http://ia.media-imdb.com/images/M/MV5BODU4MjU4NjIwNl5BMl5BanBnXkFtZTgwMDU2MjEyMDE@._V1_SX214_AL_.jpg&amp;quot;,
    &amp;quot;votes&amp;quot;: &amp;quot;1,533,914&amp;quot;,
    &amp;quot;writers&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Stephen King&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0000175&amp;quot;
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;year&amp;quot;: &amp;quot;1994&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course we want to define our own internal representation with a value object, change some structure and ignore the parts that we consider not relevant. Here&amp;rsquo;s a possible interface for the &lt;code&gt;Movie&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NS_ASSUME_NONNULL_BEGIN

@interface Movie : NSObject

@property (copy, nonatomic, readonly) NSString* title;
@property (copy, nonatomic, readonly) NSNumber* rating;
@property (copy, nonatomic, readonly) NSNumber* year;
@property (copy, nonatomic, readonly) NSNumber* lengthInMinutes;

+ (Movie*)withJSONDict:(NSDictionary*)dict;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class method &lt;code&gt;withJSONDict:&lt;/code&gt; will create an instance of &lt;code&gt;Movie&lt;/code&gt; from a JSON dictionary like the one showed before: as we can see from the interface declaration, we decided to not allow nil values for any of the properties; but when dealing with JSON, we must consider &lt;strong&gt;every possibility&lt;/strong&gt;, including missing keys, null values or wrong types. We&amp;rsquo;re going to use the &lt;code&gt;Optional&lt;/code&gt; type to parse the JSON dict in a clean, declarative and error-proof way.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with the title. From the JSON, the title should be given by the &amp;ldquo;title&amp;rdquo; key, and should be a string (&lt;code&gt;NSString&lt;/code&gt; in Objective-C), so we can get the title via the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt; NSString* title = [[[[Optional
                        with:[dict objectForKey:@&amp;quot;title&amp;quot;]]
                       
                       flatMap:^Optional*(id title) {
                         return [Optional with:[title isKindOfClass:[NSString class]] ? title : nil];
                       }]
                      
                      flatMap:^Optional*(NSString* title) {
                        return [Optional with:title.length &amp;gt; 0 ? title : nil];
                      }]
                     
                     getOrElse:^NSString*{
                       return @&amp;quot;NO TITLE&amp;quot;;
                     }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first &lt;code&gt;flatMap:&lt;/code&gt; step means that we want the title to be of &lt;code&gt;NSString&lt;/code&gt; class. It&amp;rsquo;s convenient to abstract this operation directly into the &lt;code&gt;Optional&lt;/code&gt; constructor, because we&amp;rsquo;re going to do it all the time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;+ (Optional *)with:(id)value as:(Class)valueClass
{
  if ([value isKindOfClass:valueClass])
  {
    return [Optional with:value];
  }
  return [Optional with:nil];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second &lt;code&gt;flatMap:&lt;/code&gt; step means that if the found string is of length 0 (that is, empty), we are going to treat it as unknown. Actually, this step will act as a &lt;strong&gt;filter&lt;/strong&gt;, because it will only &lt;em&gt;let pass&lt;/em&gt; the strings that are not empty; with that in mind, let&amp;rsquo;s add a &lt;code&gt;filter:&lt;/code&gt; method to the &lt;code&gt;Optional&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (Optional*)filter:(BOOL(^)(id))filterBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (Optional*)filter:(BOOL (^)(id _Nonnull))filterBlock
{
  return [self flatMap:^Optional*(id value) {
    if (filterBlock(value))
    {
      return self;
    }
    else
    {
      return [Optional with:nil];
    }
  }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;filter:&lt;/code&gt; method takes as parameter a block that returns a &lt;code&gt;BOOL&lt;/code&gt; based on the wrapped value: internally, &lt;code&gt;filter:&lt;/code&gt; will actually call &lt;code&gt;flatMap:&lt;/code&gt;, with a conditional expression to check if the &lt;code&gt;filterBlock&lt;/code&gt; succeeds or fails.&lt;/p&gt;

&lt;p&gt;Finally:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[Optional
                       with:[dict objectForKey:@&amp;quot;title&amp;quot;]
                       as:[NSString class]]
                      
                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]
                     
                     getOrElse:^NSString*{ return @&amp;quot;NO TITLE&amp;quot;; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, no conditional statements, and very few lines of code, completely declarative.&lt;/p&gt;

&lt;p&gt;For the &lt;code&gt;rating&lt;/code&gt; and &lt;code&gt;year&lt;/code&gt; parameters we need to add a &lt;code&gt;map&lt;/code&gt; to convert the &lt;code&gt;NSString&lt;/code&gt; into an &lt;code&gt;NSNumber&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* rating = [[[[Optional
                         with:[dict objectForKey:@&amp;quot;rating&amp;quot;]
                         as:[NSString class]]
                        
                        filter:^BOOL(NSString* string) {
                          return string.length &amp;gt; 0;
                        }]
                       
                       map:^NSNumber*(NSString* stringValue) {
                         return [NSDecimalNumber decimalNumberWithString:stringValue];
                       }]
                      
                      getOrElse:^NSNumber*{ return @0; }];
  movie.rating = rating;
  
  NSNumber* year = [[[[Optional
                       with:[dict objectForKey:@&amp;quot;year&amp;quot;]
                       as:[NSString class]]
                      
                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]
                     
                     map:^NSNumber*(NSString* stringValue) {
                       return [NSDecimalNumber decimalNumberWithString:stringValue];
                     }]
                    
                    getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;lenghtInMinutes&lt;/code&gt; parameter is a little tricky; from the JSON we can see that the value is represented like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;runtime&amp;quot;: [ 
	&amp;quot;142 min&amp;quot; 
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we expect an array, of which we&amp;rsquo;re only interested in the first element (thus, the array must not be empty), that has to be a string; of this string we only need the first part, removing the &lt;code&gt;min&lt;/code&gt; portion. Luckily, we already have all the tools for the job:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;  NSNumber* lengthInMinutes =
  [[[[[[Optional
        with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
        as:[NSArray class]]
       
       flatMap:^Optional*(NSArray* array) {
         return [Optional with:[array firstObject]];
       }]
      
      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]
     
     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]
    
    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]
   
   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, something is missing: the method &lt;code&gt;[array firstObject]&lt;/code&gt; returns the first object of the array if the array has at least one element, or nil if the array is empty: there&amp;rsquo;s no indication that the first object is actually a &lt;code&gt;NSString&lt;/code&gt;, so we need to add a &lt;code&gt;filter&lt;/code&gt; step to insure that the object is an instance of the correct class. Let&amp;rsquo;s do it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt; NSNumber* lengthInMinutes =
  [[[[[[[Optional
         with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
         as:[NSArray class]]
        
        flatMap:^id(NSArray* array) {
          return [Optional with:[array firstObject]];
        }]
       
       filter:^BOOL(id value) {
         return [value isKindOfClass:[NSString class]];
       }]
      
      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]
     
     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]
    
    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]
   
   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, when we work with the &lt;code&gt;Optional&lt;/code&gt; class, adding a condition simply means &lt;strong&gt;adding a step&lt;/strong&gt; in the linear &lt;strong&gt;flow of expressions&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusion&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Bringing back the &lt;code&gt;Optional&lt;/code&gt; type from Swift to Objective-C allowed us to build a JSON parsing routine, often something hard to maintain and error-prone, in a simple, linear and readable way. Of course there&amp;rsquo;s &lt;strong&gt;plenty of cases&lt;/strong&gt; where working with optionals can give us the same advantages: by composing &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; operations we can express our intent in a clean and readable way. But this is not just about the &lt;code&gt;Optional&lt;/code&gt; type: some readers may have probably noticed that many languages (including Swift) allow operations with the same names on lists and arrays, and the meanings are also the same: &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;, in particular, are &lt;strong&gt;generic concepts&lt;/strong&gt; related to monads (in fact, the array type is also a monad) and allow declarative compositions of transformations. This concept is at the core of &lt;strong&gt;functional programming&lt;/strong&gt;, and I think there&amp;rsquo;s plenty of reasons to apply similar concepts to a more object-oriented environment: they will help the programmer in reasoning about the code and express the intent in a more declarative way.&lt;/p&gt;

&lt;p&gt;The code for the &lt;code&gt;Optional&lt;/code&gt; class used throughout the article can be found on &lt;a href=&#34;https://gist.github.com/broomburgo/e318228a5f7d6a605e82&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Optionals in Objective-C</title>
      <link>/blog/ita/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/optionals-in-objective-c/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Objective-C vivrà ancora per molto&lt;/strong&gt;. Nonostante Swift sia il nuovo punto di riferimento per lo sviluppo iOS e OS X, ci sono ragioni concrete per scegliere di continuare a sviluppare in Objective-C, almeno per un po&amp;rsquo;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;progetti esistenti basati su Objective-C richiedono ancora mantenimento e probabile aggiunta di nuove funzionalità, e anche se è tecnicamente possibile mescolare i linguaggi, la cosa può risultare &lt;strong&gt;poco conveniente&lt;/strong&gt; per via della natura molto dinamica di Objective-C;&lt;/li&gt;
&lt;li&gt;Swift sta cambiando rapidamente, presenta ancora alcuni bug e &lt;strong&gt;problemi di performance&lt;/strong&gt;, e il suo workflow manca ancora di alcune feature fondamentali per i professionisti, mentre Objective-C è un linguaggio maturo, con una community molto vivace;&lt;/li&gt;
&lt;li&gt;alcuni possono &lt;strong&gt;preferire un linguaggio più dinamico&lt;/strong&gt;, e il supporto di Apple su Objective-C è &lt;a href=&#34;https://netguru.co/blog/objective-c-generics&#34;&gt;ancora forte&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Personalmente ho la tendenza a preferire linguaggi più statici, e un approccio &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;type-first&lt;/a&gt; alla programmazione, ma di tanto in tanto mi piace lavorare in un ambiente più &lt;em&gt;dinamico&lt;/em&gt;, quindi, sia per preferenza personale che per esigenze di business, non ho ancora messo Objective-C da parte. Ma dopo poche settimane di Swift, mi è mancata subito una delle sue funzionalità più potenti: gli &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optionals&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#il-tipo-optional&#34;&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optionals-in-swift&#34;&gt;Optionals in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#torniamo-a-objective-c&#34;&gt;Torniamo a Objective-C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-un-parser-json&#34;&gt;Esempio: un parser JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusione&#34;&gt;Conclusione&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;il-tipo-optional&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-tipo-optional:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt; è un tipo &lt;em&gt;generico&lt;/em&gt; (o, più propriamente, &lt;em&gt;parametrico&lt;/em&gt;), dipendente da un &lt;strong&gt;tipo secondario&lt;/strong&gt;: è possibile ad esempio definire un &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt; oppure un &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt;: la sintassi di Swift permette di scrivere i tipi appena indicati con &lt;code&gt;String?&lt;/code&gt; e &lt;code&gt;Int?&lt;/code&gt;. Ma cos&amp;rsquo;è esattamente un &lt;code&gt;Optional&lt;/code&gt;?. È un tipo particolare che serve a rappresentare un dato che &lt;em&gt;potrebbe&lt;/em&gt; esistere, ed essere quindi di un certo tipo secondario, o potrebbe non esistere, ed essere quindi &lt;strong&gt;nil&lt;/strong&gt;: &lt;em&gt;inscatolando&lt;/em&gt; il valore opzionale in un &lt;code&gt;Optional&lt;/code&gt;, il compilatore di Swift saprà che quel valore potrà essere nil, e emettere un errore nei casi in cui stiamo usando un &lt;code&gt;Optional&lt;/code&gt; dove ci si aspetta un valore &lt;strong&gt;sempre&lt;/strong&gt; presente. Questa semplice funzionalità ci garantisce notevole rigore nella definizione dei nostri tipi di dato e funzione: ad esempio, in Swift non possiamo inizializzare un valore non opzionale con nil, e considerando che, per il compilatore, un valore non può essere usato prima di essere istanziato, se assegniamo il tipo &lt;code&gt;String&lt;/code&gt; a un valore, siamo sicuri al 100% che quel valore sarà &lt;strong&gt;sempre a comunque&lt;/strong&gt; una stringa.&lt;/p&gt;

&lt;p&gt;Al contrario, in Objective-C un oggetto può essere sempre nil, e spesso siamo costretti a controllare l&amp;rsquo;effettiva presenza di un oggetto ogni volta in cui abbiamo bisogno di un&amp;rsquo;istanza che non sia nil. In realtà non si tratta di un grosso problema: è un classico &lt;strong&gt;compromesso&lt;/strong&gt; dei linguaggi dinamici, e il fatto che posso sempre inviare un messaggio a un riferimento nil può essere anche considerato una &lt;em&gt;feature&lt;/em&gt;: usando un linguaggio dinamico, ci si aspetta che progettiamo le nostre API tenendo sempre in considerazione il concetto di &lt;a href=&#34;https://en.wikipedia.org/wiki/Late_binding&#34;&gt;late-binding&lt;/a&gt;. Inoltre, i nuovi &lt;a href=&#34;https://developer.apple.com/swift/blog/?id=25&#34;&gt;&lt;em&gt;nullability specifiers&lt;/em&gt;&lt;/a&gt; di Objective-C aiutano il compilatore a emettere avvisi quando stiamo passando nil a un metodo o una &lt;em&gt;property&lt;/em&gt; che richiedono invece che il parametro sia &lt;code&gt;nonnull&lt;/code&gt;. Ma il problema rimane: abbiamo bisogno di molto &lt;em&gt;boilerplate&lt;/em&gt; per verificare se qualcosa è nil, e ciò può portare a codice poco leggibile e comprensibile, soggetto ad errori. Swift non ha tipicamente bisogno di questo &lt;em&gt;boilerplate&lt;/em&gt; grazie alla natura stessa del tipo &lt;code&gt;Optional&lt;/code&gt;: esso ha le stesse caratteristiche del tipo &lt;code&gt;Maybe&lt;/code&gt; in Haskell, o del tipo &lt;code&gt;Option&lt;/code&gt; in Scala, cioè &lt;code&gt;Optional&lt;/code&gt; è in realtà un &lt;strong&gt;monad&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il concetto di &lt;em&gt;monad&lt;/em&gt; è ereditato, in programmazione funzionale, dalla &lt;a href=&#34;https://it.wikipedia.org/wiki/Teoria_delle_categorie&#34;&gt;teoria delle categorie&lt;/a&gt;, ed è facile trovare &lt;a href=&#34;https://wiki.haskell.org/Monad&#34;&gt;molti&lt;/a&gt; &lt;a href=&#34;https://www.haskell.org/tutorial/monads.html&#34;&gt;testi&lt;/a&gt; &lt;a href=&#34;http://learnyouahaskell.com/a-fistful-of-monads&#34;&gt;introduttivi&lt;/a&gt; sul tema, quindi non approfondirò ulteriormente: dirò solo che un &lt;em&gt;monad&lt;/em&gt; è un &lt;em&gt;contesto computazionale&lt;/em&gt;, quindi una &lt;em&gt;specifica&lt;/em&gt; per il modo in cui una espressione deve essere valutata. Applicare una certa trasformazione a un &lt;em&gt;monad&lt;/em&gt; avrà come risultato un&amp;rsquo;altra istanza dello stesso &lt;em&gt;monad&lt;/em&gt; differente dalla prima, a seconda dello specifico tipo di &lt;em&gt;monad&lt;/em&gt;. Ad esempio, applicare una trasformazione a un &lt;code&gt;Optional&lt;/code&gt; risulterà nell&amp;rsquo;applicazione della stessa trasformazione al valore &lt;em&gt;contenuto&lt;/em&gt;, se presente, o assolutamente niente se l&amp;rsquo;&lt;code&gt;Optional&lt;/code&gt; contiene nil: in entrambi i casi, il risultato della trasformazione sarà un nuovo &lt;code&gt;Optional&lt;/code&gt;, possibilmente con un tipo secondario diverso.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;optionals-in-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;optionals-in-swift:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Optionals in Swift&lt;/h2&gt;

&lt;p&gt;Consideriamo il seguente codice Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?  
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)  
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalString = optionalInt.map(toString)  
print(optionalString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nell&amp;rsquo;esempio, &lt;code&gt;optionalInt&lt;/code&gt; è un &lt;code&gt;Int&lt;/code&gt; &lt;em&gt;contenuto&lt;/em&gt; in un &lt;code&gt;Optional&lt;/code&gt;, che quindi ha tipo &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt; (in Swift è possibile abbreviarlo in &lt;code&gt;Int?&lt;/code&gt;), e applicando ad esso la funzione &lt;code&gt;toString&lt;/code&gt; otteniamo un&amp;rsquo;istanza di &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt;. Possiamo vedere che, per applicare effettivamente la funzione &lt;code&gt;toString&lt;/code&gt;, abbiamo passato la funzione come argomento al metodo &lt;code&gt;map&lt;/code&gt; del &lt;code&gt;Optional&lt;/code&gt;: questa operazione è solitamente chiamata &lt;em&gt;lifting&lt;/em&gt; di una funzione, perché la funzione &lt;code&gt;toString&lt;/code&gt;, di tipo &lt;code&gt;Int -&amp;gt; String&lt;/code&gt;, è &lt;em&gt;sollevata&lt;/em&gt; (&lt;em&gt;lifted&lt;/em&gt;) fino a diventare di tipo &lt;code&gt;Optional&amp;lt;Int&amp;gt; -&amp;gt; Optional&amp;lt;String&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Come possiamo vedere, non sono state usate istruzioni condizionali nel manipolare il valore intero &lt;em&gt;opzionale&lt;/em&gt;: &lt;em&gt;sollevando&lt;/em&gt; le trasformazioni con il metodo &lt;code&gt;map&lt;/code&gt;, possiamo applicarle direttamente alle istanze di &lt;code&gt;Optional&lt;/code&gt;, e possiamo anche concatenarle molto facilmente, ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?  
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)  
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let doubled: Int -&amp;gt; Int = { $0*2 }

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalDoubledString = optionalInt.map(doubled).map(toString)  
print(optionalDoubledString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Volendo esprimere l&amp;rsquo;operazione opposta, avremmo un problema: trasformare una stringa in un intero non è sempre possibile in Swift (ad esempio se non c&amp;rsquo;è alcun numero nella stringa), quindi l&amp;rsquo;operazione stessa risulterebbe in un &lt;code&gt;Optional&lt;/code&gt;. Infatti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalStringFrom(value: String, ifTrue: Bool) -&amp;gt; String?  
{
  return ifTrue ? value : nil
}

let toInt: String -&amp;gt; Int? = { Int($0) }

let anotherOptionalString = makeOptionalStringFrom(&amp;quot;3&amp;quot;, ifTrue: true)

let anotherOptionalInt = anotherOptionalString.map(toInt).map(doubled)
/// errore di compilazione!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il problema qui è che la funzione &lt;code&gt;toInt&lt;/code&gt; è di tipo &lt;code&gt;String -&amp;gt; Optional&amp;lt;Int&amp;gt;&lt;/code&gt;, e il &lt;em&gt;lifting&lt;/em&gt; della funzione verso il &lt;em&gt;mondo opzionale&lt;/em&gt; la trasformerebbe in una funzione del tipo &lt;code&gt;Optional&amp;lt;String&amp;gt; -&amp;gt; Optional&amp;lt;Optional&amp;lt;Int&amp;gt;&amp;gt;&lt;/code&gt;, quindi un intero opzionale contenuto in un altro &lt;code&gt;Optional&lt;/code&gt;; in base alla terminologia accettata, abbiamo bisogno di un&amp;rsquo;operazione di &lt;code&gt;flatMap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let anotherOptionalInt = anotherOptionalString.flatMap(toInt).map(doubled)  
/// funziona
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi, per quanto riguarda il tipo &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; è simile a &lt;code&gt;map&lt;/code&gt;, ma deve essere usato per il &lt;em&gt;lifting&lt;/em&gt; di funzioni che generano altri valori opzionali. Nel leggere il codice, &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt; possono sostanzialmente essere letti nello stesso modo: indicano entrambi una trasformazione, e il fatto che le funzioni passate a &lt;code&gt;flatMap&lt;/code&gt; abbiano un tipo diverso può essere considerato un dettaglio di implementazione.&lt;/p&gt;

&lt;p&gt;In realtà Swift tratta questi tipi di dato &lt;strong&gt;in maniera differente&lt;/strong&gt; rispetto ad altri linguaggi: ad esempio, nei linguaggi &lt;em&gt;funzionali&lt;/em&gt; &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt; sono di norma &lt;em&gt;funzioni libere&lt;/em&gt;, mentre in Swift sono &lt;strong&gt;metodi&lt;/strong&gt;. In generale, Swift incoraggia l&amp;rsquo;uso dei metodi, e del loro &lt;strong&gt;concatenamento&lt;/strong&gt;, invece di funzioni libere, composte con operatori speciali: si tratta, più che altro, di una questione filosofica, ma nel trasportare queste feature in Objective-C l&amp;rsquo;approccio basato sui metodi tornerà utile poiché non c&amp;rsquo;è un modo semplice di rappresentare funzioni libere nel linguaggio, mentre i metodi hanno la classica sintassi alla quale siamo abituati.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;torniamo-a-objective-c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;torniamo-a-objective-c:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Torniamo a Objective-C&lt;/h2&gt;

&lt;p&gt;Implementiamo la classe &lt;code&gt;Optional&lt;/code&gt; in Objective-C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface Optional : NSObject

+ (Optional*)with:(id _Nullable)value;

- (Optional*)map:(id(^)(id))mapBlock;
- (Optional*)flatMap:(Optional*(^)(id))flatMapBlock;

@end

NS_ASSUME_NONNULL_END 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

#import &amp;quot;Optional.h&amp;quot;

@interface Optional ()

@property (strong, nonatomic, nullable) id value;

@end

@implementation Optional

+ (Optional*)with:(id _Nullable)value
{
  Optional* optional = [Optional new];
  optional.value = value;
  return optional;
}

- (Optional *)map:(id  _Nonnull (^)(id _Nonnull))mapBlock
{
  if (self.value != nil)
  {
    return [Optional with:mapBlock(self.value)];
  }
  return self;
}

- (Optional *)flatMap:(Optional* _Nonnull (^)(id _Nonnull))flatMapBlock
{
  if (self.value != nil)
  {
    return flatMapBlock(self.value);
  }
  return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come possiamo vedere, il metodo di classe &lt;code&gt;with:&lt;/code&gt; crea un oggetto &lt;code&gt;Optional&lt;/code&gt; inscatolando un altro oggetto, di tipo non specificato: poiché non esiste un vero concetto di &lt;em&gt;generic&lt;/em&gt; in Objective-C, non sarà possibile realizzare un tipo &lt;code&gt;Optional&lt;/code&gt; sicuro, dal punto di vista dei tipi, come in Swift, ma non sarà un grosso problema, e saremo comunque in grado di ereditare da Swift &lt;strong&gt;potenti features&lt;/strong&gt;. Il metodo &lt;code&gt;map:&lt;/code&gt; verifica se l&amp;rsquo;oggetto contenuto non sia nil, e in tal caso applica la trasformazione espressa con &lt;code&gt;mapBlock&lt;/code&gt;: in questo caso i &lt;em&gt;nullability specifiers&lt;/em&gt; di Objective-C ci hanno aiutato nello scrivere la firma dei metodi, infatti abbiamo chiaramente specificato che &lt;code&gt;mapBlock&lt;/code&gt; accetta e ritorna oggetti che non siano nil; &lt;code&gt;flatMapBlock&lt;/code&gt; ritorna invece un altro &lt;code&gt;Optional&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Possiamo testare la cosa riscrivendo lo stesso esempio visto per Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Test : NSObject

+ (void)testOptional;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.m

#import &amp;quot;Test.h&amp;quot;
#import &amp;quot;Optional.h&amp;quot;

@implementation Test

+ (void)testOptional
{
  Optional* optionalInt = [self makeOptionalIntFrom:@3 ifTrue:YES];
  Optional* optionalDoubledString = [[optionalInt
                                      map:[self doubled]]
                                     map:[self toString]];
  NSLog(@&amp;quot;%@&amp;quot;, optionalDoubledString);
}

+ (Optional*)makeOptionalIntFrom:(NSNumber*)fromInt ifTrue:(BOOL)ifTrue
{
  return [Optional with:ifTrue ? fromInt : nil];
}


+ (NSNumber*(^)(NSNumber*))doubled
{
  return ^NSNumber*(NSNumber* value)  {
    return @(value.integerValue*2);
  };
}

+ (NSString*(^)(NSNumber*))toString
{
  return ^NSString*(NSNumber* value)  {
    return [NSString stringWithFormat:@&amp;quot;%@&amp;quot;, value];
  };
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Un volta applicate le trasformazioni, abbiamo bisogno di un metodo per &amp;ldquo;estrarre&amp;rdquo; l&amp;rsquo;oggetto all&amp;rsquo;interno del &lt;code&gt;Optional&lt;/code&gt;: Swift permette questa operazione a livello di sintassi, mentre in Objective-C possiamo seguire le convenzioni standard in programmazione funzionale, e cioè definire un metodo &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id _Nullable)get;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)get
{
  return self.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo &lt;code&gt;get&lt;/code&gt; ritorna un &lt;code&gt;id _Nullable&lt;/code&gt;: ciò vuol dire che l&amp;rsquo;oggetto ritornato può (ovviamente) essere nil. Un pattern frequente quando si ha a che fare con oggetti nil consiste nel sostituirli con versioni di &amp;ldquo;default&amp;rdquo;: può essere utile quando non ci interessano tanto i dati contenuti in un oggetto, ma non vogliamo correre i rischi associati al lavorare riferimenti &lt;em&gt;null&lt;/em&gt;. Ancora una volta, con la classe &lt;code&gt;Optional&lt;/code&gt; possiamo evitare istruzioni condizionali ed esprimere il meccanismo di &amp;ldquo;defaulting&amp;rdquo; in un modo più dichiarativo: dobbiamo semplicemente aggiungere un metodo &lt;code&gt;getOrElse:&lt;/code&gt;, che ritorni l&amp;rsquo;oggetto contenuto se presente, o un oggetto di default passato al metodo stesso:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id)getOrElse:(id(^)())elseBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)getOrElse:(id  _Nonnull (^)())elseBlock
{
  if (self.value != nil)
  {
    return self.value;
  }
  return elseBlock();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, il metodo &lt;code&gt;getOrElse:&lt;/code&gt; &lt;strong&gt;non&lt;/strong&gt; ritorna un oggetto &lt;code&gt;_Nullable&lt;/code&gt;: in effetti non stiamo passando l&amp;rsquo;oggetto, ma un block che &amp;ldquo;produrrà&amp;rdquo; l&amp;rsquo;oggetto una volta invocato; in questo modo riusciamo a ottenere l&amp;rsquo;oggetto di default in maniera &lt;strong&gt;lazy&lt;/strong&gt;, perché se l&amp;rsquo;oggetto contenuto è presente, non è necessario generare l&amp;rsquo;oggetto di default.&lt;/p&gt;

&lt;p&gt;Per il resto dell&amp;rsquo;articolo lavoreremo su un esempio più concreto, e implementeremo diverse funzionalità per la classe &lt;code&gt;Optional&lt;/code&gt;, rendendola via via più utile e potente.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-un-parser-json&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-un-parser-json:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Esempio: un parser JSON&lt;/h2&gt;

&lt;p&gt;Supponiamo di voler realizzare un&amp;rsquo;app che mostra informazioni sui film: possiamo ottenerle in formato JSON da un sito come &lt;a href=&#34;http://api.myapifilms.com/index.do&#34;&gt;myapifilms&lt;/a&gt;. La rappresentazione JSON di ogni film è del tipo seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
    &amp;quot;countries&amp;quot;: [
        &amp;quot;USA&amp;quot;
    ],
    &amp;quot;directors&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;filmingLocations&amp;quot;: [
        &amp;quot;St. Croix&amp;quot;,
        &amp;quot;U.S. Virgin Islands&amp;quot;
    ],
    &amp;quot;genres&amp;quot;: [
        &amp;quot;Crime&amp;quot;,
        &amp;quot;Drama&amp;quot;
    ],
    &amp;quot;idIMDB&amp;quot;: &amp;quot;tt0111161&amp;quot;,
    &amp;quot;languages&amp;quot;: [
        &amp;quot;English&amp;quot;
    ],
    &amp;quot;metascore&amp;quot;: &amp;quot;80/100&amp;quot;,
    &amp;quot;originalTitle&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;plot&amp;quot;: &amp;quot;Andy Dufresne is a young and successful banker whose life changes drastically when he is convicted and sentenced to life imprisonment for the murder of his wife and her lover. Set in the 1940s, the film shows how Andy, with the help of his friend Red, the prison entrepreneur, turns out to be a most unconventional prisoner.&amp;quot;,
    &amp;quot;ranking&amp;quot;: 1,
    &amp;quot;rated&amp;quot;: &amp;quot;R&amp;quot;,
    &amp;quot;rating&amp;quot;: &amp;quot;9.3&amp;quot;,
    &amp;quot;releaseDate&amp;quot;: &amp;quot;19941014&amp;quot;,
    &amp;quot;runtime&amp;quot;: [
        &amp;quot;142 min&amp;quot;
    ],
    &amp;quot;simplePlot&amp;quot;: &amp;quot;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;The Shawshank Redemption&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;Movie&amp;quot;,
    &amp;quot;urlIMDB&amp;quot;: &amp;quot;http://www.imdb.com/title/tt0111161&amp;quot;,
    &amp;quot;urlPoster&amp;quot;: &amp;quot;http://ia.media-imdb.com/images/M/MV5BODU4MjU4NjIwNl5BMl5BanBnXkFtZTgwMDU2MjEyMDE@._V1_SX214_AL_.jpg&amp;quot;,
    &amp;quot;votes&amp;quot;: &amp;quot;1,533,914&amp;quot;,
    &amp;quot;writers&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Stephen King&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0000175&amp;quot;
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;year&amp;quot;: &amp;quot;1994&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vogliamo definire la nostra rappresentazione interna del film con un &lt;em&gt;value object&lt;/em&gt;, modificare in parte la struttura e magari ignorare alcuni elementi che non consideriamo rilevanti. Ecco un&amp;rsquo;interfaccia possibile per la classe &lt;code&gt;Movie&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NS_ASSUME_NONNULL_BEGIN

@interface Movie : NSObject

@property (copy, nonatomic, readonly) NSString* title;
@property (copy, nonatomic, readonly) NSNumber* rating;
@property (copy, nonatomic, readonly) NSNumber* year;
@property (copy, nonatomic, readonly) NSNumber* lengthInMinutes;

+ (Movie*)withJSONDict:(NSDictionary*)dict;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo di classe &lt;code&gt;withJSONDict:&lt;/code&gt; crea un&amp;rsquo;istanza di &lt;code&gt;Movie&lt;/code&gt; da un dizionario JSON come quello appena mostrato: come si può vedere dall&amp;rsquo;interfaccia dichiarata, abbiamo deciso di non permettere valori nil per le varie &lt;em&gt;property&lt;/em&gt;; ma quando abbiamo a che fare con JSON &lt;strong&gt;tutto può succedere&lt;/strong&gt;, come chiavi mancanti, valori null o di tipo diverso. Useremo il tipo &lt;code&gt;Optional&lt;/code&gt; per parsare il dizionario JSON in modo chiaro, dichiarativo e a prova di errore.&lt;/p&gt;

&lt;p&gt;Iniziamo con i titolo. Dal JSON vediamo che il titolo si trova in corrispondenza della chiave &amp;ldquo;title&amp;rdquo;, e dovrebbe essere una stringa (&lt;code&gt;NSString&lt;/code&gt; in Objective-C), quindi possiamo ottenere il titolo così:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[[Optional
                        with:[dict objectForKey:@&amp;quot;title&amp;quot;]]

                       flatMap:^Optional*(id title) {
                         return [Optional with:[title isKindOfClass:[NSString class]] ? title : nil];
                       }]

                      flatMap:^Optional*(NSString* title) {
                        return [Optional with:title.length &amp;gt; 0 ? title : nil];
                      }]

                     getOrElse:^NSString*{
                       return @&amp;quot;NO TITLE&amp;quot;;
                     }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il primo &lt;code&gt;flatMap&lt;/code&gt; indica che l&amp;rsquo;oggetto &amp;ldquo;titolo&amp;rdquo; deve appartenere alla classe &lt;code&gt;NSString&lt;/code&gt;. Conviene astrarre questa operazione inserendola direttamente nel costruttore, perché l&amp;rsquo;applicheremo ogni volta per tutti i dati:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;+ (Optional *)with:(id)value as:(Class)valueClass
{
  if ([value isKindOfClass:valueClass])
  {
    return [Optional with:value];
  }
  return [Optional with:nil];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il secondo &lt;code&gt;flatMap:&lt;/code&gt; indica che se la stringa trovata ha lunghezza 0, considereremo il titolo come &amp;ldquo;sconosciuto&amp;rdquo;. In effetti questo step avrà l&amp;rsquo;effetto di &amp;ldquo;filtro&amp;rdquo;, perché lascerà &amp;ldquo;passare&amp;rdquo; solo le stringhe non vuote; considerando ciò, aggiungiamo un metodo &lt;code&gt;filter:&lt;/code&gt; alla classe &lt;code&gt;Optional&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (Optional*)filter:(BOOL(^)(id))filterBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (Optional*)filter:(BOOL (^)(id _Nonnull))filterBlock
{
  return [self flatMap:^Optional*(id value) {
    if (filterBlock(value))
    {
      return self;
    }
    else
    {
      return [Optional with:nil];
    }
  }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo &lt;code&gt;filter:&lt;/code&gt; accetta come parametro un block che ritorna un &lt;code&gt;BOOL&lt;/code&gt; basato sul valore contenuto: internamente, &lt;code&gt;filter:&lt;/code&gt; chiamerà comunque &lt;code&gt;flatMap:&lt;/code&gt;, con un&amp;rsquo;espressione condizionale che verifichi se &lt;code&gt;filterBlock&lt;/code&gt; riesce o fallisce.&lt;/p&gt;

&lt;p&gt;Infine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[Optional  
                       with:[dict objectForKey:@&amp;quot;title&amp;quot;]
                       as:[NSString class]]

                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]

                     getOrElse:^NSString*{ return @&amp;quot;NO TITLE&amp;quot;; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi, nessuna espressione condizionale, e poche linee di codice, completamente dichiarative.&lt;/p&gt;

&lt;p&gt;Per quanto riguarda i parametri &lt;code&gt;rating&lt;/code&gt; e &lt;code&gt;year&lt;/code&gt; abbiamo bisogno di un &lt;code&gt;map&lt;/code&gt; che converta &lt;code&gt;NSString&lt;/code&gt; in &lt;code&gt;NSNumber&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* rating = [[[[Optional  
                         with:[dict objectForKey:@&amp;quot;rating&amp;quot;]
                         as:[NSString class]]

                        filter:^BOOL(NSString* string) {
                          return string.length &amp;gt; 0;
                        }]

                       map:^NSNumber*(NSString* stringValue) {
                         return [NSDecimalNumber decimalNumberWithString:stringValue];
                       }]

                      getOrElse:^NSNumber*{ return @0; }];
  movie.rating = rating;

  NSNumber* year = [[[[Optional
                       with:[dict objectForKey:@&amp;quot;year&amp;quot;]
                       as:[NSString class]]

                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]

                     map:^NSNumber*(NSString* stringValue) {
                       return [NSDecimalNumber decimalNumberWithString:stringValue];
                     }]

                    getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il parametro &lt;code&gt;lengthInMinutes&lt;/code&gt; è un po&amp;rsquo; complicato; dal JSON possiamo vedere che la sua rappresentazione è la seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;runtime&amp;quot;: [ 
    &amp;quot;142 min&amp;quot; 
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi ci aspettiamo un array, del quale siamo interessati solo al primo elemento (quindi l&amp;rsquo;array non deve essere vuoto), che deve essere una stringa; di questa stringa abbiamo bisogno solo della prima parte, rimuovendo &lt;code&gt;min&lt;/code&gt;. Fortunatamente abbiamo già tutti gli strumenti necessari per procedere:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* lengthInMinutes =
  [[[[[[Optional
        with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
        as:[NSArray class]]

       flatMap:^Optional*(NSArray* array) {
         return [Optional with:[array firstObject]];
       }]

      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]

     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]

    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]

   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In realtà manca qualcosa: il metodo &lt;code&gt;[array firstObject]&lt;/code&gt; ritorna il primo oggetto dell&amp;rsquo;array se questo ha almeno un elemento, oppure ritorna nil se l&amp;rsquo;array è vuoto: non c&amp;rsquo;è alcuna indicazione sul fatto che vogliamo che il primo elemento sia di tipo &lt;code&gt;NSString&lt;/code&gt;, quindi dobbiamo aggiungere uno step &lt;code&gt;filter&lt;/code&gt; per assicurarci che la classe dell&amp;rsquo;istanza trovata sia corretta. Quindi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* lengthInMinutes =
  [[[[[[[Optional
         with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
         as:[NSArray class]]

        flatMap:^id(NSArray* array) {
          return [Optional with:[array firstObject]];
        }]

       filter:^BOOL(id value) {
         return [value isKindOfClass:[NSString class]];
       }]

      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]

     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]

    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]

   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come possiamo vedere, lavorando con la classe &lt;code&gt;Optional&lt;/code&gt;, aggiungere una condizione significa semplicemente &lt;strong&gt;aggiungere uno step&lt;/strong&gt; nella sequenza lineare di espressioni.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusione:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Conclusione&lt;/h2&gt;

&lt;p&gt;Implementare la classe &lt;code&gt;Optional&lt;/code&gt; in Objective-C ci ha permesso di parsare un JSON, cosa spesso difficile da mantenere e soggetta a errori, in un modo semplice e lineare. In realtà ci sono &lt;strong&gt;molti casi&lt;/strong&gt; in cui lavorare con gli &lt;em&gt;optionals&lt;/em&gt; ci può dare gli stessi vantaggi: componendo operazioni di tipo &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; e &lt;code&gt;filter&lt;/code&gt; possiamo esprimere il nostro intento in maniera chiara e leggibile. Ma tutto questo non riguarda solo il tipo &lt;code&gt;Optional&lt;/code&gt;: alcuni lettori avranno probabilmente notato che molti linguaggi (incluso Swift) permettono operazioni dell stesso tipo su liste e array, e il loro significato è identico: &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt;, in particolare, sono &lt;strong&gt;concetti generici&lt;/strong&gt; legati ai &lt;em&gt;monad&lt;/em&gt; (in effetti, anche il tipo &lt;code&gt;Array&lt;/code&gt; è un &lt;em&gt;monad&lt;/em&gt;), e riguarda la composizione dichiarativa di trasformazioni. Questo concetto è alla base della &lt;strong&gt;programmazione funzionale&lt;/strong&gt;, e penso ci siano molti motivi per applicare concetti simili ad ambienti più &lt;em&gt;object-oriented&lt;/em&gt;, perché aiuterebbero il programmatore a ragionare sul codice ed esprimere l&amp;rsquo;intento in maniera più dichiarativa.&lt;/p&gt;

&lt;p&gt;Il codice per la classe &lt;code&gt;Optional&lt;/code&gt; mostrata nell&amp;rsquo;articolo è reperibile su &lt;a href=&#34;https://gist.github.com/broomburgo/e318228a5f7d6a605e82&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>No Country For If Else</title>
      <link>/blog/ita/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/no-country-for-if-else/</guid>
      <description>

&lt;p&gt;C&amp;rsquo;è un &lt;strong&gt;ospite indesiderato&lt;/strong&gt; che ci accompagna sempre mentre scriviamo codice e realizziamo progetti software: si tratta del &lt;strong&gt;codice già esistente&lt;/strong&gt;, e dobbiamo tener conto della sua complessità man mano che la &lt;em&gt;code base&lt;/em&gt; aumenta di dimensioni. Un&amp;rsquo;elevata complessità del codice può rendere le seguenti attività particolarmente difficili:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;comprendere il significato di codice vecchio, scritto da altri o da se stessi;&lt;/li&gt;
&lt;li&gt;tracciare le cause di bug, cioè errori, nel codice;&lt;/li&gt;
&lt;li&gt;eseguire modifiche a una certa procedura;&lt;/li&gt;
&lt;li&gt;aggiungere funzionalità a strutture già esistenti;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Anche approcciando lo sviluppo di nuovo software con &lt;a href=&#34;https://en.wikipedia.org/wiki/Agile_software_development&#34;&gt;metodologie agili&lt;/a&gt;, dobbiamo comunque fare i conti con il codice esistente, e per farlo dobbiamo almeno essere in grado di &lt;strong&gt;comprenderlo senza sforzi eccessivi&lt;/strong&gt;. Dunque quando parlo di &lt;em&gt;complessità&lt;/em&gt; mi riferisco in particolare alla difficoltà con la quale una programmatore è in grado di &lt;em&gt;ragionare&lt;/em&gt; sul codice. La prefazione del noto testo accademico &lt;a href=&#34;http://deptinfo.unice.fr/~roy/sicp.pdf&#34;&gt;Structure and interpretation of computer programs&lt;/a&gt; contiene la seguente frase:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Non potrei essere più d&amp;rsquo;accordo: il tempo speso da un programmatore a scrivere nuovo codice rappresenta solo &lt;strong&gt;una minima parte&lt;/strong&gt; del suo tempo totale di lavoro; molto tempo è passato a leggere il codice esistente, per correggerlo, estenderlo, modificarlo o semplicemente comprenderlo. Generando codice più comprensibile, sul quale sia più semplice ragionare, possiamo valutare più facilmente la &lt;strong&gt;correttezza&lt;/strong&gt; di quanto abbiamo scritto o, in caso di comportamento non atteso, trovare agevolmente l&amp;rsquo;errore. Ovviamente tutto questo non deve prescindere dalle tecniche che abitualmente utilizziamo per testare la correttezza del software &lt;em&gt;a posteriori&lt;/em&gt;: d&amp;rsquo;altronde, nessuna disciplina tecnico/scientifica è esente da verifiche empiriche, e in effetti l&amp;rsquo;approccio empirico all&amp;rsquo;ingegneria del software è preso in considerazione anche in ambito accademico, come dimostra l&amp;rsquo;&lt;a href=&#34;http://static.springer.com/sgw/documents/1525357/application/pdf/10664_JournalMetrics_Flyer.pdf&#34;&gt;esistenza&lt;/a&gt; della rivista &lt;a href=&#34;http://link.springer.com/journal/10664&#34;&gt;Empirical Software Engineering&lt;/a&gt;. La mia personale posizione è nel mezzo: il testing è importante, ma è anche importante ragionare &lt;em&gt;a priori&lt;/em&gt; sul proprio design, sulla sua correttezza, e sulla presenza di eventuale &lt;strong&gt;complessità accidentale&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice:c252b88516f644ca0545d16795aa645d&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#l-importanza-dell-astrazione&#34;&gt;L&amp;rsquo;importanza dell&amp;rsquo;astrazione&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#misurare-la-complessita&#34;&gt;Misurare la complessità&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-strutturata&#34;&gt;Esempio: soluzione strutturata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-oo&#34;&gt;Esempio: soluzione OO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-funzionale&#34;&gt;Esempio: soluzione funzionale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#una-verifica-empirica&#34;&gt;Una verifica empirica&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusioni&#34;&gt;Conclusioni&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;l-importanza-dell-astrazione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;l-importanza-dell-astrazione:c252b88516f644ca0545d16795aa645d&#34;&gt;L&amp;rsquo;importanza dell&amp;rsquo;astrazione&lt;/h2&gt;

&lt;p&gt;Come abbiamo visto in un &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/&#34;&gt;precedente articolo&lt;/a&gt;, più che della complessità intrinseca legata alla logica del nostro software, dobbiamo preoccuparci della &lt;a href=&#34;http://shaffner.us/cs/papers/tarpit.pdf&#34;&gt;complessità accidentale&lt;/a&gt; che introduciamo adottando &lt;strong&gt;soluzioni non ottimali e inutilmente complicate&lt;/strong&gt;: l&amp;rsquo;utilizzo eccessivo di strutture di controllo &lt;em&gt;if-else-for-switch&lt;/em&gt; tende a rendere il codice difficile da comprendere, da mantenere e da testare; si veda ad esempio il noto &lt;a href=&#34;http://c2.com/cgi/wiki?ArrowAntiPattern&#34;&gt;Arrow Anti-Pattern&lt;/a&gt;. È da notare che l&amp;rsquo;introduzione della &lt;a href=&#34;https://en.wikipedia.org/wiki/Structured_programming&#34;&gt;programmazione &lt;em&gt;strutturata&lt;/em&gt;&lt;/a&gt;, cioè quella basata proprio sulle strutture di controllo appena citate, ha rappresentato &lt;strong&gt;un grande passo avanti&lt;/strong&gt; nello sviluppo del software a cavallo tra gli anni &amp;lsquo;60 e &amp;lsquo;70: essa ha permesso di programmare a un più alto livello di astrazione rispetto allo stile precedente, rimuovendo la necessità di gestire manualmente l&amp;rsquo;ordine di esecuzione del codice con il &lt;a href=&#34;https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF&#34;&gt;famigerato&lt;/a&gt; comando &lt;code&gt;goto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I paradigmi di sviluppo cambiano quando i programmatori si ritrovano a dover gestire progetti sempre più corposi e complessi: per evitare di essere imbrigliati dalla eccessiva complessità del proprio codice, o del codice scritto altri che ci troviamo comunque a mantenere, dobbiamo lavorare a &lt;strong&gt;più alti livelli di astrazione&lt;/strong&gt;. Quanto alti? Una buona risposta a questa domanda potrebbe essere la seguente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;a un elevato livello di astrazione possiamo dire al sistema di fare ciò che vogliamo, senza specificare come farlo&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A un adeguato livello di astrazione possiamo concentrarci sul &lt;em&gt;cosa&lt;/em&gt; lasciando che sia il sistema a decidere il &lt;em&gt;come&lt;/em&gt;. Ovviamente non esiste un &amp;ldquo;massimo&amp;rdquo; livello di astrazione, e in quanto programmatori ci troviamo sempre a lavorare &lt;strong&gt;a metà strada&lt;/strong&gt; tra le cariche elettriche in movimento in un microprocessore, e le necessità di business della nostra azienda: dobbiamo tuttavia essere in grado di identificare i casi nei quali stiamo lavorando a un livello di astrazione troppo basso, poiché a tale livello può aumentare molto il rischio di fare errori e introdurre complessità accidentale. Ad esempio, nel momento in cui usiamo una struttura di controllo come &lt;em&gt;if-else&lt;/em&gt; all&amp;rsquo;interno di una procedura relativamente grande, stiamo &lt;em&gt;manualmente&lt;/em&gt; prendendo una decisione in base allo stato del nostro sistema: molto meglio sarebbe sviluppare un elemento software, ad esempio un oggetto, che sia in grado di &lt;strong&gt;prendere quella decisione al posto nostro&lt;/strong&gt;; il nostro ruolo, a quel punto, sarà &lt;em&gt;dichiarare&lt;/em&gt; la funzionalità di quell&amp;rsquo;elemento. Mescolare il &lt;em&gt;cosa&lt;/em&gt; con il &lt;em&gt;come&lt;/em&gt; è una delle principali cause di difficoltà nel comprendere cosa fa un blocco di codice, perché può portare all&amp;rsquo;oscuramento dell&amp;rsquo;&lt;strong&gt;intento&lt;/strong&gt; di una procedura, legato alla logica di business, con i &lt;strong&gt;dettagli di implementazione&lt;/strong&gt;, che sono concetti separati e spesso del tutto indipendenti (uno stesso intento può essere realizzato con diverse implementazioni a più basso livello).&lt;/p&gt;

&lt;p&gt;Vediamo un semplice esempio. Supponiamo di avere la seguente funzione:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue1(value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	var x: A?
	if cond1 == true {
		if cond2 == true {
			x = nil
		}
		else {
			x = value
		}
	}
	else {
		if cond2 == true {
			x = value
		}
		else {
			x = nil
		}
	}
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anche se la funzione è piuttosto semplice, non è immediatamente evidente cosa stia succedendo; vediamolo passo-passo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;è dichiarata una variabile &lt;code&gt;x&lt;/code&gt; di tipo &lt;code&gt;A?&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;si verifica la prima condizione:

&lt;ul&gt;
&lt;li&gt;se la prima condizione è vera, si verifica la seconda condizione:

&lt;ul&gt;
&lt;li&gt;se la seconda condizione è vera, la variabile è impostata a &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;se la seconda condizione è falsa, la variabile è impostata a &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se la prima condizione è falsa, si verifica la seconda condizione:

&lt;ul&gt;
&lt;li&gt;se la seconda condizione è vera, la variabile è impostata a &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;se la seconda condizione è falsa, la variabile è impostata a  &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;è ritornata la variabile &lt;code&gt;x&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basta pensarci un attimo per capire che, perché a &lt;code&gt;x&lt;/code&gt; venga assegnato &lt;code&gt;value&lt;/code&gt; le due condizioni devono essere semplicemente diverse tra loro. Possiamo inoltre pensare a un&amp;rsquo;altra semplificazione: non è necessario dichiarare la variabile &lt;code&gt;x&lt;/code&gt;, basta ritornare &lt;code&gt;value&lt;/code&gt; se le due condizioni sono diverse, altrimenti ritornare &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue2(value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	return cond1 != cond2 ? value : nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo semplificato molto la funzione, rendendola più facile da comprendere: ora &lt;strong&gt;basta un&amp;rsquo;occhiata&lt;/strong&gt; per capire cosa fa. Ma in un caso più complesso, con tante diverse condizioni e percorsi possibili, può non bastare semplificare le condizioni.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;misurare-la-complessita&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;misurare-la-complessità:c252b88516f644ca0545d16795aa645d&#34;&gt;Misurare la complessità&lt;/h2&gt;

&lt;p&gt;Un&amp;rsquo;unità di misura presa spesso in considerazione nel valutare la complessità di un metodo o una funzione è la &lt;a href=&#34;https://en.wikipedia.org/wiki/Cyclomatic_complexity&#34;&gt;complessità ciclomatica&lt;/a&gt; (CC): essa rappresenta il livello di complessità generato dall&amp;rsquo;uso di molteplici strutture di controllo in un metodo o una funzione. È possibile calcolare il numero di CC per una procedura strutturata rappresentando quest&amp;rsquo;ultima con un &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_graph&#34;&gt;grafo diretto&lt;/a&gt; e contando il numero di archi e nodi. Ad esempio, possiamo rappresentare la funzione &lt;code&gt;optionalValue1&lt;/code&gt; con il seguente grafo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(value,cond1,cond2)]
|
|-&amp;gt; [var x] -&amp;gt; [cond1 == true ?]
               |
               |-y-&amp;gt; [cond2 == true ?]
               |     |
               |     |-y-&amp;gt; [x = nil] --------|
               |     |-n-&amp;gt; [x = value] ------|
               |                             |
               |-n-&amp;gt; [cond2 == true ?]       |
                     |                       |
                     |-y-&amp;gt; [x = value] ------|
                     |-n-&amp;gt; [x = nil] --------|
                                             |-&amp;gt; [return x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per un singolo grafo connesso, il numero di CC è calcolabile in base alla seguente formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC = [numero archi] - [numero nodi] + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per la funzione &lt;code&gt;defaultValue1&lt;/code&gt; si può vedere che CC = 4. Apparentemente la versione semplificata &lt;code&gt;defaulValue2&lt;/code&gt; ha una complessità ciclomatica inferiore, ma in realtà, come indicato anche nella &lt;a href=&#34;http://www.literateprogramming.com/mccabe.pdf&#34;&gt;pubblicazione originale&lt;/a&gt; di T.J.McCabe, CC vale solo per una procedura &lt;em&gt;completamente strutturata&lt;/em&gt;, cioè una procedura con un solo punto di ingresso e un solo punto di uscita; inoltre CC dovrebbe tener conto di &lt;strong&gt;tutti i casi possibili&lt;/strong&gt; quando si verifica una condizione, e &lt;code&gt;if cond1 != cond2&lt;/code&gt; ha appunto 4 casi possibili. Una trattazione delle possibili evoluzioni di CC tenendo conto di molteplici punti di ingresso e uscita per un modulo è disponibile &lt;a href=&#34;http://www.acis.pamplin.vt.edu/faculty/tegarden/wrk-pap/SQJ.PDF&#34;&gt;qui&lt;/a&gt;. Quindi non terremo conto di CC nel resto dell&amp;rsquo;articolo per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la complessità che ci interessa è quella relativa alla &amp;ldquo;comprensibilità&amp;rdquo; di una funzione, e spesso pattern non strutturati (come &lt;code&gt;guard clause&lt;/code&gt;,&lt;code&gt;return&lt;/code&gt; anticipati o &lt;em&gt;conditional expression&lt;/em&gt; come quella prodotta dall&amp;rsquo;operatore ternario &lt;code&gt;?:&lt;/code&gt;) rendono una funzione o un metodo più semplici da capire;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;obiettivo è scrivere un programma componendo tante piccole funzioni la cui complessità sia la &lt;strong&gt;minima possibile&lt;/strong&gt; (nessuna struttura di controllo), quindi avrà poco valore misurare il numero di CC per ogni funzione;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mi è parso comunque importante citare la complessità ciclomatica in questo articolo, ma più che &lt;em&gt;misurare&lt;/em&gt; la complessità accidentale, siamo interessati a &lt;strong&gt;rimuoverla del tutto&lt;/strong&gt;, sostituendo le decisioni condizionali tipiche della programmazione strutturata con qualcos&amp;rsquo;altro. È da notare che una &lt;em&gt;espressione&lt;/em&gt; condizionale rappresenta un concetto &lt;strong&gt;più semplice&lt;/strong&gt; rispetto a una &lt;em&gt;istruzione&lt;/em&gt; condizionale: nel primo caso, l&amp;rsquo;intera espressione ritorna semplicemente un valore in base a una o più condizioni; nel secondo caso, una o più istruzioni potrebbero essere eseguite o meno in base allo stato del sistema.&lt;/p&gt;

&lt;p&gt;Immaginiamo di avere una funzione di questo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func getCorrectValueConsideringConditions &amp;lt;A&amp;gt; (#cond1: Condition&amp;lt;A&amp;gt;, cond2: Condition&amp;lt;A&amp;gt;, cond3: Condition&amp;lt;A&amp;gt; ...) -&amp;gt; A? {
	/// do stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo caso possiamo avere un gran numero di condizioni legate a un valore di tipo &lt;code&gt;A&lt;/code&gt;, e potrebbe essere necessario valutare ciascuna di queste con diversi &lt;em&gt;if-else&lt;/em&gt; e/o &lt;em&gt;switch&lt;/em&gt; annidati. Un modo per risolvere questo problema può consistere nell&amp;rsquo;&lt;em&gt;astrarre&lt;/em&gt; il concetto stesso di &lt;em&gt;condizione&lt;/em&gt;, trasformandolo in una &lt;em&gt;relazione statica&lt;/em&gt; tra un qualche parametro e un valore di tipo &lt;code&gt;A&lt;/code&gt;: dovremmo quindi realizzare un sistema che sia in grado di &lt;em&gt;risolvere&lt;/em&gt; un qualunque numero di relazioni, possibilmente in un &lt;strong&gt;qualunque ordine&lt;/strong&gt;, e in base ad esse dedurre il valore risultante.&lt;/p&gt;

&lt;p&gt;Vediamo un esempio pratico.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-strutturata&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-strutturata:c252b88516f644ca0545d16795aa645d&#34;&gt;Esempio: soluzione strutturata&lt;/h2&gt;

&lt;p&gt;Una persona si reca all&amp;rsquo;ufficio di collocamento per cercare lavoro: in base ad alcuni attributi (preferenze, giovane/anziano, numero di figli di età inferiore ai 18 anni) essa può essere inviata a un certo sportello per selezionare un impiego tra i vari disponibili, oppure mandata fuori dall&amp;rsquo;ufficio nel caso in cui il set di attributi non generi una lista di lavori accettabili. Ecco la procedura completa (non è importante il realismo, è solo un esempio):&lt;/p&gt;

&lt;p&gt;Un persona &lt;strong&gt;p1&lt;/strong&gt; arriva allo sportello &lt;strong&gt;d1&lt;/strong&gt; per cercare un impiego; &lt;strong&gt;p1&lt;/strong&gt; ha una lista di preferenze lavorative, ma potrebbe accettare anche altri lavori fuori lista; &lt;strong&gt;p1&lt;/strong&gt; ha inoltre una lista di lavori che di sicuro non accetterebbe mai;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; è giovane si ottiene da &lt;strong&gt;p1&lt;/strong&gt; una lista &lt;strong&gt;l1&lt;/strong&gt; di preferenze;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;l1&lt;/strong&gt; è troppo piccola, si chiede a &lt;strong&gt;p1&lt;/strong&gt; di ingrandire la lista con preferenze secondarie;&lt;/li&gt;
&lt;li&gt;si inseriscono le preferenze nel sistema e si ottiene una lista &lt;strong&gt;l2&lt;/strong&gt; di posizioni disponibili;&lt;/li&gt;
&lt;li&gt;se la lista &lt;strong&gt;l2&lt;/strong&gt; è vuota, si chiede a &lt;strong&gt;p1&lt;/strong&gt; se vuole visualizzare la lista completa delle posizioni;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d2&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; è anziano, si chiede a &lt;strong&gt;p1&lt;/strong&gt; di scegliere dalla lista &lt;strong&gt;l3&lt;/strong&gt; dei lavori adatti per gli anziani;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d3&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha figli, in ogni caso la lista delle posizioni disponibili sarà influenzata dal numero di figli:

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 1 figlio con età inferiore ai 18 anni, si presenta a &lt;strong&gt;p1&lt;/strong&gt; la lista &lt;strong&gt;l4&lt;/strong&gt; dei lavori adatti al suo caso;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 2 figli con età inferiore ai 18 anni, si presenta a &lt;strong&gt;p1&lt;/strong&gt; la lista &lt;strong&gt;l5&lt;/strong&gt; dei lavori adatti al suo caso;&lt;/li&gt;
&lt;li&gt;nei due casi precedenti, se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d4&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 3 figli o più, &lt;strong&gt;p1&lt;/strong&gt; è inviato allo sportello &lt;strong&gt;d5&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un approccio &amp;ldquo;strutturato&amp;rdquo; al problema può consistere nello scrivere una funzione in cui l&amp;rsquo;intera procedura è espressa con una serie di &lt;em&gt;if-else&lt;/em&gt; e uno &lt;em&gt;switch&lt;/em&gt; (nel caso del numero di figli).&lt;/p&gt;

&lt;p&gt;Il progetto relativo a questo articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/NoCountryForIfElse&#34;&gt;GitHub&lt;/a&gt;: suggerisco di controllare il codice nel progetto man mano che si prosegue nella lettura dell&amp;rsquo;articolo; i file &lt;code&gt;.swift&lt;/code&gt; sono semplici file di testo, e possono essere visualizzati con qualsiasi editor. Nel file &lt;code&gt;common.swift&lt;/code&gt; sono indicate alcune strutture e funzioni comuni tra tutte le soluzioni al problema proposto. In particolare, indicheremo una &amp;ldquo;persona&amp;rdquo; con &lt;code&gt;struct Person&lt;/code&gt;, in sostanza un &lt;em&gt;value object&lt;/em&gt; immutabile che contiene i vari attributi considerati nel problema:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Person {
    
    let name: String
    let isYoung: Bool
    let childrenCount: Int
    let likedJobsMain: [String]
    let likedJobsSecondary: [String]
    let dislikedJobs: [String]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;idea è quella di scrivere una funzione &lt;code&gt;placeNameForPerson&lt;/code&gt; che ritorni il nome della &lt;em&gt;destinazione successiva&lt;/em&gt; per la persona in ingresso al problema: tale destinazione può essere un altro sportello &lt;code&gt;d2,d3,d4,d5&lt;/code&gt; oppure &lt;code&gt;outside&lt;/code&gt; nel caso in cui la persona lasci l&amp;rsquo;ufficio di collocamento senza lavoro. La funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; ritorna appunto il nome del luogo di destinazione della persona in ingresso, e richiede anche un secondo input, un &lt;code&gt;DeskWithJobs&lt;/code&gt; cioè uno sportello con diverse liste di lavori disponibili. Nel caso strutturato, l&amp;rsquo;intera logica di esecuzione è indicata nella funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt;, ed è appunto basata su verifiche condizionali annidate, legate alle caratteristiche dei parametri in ingresso.&lt;/p&gt;

&lt;p&gt;Si vede subito che è piuttosto difficile capire cosa succeda nella funzione semplicemente leggendola: probabilmente, in un &amp;ldquo;vero&amp;rdquo; software, una funzione di questo tipo sarebbe annotata con &lt;strong&gt;un gran numero di commenti&lt;/strong&gt;. Inoltre, si vede facilmente che per tracciare un bug in una funzione del genere sarebbe necessario un debugging passo-passo, perché il gran numero di condizioni espresse rende la funzione sostanzialmente non testabile in maniera efficiente. Infine, se ci trovassimo a dover modificare la procedura, modificando delle condizioni o introducendone altre, avremmo vita dura.&lt;/p&gt;

&lt;p&gt;Il problema di fondo è in realtà dovuto al fatto che, con un approccio strutturato, stiamo &lt;strong&gt;mescolando l&amp;rsquo;intento con l&amp;rsquo;implementazione&lt;/strong&gt;: in questo caso l&amp;rsquo;intento è associare gruppi di condizioni a specifici sportelli &amp;ldquo;target&amp;rdquo;, ma nella soluzione strutturata tali relazioni sono &amp;ldquo;nascoste&amp;rdquo; nel codice e devono essere dedotte da esso; se ad esempio ci venisse chiesto qual è lo sportello per una persona anziana con 2 figli, dovremmo necessariamente seguire il flusso di codice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;poiché la prima condizione è relativa al numero di figli, entriamo subito nel branch &lt;code&gt;childrenCount != 0&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;a questo punto entriamo nel &lt;code&gt;case 2&lt;/code&gt; per il numero di figli;&lt;/li&gt;
&lt;li&gt;c&amp;rsquo;è una condizione in base alla quale il codice verifica che c&amp;rsquo;è un lavoro disponibile;&lt;/li&gt;
&lt;li&gt;a scelta positiva lo sportello di destinazione è il &amp;ldquo;d4&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;dov&amp;rsquo;è la condizione &amp;ldquo;giovane/anziano&amp;rdquo;? C&amp;rsquo;è un bug nel codice? Analizzando il ramo &lt;code&gt;childrenCount == 0&lt;/code&gt; possiamo verificare che tale condizione è effettivamente analizzata, ma è semplicemente irrilevante per l&amp;rsquo;altro ramo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;È una strada relativamente lunga per capire una cosa semplice, ed è da notare che se volessimo fare delle modifiche, dovremmo sempre scorrere nuovamente l&amp;rsquo;intera procedura per verificare che abbiamo coperto tutti i casi possibili, e che non ci siano conflitti o ambiguità.&lt;/p&gt;

&lt;p&gt;Possiamo fare di meglio.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-oo&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-oo:c252b88516f644ca0545d16795aa645d&#34;&gt;Esempio: soluzione OO&lt;/h2&gt;

&lt;p&gt;Progettare una soluzione a oggetti è spesso un&amp;rsquo;operazione &lt;strong&gt;tanto razionale quanto creativa&lt;/strong&gt;: in genere è possibile immaginare moltissimi design OO per risolvere uno stesso problema. Come detto, il nostro intento è di &lt;em&gt;astrarre&lt;/em&gt; il concetto di &lt;em&gt;condizione&lt;/em&gt;; basandoci su questo approccio, proviamo fissare qualche punto, in modo da identificare le responsabilità e i comportamenti da assegnare alla classi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vogliamo essere in grado di rappresentare ciascuna condizione come se fosse un &lt;em&gt;check&lt;/em&gt; separato dagli altri, quindi avremo certamente qualcosa che assomiglia a un tipo &lt;em&gt;Check&lt;/em&gt; caratterizzato da metodi che verificano se una certa persona passa un controllo o no;&lt;/li&gt;
&lt;li&gt;vogliamo rappresentare separatamente i check relativi a un attributo della persona, tipo il numero di figli, da quelli relativi alla lista di lavori tra cui scegliere;&lt;/li&gt;
&lt;li&gt;vogliamo costruire oggetti che siano in grado di combinare più check in un unico check;&lt;/li&gt;
&lt;li&gt;vogliamo creare un oggetto che rappresenti una lista di check e sia in grado di valutare se la persona passi uno dei check della lista, uno e solo uno, oppure non passi alcun check;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il file &lt;code&gt;oo.swift&lt;/code&gt; contiene l&amp;rsquo;implementazione completa della soluzione a oggetti. È definito un &lt;code&gt;protocol PersonCheckType&lt;/code&gt;, cioè un&amp;rsquo;interfaccia che dichiara un metodo &lt;code&gt;personIsValid&lt;/code&gt; che verifica se una certa &lt;code&gt;Person&lt;/code&gt; passa il check:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol PersonCheckType {
    func personIsValid(person: Person) -&amp;gt; Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sono quindi dichiarate alcune classi di tipo &lt;code&gt;PersonCheckType&lt;/code&gt; che permettono di verificare singolarmente ciascun attributo intrinseco di una &lt;code&gt;Person&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Il tipo &lt;code&gt;JobsType&lt;/code&gt; dichiara semplicemente un attributo &lt;code&gt;availableJobs&lt;/code&gt; per raccogliere i lavori disponibili nei vari casi: da esso derivano altri &lt;em&gt;check&lt;/em&gt;, a loro volta di tipo &lt;code&gt;PersonCheckType&lt;/code&gt;, che verificano se una persona sia valida dal punto di vista dei lavori preferiti.&lt;/p&gt;

&lt;p&gt;Infine, il tipo &lt;code&gt;NextDeskType&lt;/code&gt; dichiara un metodo &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; in base al quale è possibile definire quale sia il nome del prossimo sportello per una persona; il metodo ritorna &lt;code&gt;String?&lt;/code&gt; perché per una certa persona potrebbe non essere disponibile alcuno sportello:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol NextDeskType {
    func nextDeskNameForPerson(person: Person) -&amp;gt; String?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dal tipo &lt;code&gt;NextDeskType&lt;/code&gt; deriviamo le seguenti classi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CheckNode&lt;/code&gt;, che rappresenta un nodo nella struttura decisionale del software;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CheckStructure&lt;/code&gt;, che rappresenta l&amp;rsquo;intera struttura di nodi;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In effetti, l&amp;rsquo;implementazione di &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; in &lt;code&gt;CheckStructure&lt;/code&gt; corrisponde esattamente alla soluzione del problema posto: trovare il nome dello sportello di destinazione.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;idea è quella di creare alcuni semplici &lt;strong&gt;check unitari&lt;/strong&gt;, usando le varie classi di tipo &lt;code&gt;PersonCheckType&lt;/code&gt;, e combinare questi check in oggetti concreti di classe &lt;code&gt;CheckNode&lt;/code&gt;, definendo la nostra &lt;code&gt;CheckStructure&lt;/code&gt;. In puro stile OO, abbiamo definito classi chiamate &lt;code&gt;MultipleCheck&lt;/code&gt; e &lt;code&gt;ComposedCheck&lt;/code&gt; per poter comporre più check, e &lt;code&gt;FailingCheck&lt;/code&gt; per poter incapsulare un check di cui si richiede il fallimento. Nessuno dei metodi implementati presenta strutture decisionali che influenzino la &lt;em&gt;business logic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Come esempio si riporta l&amp;rsquo;implementazione della classe &lt;code&gt;ChildrenCountCheck&lt;/code&gt;, che si occupa di verificare se una persona abbia un certo numero di figli:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ChildrenCountCheck: PersonCheckType {
    
    let childrenCount: Int
    init(_ childrenCount: Int) {
        self.childrenCount = childrenCount
    }
    
    func personIsValid(person: Person) -&amp;gt; Bool {
        return person.childrenCount == childrenCount
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;oggetto &lt;code&gt;structure&lt;/code&gt; definito nel file &lt;code&gt;main.swift&lt;/code&gt; presenta la lista delle condizioni, sotto forma di oggetti adeguatamente configurati; come si può vedere, la lista è ben leggibile e le condizioni sono chiare: siamo quindi riusciti a &lt;em&gt;dichiarare&lt;/em&gt; l&amp;rsquo;intento in maniera semplice e separata dai dettagli di implementazione.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-funzionale:c252b88516f644ca0545d16795aa645d&#34;&gt;Esempio: soluzione funzionale&lt;/h2&gt;

&lt;p&gt;Nello strutturare la soluzione OO abbiamo adottato un &lt;strong&gt;principio di composizione&lt;/strong&gt;: oggetti dal comportamento semplice, adeguatamente preparati, composti tra loro per poter ottenere strutture più complesse. In particolare ciascuno dei nostri oggetti rappresenta uno specifico &lt;em&gt;comportamento unitario&lt;/em&gt;, e i vari &lt;em&gt;comportamenti&lt;/em&gt; sono combinati per ottenere un &lt;em&gt;comportamento composto&lt;/em&gt;. &lt;strong&gt;L&amp;rsquo;astrazione regge&lt;/strong&gt;, e riusciamo ad accettare il fatto che gli oggetti &lt;em&gt;check&lt;/em&gt; siano scatole chiuse che incapsulano una singola decisione su una persona: creando una scatola più grande, con dentro scatole più piccole, possiamo rappresentare una condizione più complessa. Tuttavia ci sono due problemi tipici dell&amp;rsquo;approccio OO:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ogni singola classe richiede molto codice solo per costruire l&amp;rsquo;astrazione di &amp;ldquo;decisione nella scatola&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;la composizione tra oggetti è basata sui metodi degli oggetti stessi, la qual cosa comporta, di nuovo, la scrittura di molto codice, che può offuscare l&amp;rsquo;intento;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;È possibile ottenere più chiaramente lo stesso risultato, cioè creare una struttura decisionale complessa a partire da componenti semplici, usando uno stile di &lt;strong&gt;programmazione funzionale&lt;/strong&gt;. Il codice funzionale è descritto nel file &lt;code&gt;functional.swift&lt;/code&gt;. Partiamo sempre dall&amp;rsquo;immutabile &lt;code&gt;struct Person&lt;/code&gt; e definiamo, per comodità, un altro semplice contenitore di dati, &lt;code&gt;struct DeskNode&lt;/code&gt;, che accoppia il nome di un nodo al nome di uno sportello di destinazione. Per il resto, definiremo solo ed esclusivamente funzioni, modellizzando l&amp;rsquo;intero problema con una serie di trasformazioni di dati.&lt;/p&gt;

&lt;p&gt;In questo caso &lt;code&gt;PersonCheck&lt;/code&gt; è &lt;strong&gt;un tipo di funzione&lt;/strong&gt;, che associa una &lt;code&gt;Person&lt;/code&gt; a un &lt;code&gt;Bool&lt;/code&gt;. Definiamo inoltre il tipo di funzione &lt;code&gt;PersonNode&lt;/code&gt;, che associa un certo &lt;code&gt;DeskNode&lt;/code&gt; a una &lt;code&gt;Person&lt;/code&gt;, e che ha sostanzialmente lo scopo che aveva il metodo &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; nella soluzione a oggetti.&lt;/p&gt;

&lt;p&gt;Rappresentiamo infine i vari &amp;ldquo;nodi&amp;rdquo; con una funzione del tipo &lt;code&gt;JobsNode&lt;/code&gt;, che costruisce un &lt;code&gt;PersonNode&lt;/code&gt; in base a un certo &lt;code&gt;PersonCheck&lt;/code&gt;: in questo modo, per costruire una lista di &lt;code&gt;PersonNode&lt;/code&gt; sarà sufficiente applicare i vari &lt;em&gt;check&lt;/em&gt; (&lt;code&gt;PersonCheck&lt;/code&gt;) ai rispettivi nodi (&lt;code&gt;JobsNode&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Il metodo più spesso adottato in programmazione funzionale per comporre le funzioni è quello di definire degli &lt;strong&gt;operatori personalizzati&lt;/strong&gt;. Vogliamo ad esempio comporre i vari &lt;code&gt;PersonCheck&lt;/code&gt; come se componessimo dei semplici &lt;code&gt;Bool&lt;/code&gt;, quindi ad esempio definendo degli operatori &lt;strong&gt;AND&lt;/strong&gt; e &lt;strong&gt;OR&lt;/strong&gt;. Ad imitazione dei classici &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; e &lt;code&gt;||&lt;/code&gt; definiremo rispettivamente gli operatori &lt;code&gt;&amp;lt;&amp;amp;&amp;gt;&lt;/code&gt; e &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, copiando regole di &lt;a href=&#34;https://en.wikipedia.org/wiki/Operator_associativity&#34;&gt;precedenza e associatività&lt;/a&gt; dalla libreria standard. Per migliorare la leggibilità e la chiarezza della composizione tra funzioni, definiremo anche un operatore di &lt;em&gt;applicazione di funzione&lt;/em&gt;, nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;infix operator &amp;lt;*&amp;gt; {
    associativity left
    precedence 100
}
func &amp;lt;*&amp;gt; &amp;lt;A,B&amp;gt; (left: A -&amp;gt; B, right: A) -&amp;gt; B {
    return left(right)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vediamo dalla definizione che l&amp;rsquo;operatore &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; in sostanza &lt;em&gt;applica&lt;/em&gt; un argomento (posizionato a destra dell&amp;rsquo;operatore) a una certa funzione (posizionata a sinistra dell&amp;rsquo;operatore): esso rappresenta quindi un modo alternativo di applicare una funzione rispetto allo scrivere i suoi argomenti &lt;strong&gt;tra parentesi&lt;/strong&gt;, ed è particolarmente adatto a migliorare la leggibilità del codice quando usiamo &lt;a href=&#34;https://en.wikipedia.org/wiki/Higher-order_function&#34;&gt;funzioni di ordine superiore&lt;/a&gt;. Vediamo gli operatori all&amp;rsquo;opera nel file &lt;code&gt;main.swift&lt;/code&gt;, quando definiamo i nostri nodi, ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;node(&amp;quot;old&amp;quot;, nextDeskName: &amp;quot;d3&amp;quot;)
    &amp;lt;*&amp;gt; oldCheck
    &amp;lt;&amp;amp;&amp;gt; mustFail(childrenChecks)
    &amp;lt;&amp;amp;&amp;gt; checkExtendedJobs(availableJobsElderly)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione sopraindicata costruisce un &lt;code&gt;PersonNode&lt;/code&gt; chiamato &lt;em&gt;old&lt;/em&gt; che ritorna lo sportello &lt;em&gt;d3&lt;/em&gt; se la &lt;code&gt;Person&lt;/code&gt; in ingresso rispetta un check composto formato dalle seguenti funzioni:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oldCheck&lt;/code&gt;: la persona è anziana;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mustFail(childrenChecks)&lt;/code&gt;: la persona non deve avere figli;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkExtendedJobs(availableJobsElderly)&lt;/code&gt;: l&amp;rsquo;insieme dei lavori adatti agli anziani e l&amp;rsquo;insieme dei lavori preferiti dalla persona devono avere una qualche intersezione;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A un primo impatto lo stile funzionale può risultare poco comprensibile, ma è sufficiente capire le astrazioni di base sulle quali è realizzata la composizione funzionale per poterne apprezzare &lt;strong&gt;la potenza e l&amp;rsquo;espressività&lt;/strong&gt;. L&amp;rsquo;array &lt;code&gt;nodes&lt;/code&gt;, nel file &lt;code&gt;main.swift&lt;/code&gt;, contiene tutti i nodi del problema, rappresentati come funzioni: rispetto  alla soluzione a oggetti contenuta in &lt;code&gt;structure&lt;/code&gt;, quella funzionale appare più chiara e leggibile.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;una-verifica-empirica&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;una-verifica-empirica:c252b88516f644ca0545d16795aa645d&#34;&gt;Una verifica empirica&lt;/h2&gt;

&lt;p&gt;Nel progettare le soluzioni &amp;ldquo;OO&amp;rdquo; e &amp;ldquo;funzionale&amp;rdquo; si è specificamente scelto di costruire strutture di verifica nelle quali l&amp;rsquo;ordine con il quale i check sono eseguiti fosse irrilevante: in questo modo rimuoviamo una nota causa di complessità accidentale, quella del &amp;ldquo;controllo&amp;rdquo;, e cioè dell&amp;rsquo;&lt;strong&gt;ordine&lt;/strong&gt; con il quale le operazioni sono eseguite (ne abbiamo parlato &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/#cause-di-complessita&#34;&gt;qui&lt;/a&gt;). Per fare ciò è tuttavia necessario che i check presenti nella lista &lt;strong&gt;non siano ambigui&lt;/strong&gt;: al massimo un solo check deve poter passare per una certa persona. Probabilmente sarebbe possibile impostare un &lt;strong&gt;metodo formale&lt;/strong&gt; per poter provare che un determinato set di condizioni sia non-ambiguo, e scrivere quindi un test unitario basato su tale prova, ma in questo caso un approccio &lt;em&gt;empirico&lt;/em&gt; sembra più adatto, e &lt;strong&gt;più semplice&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Si è quindi scelto di procedere seguendo il metodo &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt;: si tratta di una libreria scritta per il linguaggio &lt;a href=&#34;https://www.haskell.org&#34;&gt;Haskell&lt;/a&gt; che permette di testare in modo automatico che le funzioni rispettino determinate &lt;em&gt;proprietà&lt;/em&gt;. L&amp;rsquo;idea è quella di verificare che una funzione si comporti sempre nello stesso modo, testandola con &lt;strong&gt;un gran numero di input casuali&lt;/strong&gt;: nel nostro caso la funzione è proprio la lista di check, e l&amp;rsquo;input è un valore di tipo &lt;code&gt;Person&lt;/code&gt;. Per verificare che i check non siano ambigui possiamo semplicemente provarli con un gran numero di &lt;code&gt;Person&lt;/code&gt; generate casualmente: se per un certo valore di &lt;code&gt;Person&lt;/code&gt; due o più check risultano positivi, l&amp;rsquo;esecuzione del test si interrompe e sono stampati in console i nomi dei check incriminati. Se i check ambigui sono due, sarà sufficiente rendere uno di essi più specifico, ad esempio richiedendo che l&amp;rsquo;altro fallisca. Useremo qui il termine &lt;em&gt;QuickCheck&lt;/em&gt; per indicare il test empirico implementato, ma in realtà la libreria originale fa molto di più: rimando alla pagina &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;linkata&lt;/a&gt; per tutte le informazioni.&lt;/p&gt;

&lt;p&gt;Le funzioni &lt;code&gt;quickCheck_oo&lt;/code&gt; e &lt;code&gt;quickCheck_functional&lt;/code&gt; implementano la funzionalità richiesta: generano un certo numero di &lt;code&gt;Person&lt;/code&gt; casuali, e verificano che il numero di &lt;code&gt;check&lt;/code&gt; superato per ogni &lt;code&gt;Person&lt;/code&gt; sia 0 o 1. Possiamo sfruttare immediatamente questo test aggiungendo un nuovo nodo. Supponiamo ad esempio che a un certo punto, dopo qualche tempo in cui il codice è stato usato con successo per risolvere il problema, si scelga di aggiungere una nuova condizione: è stato appositamente aperto uno sportello per persone anziane con un solo figlio. Si noti come modificare il codice della funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; sarebbe piuttosto complicato: probabilmente dovremmo modificare interi branch decisionali, &lt;strong&gt;aggiungendo la stessa condizione in diversi punti&lt;/strong&gt;, e la probabilità di sbagliare sarebbe molto alta. Con le altre due soluzioni, invece, si tratta semplicemente di aggiungere un nuovo check. Tuttavia, dopo aver aggiunto il nodo, se eseguiamo il programma vedremo che QuickCheck fallirà, stampando il seguente messaggio&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ambiguous nodes: [1 child, 1 child old]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QuickCheck ci sta informando che i nodi chiamati &amp;ldquo;1 child&amp;rdquo; e &amp;ldquo;1 child old&amp;rdquo; sono &lt;strong&gt;ambigui&lt;/strong&gt;: in effetti, se la &lt;code&gt;Person&lt;/code&gt; ha un figlio ed è anziana, passeranno i check per entrambi i nodi. Per risolvere il problema sarà sufficiente introdurre una condizione di fallimento nel nodo &amp;ldquo;1 child&amp;rdquo;: perché esso passi, deve fallire il check di anzianità.&lt;/p&gt;

&lt;p&gt;Nel progetto è implementata anche una funzione &lt;code&gt;quickCheck_consistency&lt;/code&gt; che esegue un test di sicurezza del tipo &lt;em&gt;sanity check&lt;/em&gt;: verifica infatti che lo sportello di destinazione di un gran numero di &lt;code&gt;Person&lt;/code&gt; generate casualmente rimanga lo stesso nei 3 metodi implementati.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusioni&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusioni:c252b88516f644ca0545d16795aa645d&#34;&gt;Conclusioni&lt;/h2&gt;

&lt;p&gt;Abbiamo visto tre metodi per risolvere uno stesso problema relativamente complesso, e in due di essi siamo riusciti a ottenere un sistema &lt;strong&gt;più facilmente gestibile&lt;/strong&gt;, estendibile e modificabile in sicurezza, lavorando a un &lt;strong&gt;più alto livello di astrazione&lt;/strong&gt;. In particolare il metodo &amp;ldquo;funzionale&amp;rdquo; ci ha permesso di scrivere codice più compatto, caratterizzato da un intento più evidente, al costo (basso) di un passo iniziale di astrazione in più, rappresentato dagli operatori personalizzati. Ma la chiave di lettura dell&amp;rsquo;intero processo è ancora una volta da ricercarsi nella già citata frase presente in &lt;em&gt;Structure and Interpretation of Computer Programs&lt;/em&gt;, che riporto nuovamente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Adottando uno stile più &lt;strong&gt;dichiarativo&lt;/strong&gt;, in cui il codice proprio della &lt;em&gt;business logic&lt;/em&gt; &amp;ldquo;dichiara l&amp;rsquo;intento&amp;rdquo;, descrivendo il &amp;ldquo;cosa&amp;rdquo; e non il &amp;ldquo;come&amp;rdquo;, è possibile scrivere software più chiaro e leggibile. Tale software sarà probabilmente anche più &lt;em&gt;testabile&lt;/em&gt;, perché basato su &lt;strong&gt;componenti atomici&lt;/strong&gt; a più basso livello, individualmente facili da testare, che sono combinati attraverso strutture di composizione, anch&amp;rsquo;esse agilmente testabili e provabili. L&amp;rsquo;obiettivo finale è quello di realizzare architetture software che siano in grado di &lt;strong&gt;risolvere automaticamente i problemi&lt;/strong&gt;, descritti nel codice sfruttando gli &lt;strong&gt;elementi costruttivi di base&lt;/strong&gt;. Abbiamo infine visto come un approccio misto tra &amp;ldquo;ragionato&amp;rdquo; e &amp;ldquo;empirico&amp;rdquo; possa garantire ottimi risultati; il ragionamento &lt;em&gt;a priori&lt;/em&gt; e la verifica &lt;em&gt;a posteriori&lt;/em&gt; sono entrambi strumenti utili, ma la loro unione risulta essere particolarmente potente: d&amp;rsquo;altronde, ogni disciplina scientifica richiede sia il ragionamento logico-matematico per la definizione delle teorie, sia la verifica sperimentale per poterne testare la validità.&lt;/p&gt;

&lt;p&gt;Gli strumenti sono a disposizione, basta &lt;strong&gt;iniziare ad usarli&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programmazione Funzionale: perché preoccuparsi?</title>
      <link>/blog/ita/programmazione-funzionale-perche-preoccuparsi/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/programmazione-funzionale-perche-preoccuparsi/</guid>
      <description>

&lt;p&gt;Nel suo discorso di accettazione del &lt;a href=&#34;http://amturing.acm.org/award_winners/dijkstra_1053701.cfm&#34;&gt;Premio Turing 1972&lt;/a&gt;, dal titolo &amp;ldquo;&lt;a href=&#34;https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html&#34;&gt;The humble programmer&lt;/a&gt;&amp;rdquo;, &lt;strong&gt;Edsger Wybe Dijkstra&lt;/strong&gt;, uno dei più celebri &lt;em&gt;computing scientists&lt;/em&gt; del 20° secolo (morto nel 2002), affrontò le cause della nota &lt;a href=&#34;https://it.wikipedia.org/wiki/Software_crisis&#34;&gt;Software Crisis&lt;/a&gt;, cioè la crisi che colpì l&amp;rsquo;industria del software nella seconda metà degli anni sessanta: la potenza e la capacità di elaborazione dei computer stavano &lt;strong&gt;crescendo esponenzialmente&lt;/strong&gt;, molto più rapidamente dell&amp;rsquo;abilità dei programmatori di &lt;strong&gt;gestire la complessità&lt;/strong&gt; e scrivere software funzionante. Nello stesso discorso, Dijkstra propose anche delle possibili strade da intraprendere che a suo avviso avrebbero portato aziende e università a migliorare la qualità del loro software. Riporto qui una frase che a mio parere riassume abbastanza bene l&amp;rsquo;intero discorso:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I now suggest that we confine ourselves to the design and implementation of intellectually manageable programs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Il suggerimento è quindi il seguente: un programmatore dovrebbe limitarsi a lavorare su programmi &lt;strong&gt;intellettualmente gestibili&lt;/strong&gt;, cioè programmi dei quali è possibile stabilire la correttezza semplicemente &lt;strong&gt;attraverso il ragionamento&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#la-software-crisis-nei-decenni&#34;&gt;La &lt;em&gt;Software Crisis&lt;/em&gt; nei decenni&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cause-di-complessita&#34;&gt;Cause di complessità&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pensare-ad-oggetti&#34;&gt;Pensare ad oggetti&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#un-vecchio-paradigma-programmazione-funzionale&#34;&gt;Un vecchio paradigma: Programmazione Funzionale&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;la-software-crisis-nei-decenni&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;la-software-crisis-nei-decenni:ba51084cbefae16f67c65bf54f6283db&#34;&gt;La &lt;em&gt;Software Crisis&lt;/em&gt; nei decenni&lt;/h2&gt;

&lt;p&gt;Molti anni sono passati da allora, e la pratica dello sviluppo software ha attraversato varie evoluzioni e trasformazioni. Rispetto ai tempi di &lt;a href=&#34;https://it.wikipedia.org/wiki/Fortran&#34;&gt;FORTRAN&lt;/a&gt; e &lt;a href=&#34;https://en.wikipedia.org/wiki/ALGOL_60&#34;&gt;Algol 60&lt;/a&gt;, nuovi linguaggi di programmazione sono emersi e si sono affermati come standard; nuove tecniche e paradigmi, come la programmazione orientata agli oggetti, si sono diffuse nell&amp;rsquo;industria del software dopo un lungo periodo di gestazione in &lt;a href=&#34;https://en.wikipedia.org/wiki/Object-oriented_programming#History&#34;&gt;università e centri di ricerca privati&lt;/a&gt;; diversi modi di gestire il processo di realizzazione del software e il suo ciclo di vita sono stati elaborati nei decenni, dal classico modello &lt;a href=&#34;https://en.wikipedia.org/wiki/Waterfall_model&#34;&gt;Waterfall&lt;/a&gt; alle moderne metodologie &lt;a href=&#34;http://engineering.facile.it/un-flusso-di-lavoro-agile/&#34;&gt;Agile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ma &lt;strong&gt;il problema di fondo&lt;/strong&gt; espresso in &lt;em&gt;The humble programmer&lt;/em&gt; è praticamente &lt;strong&gt;rimasto intatto&lt;/strong&gt; nel corso dei decenni: lo sviluppo di funzionalità elaborate e la progettazione di strutture complesse portano al rilascio di software caratterizzato da molti &lt;em&gt;bug&lt;/em&gt;, o per meglio dire, &lt;strong&gt;errori&lt;/strong&gt; dovuti a una difficile, &lt;strong&gt;a volte apparentemente impossibile&lt;/strong&gt;, gestione della complessità. La possibilità di rilasciare software rapidamente e in maniera iterativa ha portato a &lt;strong&gt;integrare&lt;/strong&gt; del tutto questi errori nel processo di sviluppo e rilascio: questa integrazione è realizzata attraverso diverse tecniche, dal &lt;em&gt;debugging&lt;/em&gt;, praticato già dai primissimi programmatori oltre mezzo secolo fa, al &lt;a href=&#34;http://engineering.facile.it/tag/software-testing/&#34;&gt;&lt;em&gt;software testing&lt;/em&gt;&lt;/a&gt;, che permette, in maniera decisamente più efficace rispetto al &lt;em&gt;debugging&lt;/em&gt;, di &lt;strong&gt;identificare gli errori commessi&lt;/strong&gt; e porvi rimedio. Sfortunatamente il &lt;em&gt;testing&lt;/em&gt;, pur essendo una pratica ottima per verificare se ci siano errori in un particolare software, non è sufficiente a &lt;strong&gt;garantire&lt;/strong&gt; che questi errori non ci siano.&lt;/p&gt;

&lt;p&gt;Notiamo inoltre che l&amp;rsquo;idea di integrare gli errori nel processo di &lt;em&gt;design&lt;/em&gt; è una caratteristica praticamente esclusiva dell&amp;rsquo;ingegneria del software, che &lt;strong&gt;la distingue radicalmente&lt;/strong&gt; dalle altre discipline ingegneristiche: in esse, tipicamente, si progettano componenti usando &lt;strong&gt;metodi matematici rigorosi&lt;/strong&gt; o software di calcolo numerico che permettono comunque di ottenere dati molto precisi, e poi si applicano margini di sicurezza per tener conto della variabilità dei processi di sviluppo dei materiali, delle imperfezioni di assemblaggio e delle oscillazioni nelle condizioni di esercizio. Da una parte questa differenza rappresenta &lt;strong&gt;un grande vantaggio&lt;/strong&gt; per l&amp;rsquo;ingegneria del software: non si può &amp;ldquo;iterare&amp;rdquo; nella costruzione di un grattacielo! D&amp;rsquo;altra parte penso sia necessario evitare che lo sviluppo software si trasformi in un banale processo di &lt;em&gt;trial and error&lt;/em&gt; perché, per quanto esso possa dimostrarsi efficace in alcuni casi, spesso &lt;strong&gt;non ci permette di capire razionalmente cosa stiamo facendo&lt;/strong&gt;, e può portare alla produzione di codice instabile e difficilmente gestibile. La verifica &lt;em&gt;a posteriori&lt;/em&gt; attuata grazie al &lt;em&gt;testing&lt;/em&gt; non dovrebbe essere considerata sufficiente a giudicare un software corretto. A mio parere, inoltre, non dovremmo considerare i &lt;em&gt;bug&lt;/em&gt; come se fossero &lt;strong&gt;concetti filosofici&lt;/strong&gt;, necessari e impossibili da eliminare. Ovviamente gli esseri umani compiono errori, ma la differenza tra un comune errore dovuto alle non perfette abilità di una persona, e un bug causato dall&amp;rsquo;eccessiva complessità di un software, è simile alla differenza che c&amp;rsquo;è tra lo scivolare su un pavimento bagnato perché non si è notato il messaggio di avviso, e lo sfracellarsi al suolo dopo aver tentato una scalata difficilissima senza attrezzatura e senza aver alcuna esperienza di montagna: nel secondo caso, &lt;strong&gt;ce la siamo cercata&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In effetti, in un &lt;em&gt;essay&lt;/em&gt; scritto nel 1997 per il libro &lt;a href=&#34;https://books.google.it/books?id=9P5uwNpP1JAC&amp;amp;redir_esc=y&#34;&gt;Beyond Calculation: The Next Fifty Years of Computing&lt;/a&gt;, pubblicato a celebrazione dei primi 50 anni di vita del computer, lo stesso Dijkstra torna ad affrontare il tema della complessità non gestita, suggerendo che &lt;strong&gt;poco è cambiato&lt;/strong&gt; in merito al problema di fondo che già si era presentato più di 50 anni fa. Raccolgo qui poche parole prese dal &lt;em&gt;essay&lt;/em&gt; che, di nuovo, penso ne distillino il succo (grassetto mio):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Computing&amp;rsquo;s core challenge is &lt;strong&gt;how not to make a mess of it&lt;/strong&gt;. [&amp;hellip;] Because we are dealing with artefacts, all unmastered complexity is of our own making; &lt;strong&gt;there is no one else to blame&lt;/strong&gt; and so we had better learn how &lt;strong&gt;not to introduce the complexity in the first place&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a name=&#34;cause-di-complessita&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cause-di-complessità:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Cause di complessità&lt;/h2&gt;

&lt;p&gt;Ma quali sono le cause di tutta questa complessità? La fonte che, a mio parere, affronta in maniera più completa il problema della complessità nel software, proponendo soluzioni concrete, è il bellissimo (e lungo) articolo di Ben Moseley e Peter Marks &amp;ldquo;Out of the Tar Pit&amp;rdquo;(2006), reperibile &lt;a href=&#34;https://www.dropbox.com/s/nov94b39ikijwqd/tarpit.pdf?dl=0&#34;&gt;QUI&lt;/a&gt;. Per poter identificare i punti principali dell&amp;rsquo;articolo dobbiamo intanto dare &lt;strong&gt;una possibile definizione di &amp;ldquo;complessità&lt;/strong&gt;&amp;rdquo;, almeno per quanto riguarda lo sviluppo software; un primo tentativo potrebbe essere il seguente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;la complessità di un software rappresenta la difficoltà nel ragionare sul suo funzionamento&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In base a questa definizione, ad esempio, nel caso in cui un software presenti un qualche errore potremmo giudicare tale software più o meno complesso in base a quanto sia difficile trovare l&amp;rsquo;errore utilizzando il solo ragionamento. Basandoci su questa definizione, possiamo estrapolare da &lt;em&gt;Out of the Tar Pit&lt;/em&gt; due principali cause di complessità:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lo &lt;strong&gt;stato&lt;/strong&gt; delle variabili nel sistema&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;&lt;strong&gt;ordine&lt;/strong&gt; di esecuzione delle procedure&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In sintesi: la mente umana ha relativa difficoltà a tener traccia del modo in cui &lt;strong&gt;evolve nel tempo lo stato di molti parametri&lt;/strong&gt; in base a vari processi di trasformazione, specialmente se tale stato dipende anche &lt;strong&gt;dall&amp;rsquo;ordine in cui questi processi sono eseguiti&lt;/strong&gt;. In realtà riusciamo tranquillamente a gestire processi relativamente semplici attraverso una serie di trasformazioni di stato, si pensi all&amp;rsquo;atto di &amp;ldquo;fare una torta&amp;rdquo;: gli ingredienti di base &amp;ldquo;diventano&amp;rdquo; torta dopo una serie di stadi di trasformazione, che possiamo tranquillamente a tenere a mente, e se il risultato finale non è quello che ci aspettavamo riusciamo rapidamente a identificare l&amp;rsquo;errore nella procedura (la torta è troppo cotta, o abbiamo usato il sale al posto dello zucchero). In effetti seguire l&amp;rsquo;evoluzione di un processo di trasformazione costituito da una serie di procedure è assolutamente &lt;strong&gt;intuitivo&lt;/strong&gt; per la mente umana ed è alla base del paradigma di programmazione noto come &lt;strong&gt;programmazione procedurale&lt;/strong&gt;: nella mia breve esperienza personale ho potuto notare infatti che il metodo più frequentemente adottato nei corsi base di programmazione è proprio quello basato su alberi di scelte binarie &lt;em&gt;if-else&lt;/em&gt;, iterazioni e cicli con una o più condizioni di uscita. Purtroppo è facile osservare che questo modo di ragionare, sebbene sia perfettamente adatto a risolvere molti problemi pratici nella vita di tutti i giorni, &lt;strong&gt;non costituisca una strategia particolarmente efficace&lt;/strong&gt; quando si parla di programmi corposi e complessi, e con &amp;ldquo;corposi&amp;rdquo; intendo &amp;ldquo;più lunghi di un centinaio di righe&amp;rdquo;. È stato necessario introdurre nuove astrazioni, a più alto livello, per riuscire a superare la sempre incombente &lt;em&gt;software crisis&lt;/em&gt;, abbandonando ciò che appare intuitivo in favore di qualcosa di maggiormente gestibile ed efficiente.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;pensare-ad-oggetti&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;pensare-ad-oggetti:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Pensare ad oggetti&lt;/h2&gt;

&lt;p&gt;Vediamo in sintesi come il problema della complessità sia affrontato, a grandi linee, dal più diffuso e importante paradigma di sviluppo software adottato a sostituzione di quello procedurale: la programmazione orientata agli oggetti (&lt;em&gt;Object-Oriented Programming&lt;/em&gt;: &lt;strong&gt;OOP&lt;/strong&gt;). OOP adotta il principio &lt;strong&gt;dell&amp;rsquo;incapsulamento della complessità&lt;/strong&gt;: le varie strutture computazionali del nostro software, individualmente più o meno complesse, sono suddivise in porzioni sufficientemente indipendenti, rinchiuse in contenitori stagni collegati tra loro da interfacce chiare e dichiarative. Si noti intanto che questo &lt;strong&gt;non è&lt;/strong&gt; il modo in cui gli esseri umani agiscono; nel suo classico articolo &lt;a href=&#34;http://c2.com/doc/oopsla89/paper.html&#34;&gt;A Laboratory For Teaching Object-Oriented Thinking (1989)&lt;/a&gt;, il celebre &lt;a href=&#34;https://it.wikipedia.org/wiki/Kent_Beck&#34;&gt;Kent Beck&lt;/a&gt;, noto soprattutto per i fondamentali contributi alle metodologie &lt;a href=&#34;https://it.wikipedia.org/wiki/Extreme_programming&#34;&gt;Extreme Programming&lt;/a&gt; e &lt;a href=&#34;https://it.wikipedia.org/wiki/Test_driven_development&#34;&gt;Test Driven Development&lt;/a&gt;, affronta il problema che si incontra quando si cerca di &lt;strong&gt;insegnare agli studenti a &amp;ldquo;pensare a oggetti&amp;rdquo;&lt;/strong&gt;: come essere umani siamo abituati a pensare allo stato globale di una situazione; a spostarci per comunicare direttamente con chiunque; ad affidarci al modo particolare in cui le persone che conosciamo svolgeranno un certo compito. OOP è invece basato su concetti opposti: ogni oggetto dovrebbe &amp;ldquo;vedere&amp;rdquo; solo i suoi vicini diretti, e di questi non dovrebbe comunque conoscere alcun dettaglio interno. Osserviamo quindi che &lt;strong&gt;il sistema di astrazioni&lt;/strong&gt; su cui OOP è basato non ha nulla a che fare con la vita &amp;ldquo;reale&amp;rdquo; o con il nostro abituale modo di pensare agli oggetti &amp;ldquo;fisici&amp;rdquo;, e a ragione: un software è svariati ordini di grandezza più complesso rispetto a una qualsiasi struttura fisica, e richiede strumenti diversi per poter essere compreso e gestito.&lt;/p&gt;

&lt;p&gt;In effetti un presunto punto di forza di OOP, spesso citato per fornire una prova dell&amp;rsquo;accessibilità di questo paradigma di programmazione, è costituito dall&amp;rsquo;idea che sia possibile trattare gli oggetti nel software come se fossero oggetti reali. Ho potuto osservare, tuttavia, che impostando proprietà e metodi delle classi come se queste fossero &lt;em&gt;template&lt;/em&gt; di oggetti reali, si tende a generare entità eccessivamente interdipendenti e poco flessibili. Questo porta a cadere in &lt;strong&gt;labirinti di complessità&lt;/strong&gt; paragonabili a quelli ottenuti in programmazione procedurale, nei quali lo &lt;strong&gt;stato mutabile&lt;/strong&gt; rende molto difficile la gestione, manutenzione e in generale la comprensibilità del sistema. Quindi spesso i concetti di &amp;ldquo;classe&amp;rdquo; e &amp;ldquo;oggetto&amp;rdquo; sono, purtroppo, &lt;strong&gt;usati in contesti sostanzialmente procedurali&lt;/strong&gt;: non sono rari metodi lunghi centinaia di righe con molti &lt;em&gt;if-else&lt;/em&gt; annidati, o riferimenti a dettagli di implementazione di altri oggetti, che dovrebbero rimanere &amp;ldquo;nascosti&amp;rdquo; al mondo esterno.&lt;/p&gt;

&lt;p&gt;Un tentativo di soluzione a questi problemi è rappresentato dai &lt;strong&gt;design patterns&lt;/strong&gt;, cioè strutture di classi e interfacce che hanno dimostrato &lt;strong&gt;eccellente applicabilità e robustezza&lt;/strong&gt; nell&amp;rsquo;affrontare molti problemi pratici; ma essi sono appunto &lt;em&gt;pattern&lt;/em&gt;, non sono teoremi, la loro capacità di risolvere problemi è verificata dal tempo e dall&amp;rsquo;esperienza, ma essi non permettono in alcun modo di provare in maniera deterministica che un software sia corretto. Il problema di fondo è che, a causa della continua variazione di stato degli oggetti, la struttura di un software scritto in OOP non &lt;strong&gt;può essere rappresentata con un modello matematico&lt;/strong&gt;: funzioni ed equazioni rappresentano relazioni statiche tra variabili dipendenti e indipendenti, con parametri costanti per ogni relazione; variando i parametri, cambia la relazione. Quindi il sistema di astrazioni su cui OOP si basa non può essere descritto dalla matematica. Ma la matematica è proprio l&amp;rsquo;antico e potente strumento utilizzato in qualsiasi disciplina scientifica proprio quando è necessario &lt;strong&gt;fornire prove formali&lt;/strong&gt; della correttezza di sistemi che non possono essere concepiti in maniera dettagliata dalla sola intuizione umana.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;un-vecchio-paradigma-programmazione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;un-vecchio-paradigma-programmazione-funzionale:ba51084cbefae16f67c65bf54f6283db&#34;&gt;Un vecchio paradigma: Programmazione Funzionale&lt;/h2&gt;

&lt;p&gt;La &amp;ldquo;programmazione funzionale&amp;rdquo; (&lt;em&gt;Functional Programming&lt;/em&gt;: &lt;strong&gt;FP&lt;/strong&gt;) è un paradigma di sviluppo software in parte codificato già alla fine degli anni cinquanta, attraverso il noto linguaggio &lt;a href=&#34;https://en.wikipedia.org/wiki/Lisp_(programming_language&#34;&gt;LISP&lt;/a&gt;), e gode di solide basi matematiche nella &lt;a href=&#34;https://en.wikipedia.org/wiki/Combinatory_logic&#34;&gt;logica combinatoria&lt;/a&gt; e nel &lt;a href=&#34;https://en.wikipedia.org/wiki/Lambda_calculus&#34;&gt;lambda calcolo&lt;/a&gt;: malgrado ciò, ha trovato difficoltà nel diffondersi sia nei corsi universitari di base che nelle aziende, forse per &lt;strong&gt;un&amp;rsquo;alta barriera d&amp;rsquo;ingresso&lt;/strong&gt;, dovuta appunto alle forti basi matematiche e alla manipolazione di concetti molto astratti e poco intuitivi.&lt;/p&gt;

&lt;p&gt;FP si basa sull&amp;rsquo;idea che un software possa essere descritto attraverso l&amp;rsquo;applicazione di tre tecniche principali:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la definizione di un gran numero di &lt;strong&gt;funzioni pure&lt;/strong&gt;, cioè funzioni &lt;strong&gt;senza effetti collaterali&lt;/strong&gt;: una funzione pura ritorna &lt;strong&gt;sempre&lt;/strong&gt; un valore, e tale valore è sempre lo stesso &lt;strong&gt;a parità di condizioni di ingresso&lt;/strong&gt;, quindi non potrà mai succedere che una certa funzione ritorni due diversi valori in due diversi momenti nel corso dell&amp;rsquo;esecuzione di un software se non cambiano i dati in ingresso alla funzione;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;applicazione di queste funzioni ai dati soggetti a manipolazione nel nostro software, e la loro combinazione attraverso particolari funzioni note come &lt;strong&gt;funzioni di più altro ordine&lt;/strong&gt;, anch&amp;rsquo;esse pure, che però presentano altre funzioni tra i dati di ingresso e/o di uscita;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;uso di dati &lt;strong&gt;immutabili&lt;/strong&gt; e l&amp;rsquo;assenza di variazione di stato, che permettono di trattare estese porzioni di un software come se fossero &lt;strong&gt;equazioni matematiche&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Funzioni pure, indipendenti dallo stato di esecuzione di un software, rappresentano quindi delle &lt;strong&gt;relazioni statiche tra entità&lt;/strong&gt;: il processo di &lt;em&gt;testing&lt;/em&gt; sarà quindi più semplice perché ogni funzione da testare sarà del tutto indipendente dalle altre. In realtà il &lt;em&gt;testing&lt;/em&gt; in sé non è particolarmente importante in FP, perché tale paradigma si basa sull&amp;rsquo;idea di verificare &lt;em&gt;a priori&lt;/em&gt; che un programma sia corretto. Un software scritto in FP nasce in primo luogo da una costruzione teorica la cui correttezza è verificabile tramite &lt;a href=&#34;http://www.haskellforall.com/2013/12/equational-reasoning.html&#34;&gt;ragionamento equazionale&lt;/a&gt;. Saremo quindi in grado di ottenere un software corretto se:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ciascuna funzione sarà stata implementata correttamente;&lt;/li&gt;
&lt;li&gt;avremo impostato le relazioni corrette tra le entità coinvolte;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In FP le funzioni sono anche &lt;strong&gt;dati&lt;/strong&gt;, nel senso che hanno un &lt;strong&gt;tipo associato&lt;/strong&gt;. Ad esempio, usando la notazione di Swift, possiamo definire il tipo di una funzione &lt;code&gt;square&lt;/code&gt;, che permette di elevare al quadrato un numero intero, nel seguente modo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let square: Int -&amp;gt; Int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Possiamo leggere la definizione di questo &lt;em&gt;type&lt;/em&gt; così: una funzione che prende in ingresso un numero intero e ritorna un numero intero. Se nel software che stiamo scrivendo dovessimo trasformare un &lt;em&gt;array&lt;/em&gt; di numeri interi in un altro array con gli stessi numeri elevati al quadrato, potremmo definire una funzione &lt;code&gt;map&lt;/code&gt; con la seguente notazione:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let map: ([Int], Int -&amp;gt; Int) -&amp;gt; [Int]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Questo &lt;em&gt;type&lt;/em&gt; definisce una funzione che prende in ingresso un &lt;em&gt;array&lt;/em&gt; di numeri interi e una funzione del tipo &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt; (per esempio la funzione &lt;code&gt;square&lt;/code&gt;, definita prima). Abbiamo già visto in un &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;precedente articolo&lt;/a&gt; come &lt;strong&gt;ragionare sui tipi di dati e funzioni coinvolti&lt;/strong&gt; possa semplificare e irrobustire il design di un software: i prossimi articoli di questa serie serviranno da introduzione alla programmazione funzionale, trattando i principali strumenti utilizzati e mostrando un modo meno diffuso &lt;strong&gt;ma forse più efficace&lt;/strong&gt; di gestire la complessità del software.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Type First Development in Swift</title>
      <link>/blog/ita/type-first-development-in-swift/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/type-first-development-in-swift/</guid>
      <description>

&lt;p&gt;Con &lt;em&gt;Type First Development&lt;/em&gt; può intendersi un approccio allo sviluppo di nuove funzionalità o moduli di un software partendo dai &lt;strong&gt;tipi&lt;/strong&gt; di dati coinvolti: non si tratta quindi di un pattern o una pratica codificata, ma solo di &lt;strong&gt;un possibile punto di partenza&lt;/strong&gt; per iniziare il ragionamento. Ragionando esclusivamente sui tipi, prima ancora di pensare alle singole specifiche implementazioni dei vari blocchi di codice, è possibile costruire più facilmente una mappa dei vari di flussi di dati che attraversano il nostro software, e verificare immediatamente se stiamo scrivendo qualcosa di sensato, solido ed adeguatamente estendibile.&lt;/p&gt;

&lt;p&gt;Ragionare sui tipi di dato è un classico approccio usato nel paradigma di programmazione noto come &lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_programming&#34;&gt;&lt;em&gt;programmazione funzionale&lt;/em&gt;&lt;/a&gt;, e il presente articolo adotta tale paradigma in maniera piuttosto pura.&lt;/p&gt;

&lt;h2 id=&#34;indice:9546cc279181b22e90a8ccdde798a866&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#il-type-system-di-swift&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#costruiamo-un-form-il-tipo-field&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#funzioni-generiche-e-composizione-funzionale&#34;&gt;Funzioni generiche e composizione funzionale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#il-tipo-form&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;Modifica di un form e ricerca di un campo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusione&#34;&gt;Conclusione&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;il-type-system-di-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-type-system-di-swift:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/h2&gt;

&lt;p&gt;Il linguaggio &lt;strong&gt;Swift&lt;/strong&gt;, usato nello sviluppo di software per Mac OSX e iOS, si presta molto bene all&amp;rsquo;approccio basato sui tipi illustrato in questo articolo, a causa di due particolari caratteristiche del linguaggio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Type_system#Static_type-checking&#34;&gt;staticamente tipizzato&lt;/a&gt;, cioè ogni parametro, costante o variabile che sia, è caratterizzato da uno specifico tipo, e se una funzione vuole in ingresso un valore di un certo tipo, chiamare la funzione con un valore di un altro tipo risulterà in un errore di compilazione;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Strong_and_weak_typing&#34;&gt;fortemente tipizzato&lt;/a&gt;, cioè non esiste alcuna conversione implicita tra i tipi: ad esempio, in Swift &lt;code&gt;1&lt;/code&gt; è diverso da &lt;code&gt;true&lt;/code&gt; e i due valori non posso essere usati indifferentemente nello stesso contesto;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift è molto rigido, ma è in tale rigore che risiede la sua potenza: usare tipi errati provoca un errore di compilazione, e manipolando adeguatamente i tipi di dato nella costruzione di funzioni è possibile verificare gran parte della correttezza del proprio codice già nella fase di compilazione, evitando potenziali problemi in fase di esecuzione.&lt;/p&gt;

&lt;p&gt;Swift usa molti termini ereditati da C, come &lt;code&gt;struct&lt;/code&gt; e &lt;code&gt;enum&lt;/code&gt;, ma il loro significato è completamente diverso, ad esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;una &lt;code&gt;struct&lt;/code&gt; in Swift può dichiarare metodi ed essere estesa con interfacce;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enum&lt;/code&gt; in Swift è ciò che in altri linguaggi è spesso chiamato &amp;ldquo;sum type&amp;rdquo; o &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Tagged_union&#34;&gt;tagged union&lt;/a&gt;&amp;rdquo;, e a ogni &lt;code&gt;case&lt;/code&gt; possono essere assegnati dei valori associati, ad esempio &lt;code&gt;case Text(String)&lt;/code&gt; rappresenta il caso &lt;code&gt;Text&lt;/code&gt; e ha un valore &lt;code&gt;String&lt;/code&gt; associato.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per illustrare un modo per applicare l&amp;rsquo;approccio &lt;em&gt;Type First&lt;/em&gt; nello sviluppo in Swift inizieremo a scrivere una libreria per gestire &lt;strong&gt;form&lt;/strong&gt;, quindi liste strutturate di campi valorizzati, utili per raccogliere dati degli utenti tramite moduli da compilare, per effettuare sondaggi o inserire i parametri di query a un server.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;costruiamo-un-form-il-tipo-field&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;costruiamo-un-form-il-tipo-field:9546cc279181b22e90a8ccdde798a866&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Un possibile tipo di dato da cui partire è &lt;strong&gt;Field&lt;/strong&gt;, il campo, cioè il mattone costruttivo di base di un form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: String
    let name: String
    let value: String
    let visible: Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Questa definizione di Field è molto basilare, il ché non è un problema nelle prime fasi dello sviluppo, ma &lt;strong&gt;sembra poco estendibile&lt;/strong&gt;, per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; è definito come &lt;code&gt;String&lt;/code&gt; - ad esempio testo inserito dall&amp;rsquo;utente - ma un campo potrebbe contenere altri tipi di valori, ad esempio un checkbox si/no, oppure un preciso valore selezionato da una lista;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;visibile&lt;/code&gt; è definito come &lt;code&gt;Bool&lt;/code&gt;, e vuole indicare se il campo è visibile oppure nascosto, ma se volessimo assegnare altri valori di visibilità, ad esempio &amp;ldquo;evidenziato&amp;rdquo; o &amp;ldquo;oscurato&amp;rdquo; dovremmo aggiungere altri parametri &lt;code&gt;Bool&lt;/code&gt;, che alla fine potrebbero andare in contrasto l&amp;rsquo;uno con l&amp;rsquo;altro;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo risolvere immediatamente il problema, &lt;strong&gt;senza cadere nell&amp;rsquo;eccessiva ottimizzazione preventiva&lt;/strong&gt;, semplicemente modificando il tipo di &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visible&lt;/code&gt; con degli &lt;code&gt;enum&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum FieldValue: Equatable {
    case Text(String)
    case Empty
}

func == (lhs: FieldValue, rhs: FieldValue) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Empty, .Empty):
        return true
    case (.Text(let lhsText), .Text(let rhsText)):
        return lhsText == rhsText
    default:
        return false
    }
}

enum FieldVisibility: Equatable {
    case Visible
    case Hidden
}

func == (lhs: FieldVisibility, rhs: FieldVisibility) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Visible, .Visible), (.Hidden, .Hidden):
        return true
    default:
        return false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo fatto adottare il protocollo &lt;code&gt;Equatable&lt;/code&gt; a entrambi i tipi, in modo da poter confrontare &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visibility&lt;/code&gt; di due campi per verificare se sono uguali: il vantaggio degli &lt;code&gt;enum&lt;/code&gt; è che &lt;strong&gt;possiamo facilmente aggiungere nuovi casi&lt;/strong&gt; senza rompere il codice esistente, ci basterà gestire i nuovi &lt;code&gt;case&lt;/code&gt; via via che vengono aggiunti.&lt;/p&gt;

&lt;p&gt;Un&amp;rsquo;altra piccola modifica utile corrisponde a ridefinire il tipo del parametro &lt;code&gt;id&lt;/code&gt;: a tale parametro deve essere assegnata &lt;strong&gt;una chiave univoca&lt;/strong&gt;, diversa per ogni campo, quindi può convenire definire un tipo &lt;code&gt;UniqueKey&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias UniqueKey = String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift, la keyword &lt;code&gt;typealias&lt;/code&gt; ci permette di definire un &lt;em&gt;alias&lt;/em&gt; di un tipo, cioè un termine che corrisponde esattamente a quel tipo, e permette di:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;migliorare la leggibilità&lt;/strong&gt;, la chiarezza e la compattezza del codice;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;facilitare la manipolazione dei tipi&lt;/strong&gt;, come vedremo a breve;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ogni volta in cui una funzione richiederà &lt;code&gt;UniqueKey&lt;/code&gt; sapremo che in quel campo sarà necessario inserire una stringa univoca, che identifica un particolare campo.&lt;/p&gt;

&lt;p&gt;Definiamo nuovamente &lt;code&gt;Field&lt;/code&gt; incorporando i nuovi tipi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: UniqueKey    
    let name: String
    let value: FieldValue
    let visibility: FieldVisibility
    init (_ id: Key, _ name: String, _ value: FieldValue, _ visibility: FieldVisibility) {
        self.id = id
        self.name = name
        self.value = value
        self.visibility = visibility
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo aggiunto anche un costruttore di convenienza che ci permetterà di creare un &lt;code&gt;Field&lt;/code&gt; semplicemente passando i 4 dati richiesti.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/h2&gt;

&lt;p&gt;La prima e più semplice operazione che vogliamo poter effettuare su &lt;code&gt;Field&lt;/code&gt; è quella di modificarlo in qualche modo: ogni operazione di questo tipo, in Swift, può essere indicata con &lt;code&gt;Field -&amp;gt; Field&lt;/code&gt;, cioè una trasformazione che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e produce un &lt;code&gt;Field&lt;/code&gt; in uscita:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChange = Field -&amp;gt; Field
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;operatore &lt;code&gt;-&amp;gt;&lt;/code&gt; ha lo stesso significato che ha già in &lt;a href=&#34;http://en.wikipedia.org/wiki/Haskell_(programming_language&#34;&gt;Haskell&lt;/a&gt;): definisce il tipo di una funzione che prende in ingresso un dato del tipo indicato a sinistra dell&amp;rsquo;operatore, e ritorna un dato del tipo indicato a destra dell&amp;rsquo;operatore (in questo caso entrambi i dati sono di tipo &lt;code&gt;Field&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;È da evidenziare che &lt;code&gt;FieldChange&lt;/code&gt; non rappresenta un tipo di &amp;ldquo;dato&amp;rdquo; in senso stretto, ma &lt;strong&gt;un tipo di &amp;ldquo;funzione&lt;/strong&gt;&amp;ldquo;: in effetti, definendo &lt;code&gt;FieldChange&lt;/code&gt;, possiamo trattare le funzioni di quel tipo come se fossero dati.&lt;/p&gt;

&lt;p&gt;Per fare un esempio potremmo definire la funzione &lt;code&gt;setVisibility&lt;/code&gt;, che prende in ingresso un valore di &lt;code&gt;FieldVisibility&lt;/code&gt; e ritorna, appunto, un &lt;code&gt;FieldChange&lt;/code&gt;, cioè un&amp;rsquo;altra funzione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibility (visibility: FieldVisibility) -&amp;gt; FieldChange {
    return { field in
        return Field (
            field.id,
            field.name,
            field.value,
            visibility
        )
    }
}

/// alcuni esempi
let setHidden = setVisibility(.Hidden)
let visibleField1 = Field (&amp;quot;&amp;quot;,&amp;quot;&amp;quot;, .Empty, .Visible)
let isTrue1 = visibleField1.visibility == .Visible
let hiddenField1 = setHidden(visibleField1)
let isTrue2 = hiddenField1.visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Negli esempi mostrati, &lt;code&gt;setHidden&lt;/code&gt; è una funzione ma dal punto di vista sintattico è indistinguibile da un qualsiasi altro valore, e il suo tipo (cioè &lt;code&gt;FieldChange&lt;/code&gt;) è dedotto dal compilatore di Swift in base alla definizione della funzione.&lt;/p&gt;

&lt;p&gt;Una funzionalità che vogliamo certamente introdurre nella libreria corrisponde al poter operare una trasformazione su un campo in base a un qualche parametro definito in un altro campo: ad esempio, un particolare campo mostra un check che permette di mostrare/nascondere altri campi. Definiamo quindi un nuovo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChangeGenerator = Field -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è il tipo di una funzione dalla quale otteniamo, in base allo stato un certo campo origine, una certa trasformazione di tipo &lt;code&gt;FieldChange&lt;/code&gt;, cioè qualcosa che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e ritorna un &lt;code&gt;Field&lt;/code&gt; in uscita: si tratta quindi di una funzione che ritorna un&amp;rsquo;altra funzione, di tipo diverso. Vorremmo ad esempio poter scrivere una funzione del tipo &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, che imposta un valore di visibilità in base allo stato di un campo origine: ok, ma quale valore di visibilità? Dipende dal campo origine, e possiamo risolvere il problema definendo un nuovo tipo di funzione, che prende in ingresso un campo, e ritorna un valore di visibilità:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition = Field -&amp;gt; FieldVisibility
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La nostra funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt; semplicemente prenderà ingresso un dato di tipo &lt;code&gt;FieldCondition&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition) -&amp;gt; FieldChangeGenerator {
    return { origin in
        let newVisibility = condition(origin)
        return setVisibility(newVisibility)
    }
}

/// alcuni esempi

let setVisibleIfNotEmpty = setVisibilityIfOrigin { field in
    switch field.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
}

let nonEmptyField = Field (&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, .Text(&amp;quot;something&amp;quot;), .Visible)

let anotherVisibleField = setVisibleIfNotEmpty(nonEmptyField)(invisibleField)

let isTrue3 = anotherVisibleField.visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;funzioni-generiche-e-composizione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;funzioni-generiche-e-composizione-funzionale:9546cc279181b22e90a8ccdde798a866&#34;&gt;Funzioni generiche e composizione funzionale&lt;/h2&gt;

&lt;p&gt;In realtà la nostra &lt;code&gt;FieldCondition&lt;/code&gt; sembra essere un po&amp;rsquo; limitata: ritorna un valore di &lt;code&gt;FieldVisibility&lt;/code&gt;, mentre una vera &lt;em&gt;condition&lt;/em&gt; &lt;strong&gt;dovrebbe ritornare un valore generico&lt;/strong&gt;, a seconda dei casi: ad esempio, potrebbe cambiare il &lt;strong&gt;valore&lt;/strong&gt; di un campo bersaglio in base allo stato di un campo origine. L&amp;rsquo;ideale sarebbe scrivere qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition&amp;lt;T&amp;gt; = Field -&amp;gt; T
/// errore di compilazione!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sfortunatamente in Swift non è possibile scrivere dei &lt;code&gt;typealias&lt;/code&gt; generici, ma possiamo facilmente aggirare l&amp;rsquo;ostacolo costruendo una &lt;code&gt;struct&lt;/code&gt; generica che contiene un solo parametro, al quale è assegnata una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct FieldCondition&amp;lt;T&amp;gt; {
    let apply: Field -&amp;gt; T
    init(_ apply: Field -&amp;gt; T) {
        self.apply = apply
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se prima abbiamo scritto semplicemente una funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, l&amp;rsquo;idea è riuscire ora a scrivere &lt;strong&gt;una funzione generica&lt;/strong&gt; &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; che ritorna un &lt;code&gt;FieldChangeGenerator&lt;/code&gt; che trasforma un campo bersaglio rispetto a un certo parametro, definito in base allo stato di un campo origine: come scrivere questa funzione? &lt;strong&gt;Ragioniamo sui tipi&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FieldCondition&amp;lt;T&amp;gt;&lt;/code&gt; è un contenitore per una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è un alias per &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;per completare la catena abbiamo bisogno di una trasformazione del tipo &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; perché unendo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt; e &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; otteniamo appunto &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo scrivere quindi la funzione generica di cui sopra:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setTargetIfOrigin&amp;lt;T&amp;gt; (condition: FieldCondition&amp;lt;T&amp;gt;, generate: T -&amp;gt; FieldChange) -&amp;gt; FieldChangeGenerator {
    return { field in
        return generate(condition.apply(field))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se tutto sembra molto astratto è perché &lt;strong&gt;lo è&lt;/strong&gt;: stiamo gradualmente costruendo degli strumenti di manipolazione dei dati (e delle funzioni, che sono anch&amp;rsquo;esse dati) operando su astrazioni successive.&lt;/p&gt;

&lt;p&gt;Nella funzione &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; c&amp;rsquo;è un parametro &lt;code&gt;generate&lt;/code&gt; che è definito come &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt;: cosa è &lt;code&gt;T&lt;/code&gt;? È semplicemente lo stesso tipo di dato con il quale viene passata la condizione in &lt;code&gt;condition&lt;/code&gt;; se passiamo una condizione sulla visibilità, ad esempio, &lt;code&gt;T&lt;/code&gt; sarà &lt;code&gt;FieldVisibility&lt;/code&gt;: &lt;strong&gt;una funzione generica si specializza nel momento in cui è definito il tipo concreto da assegnare ai tipi generici&lt;/strong&gt;. Volendo fare un esempio concreto, possiamo ridefinire la funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition&amp;lt;FieldVisibility&amp;gt;) -&amp;gt; FieldChangeGenerator {
    return setTargetIfOrigin (condition) { visibility in setVisibility(visibility) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione chiama &lt;code&gt;setTargetIfOrigin&lt;/code&gt;, passando una condizione del tipo &lt;code&gt;FieldCondition&amp;lt;FieldVisibility&amp;gt;&lt;/code&gt;: il secondo parametro dovrà essere quindi una funzione del tipo &lt;code&gt;FieldVisibility -&amp;gt; FieldChange&lt;/code&gt;, e possiamo usare la funzione &lt;code&gt;setVisibility&lt;/code&gt; definita prima. Vediamo qualche altro esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let setVisibleIfNotEmpty = setVisibilityIfOrigin (FieldCondition { origin in
    switch origin.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
})

let copyValue = setTargetIfOrigin (FieldCondition { $0.value}) { value in
    return { target in
        return Field(target.id,target.name,value,target.visibility)
    }
}

let field1 = Field(&amp;quot;field1&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;1&amp;quot;),.Visible)
let field2 = Field(&amp;quot;field2&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;2&amp;quot;),.Visible)

let newField1 = copyValue(field2)(field1)

let isTrue4 = newField1.value == .Text(&amp;quot;2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Può essere interessante spendere qualche parola per la funzione &lt;code&gt;copyValue&lt;/code&gt; definita nell&amp;rsquo;esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la condizione è chiaramente del tipo &lt;code&gt;FieldCondition&amp;lt;FieldValue&amp;gt;&lt;/code&gt; perché la &lt;em&gt;closure&lt;/em&gt; passata ritorna il &lt;code&gt;value&lt;/code&gt; del campo;&lt;/li&gt;
&lt;li&gt;nella seconda &lt;em&gt;closure&lt;/em&gt; passata, il valore è usato per costruire un nuovo campo, uguale al bersaglio tranne proprio per quel valore;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quindi &lt;code&gt;copyValue&lt;/code&gt;, che ricordiamo è di tipo &lt;code&gt;FieldChangeGenerator&lt;/code&gt;, è una trasformazione che prende il valore di un campo origine e lo assegna a un campo bersaglio.&lt;/p&gt;

&lt;p&gt;Nel caso in cui avessimo una serie di campi e volessimo applicare una certa trasformazione a un solo campo particolare, avremmo bisogno di un check sul campo bersaglio. Come al solito, pensiamo prima al &lt;strong&gt;tipo&lt;/strong&gt; di questo check: sarà qualcosa che prende un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un altro &lt;code&gt;FieldChange&lt;/code&gt;, che potrebbe essere uguale a quello in ingresso, oppure diverso in base a una certa condizione applicata al campo bersaglio.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCheck = FieldChange -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per quanto riguarda la condizione, possiamo usare lo stesso FieldCondition&lt;T&gt; di prima, ma in questo caso lo specializzeremo direttamente in &lt;code&gt;FieldCondition&amp;lt;Bool&amp;gt;&lt;/code&gt; perché quello che ci interessa sapere è se un certo campo bersaglio è interessato oppure no da una certa trasformazione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldConditionBool = FieldCondition&amp;lt;Bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Definiamo quindi una funzione &lt;code&gt;checkTarget&lt;/code&gt; che prende in ingresso una condizione, e ritorna un &lt;code&gt;FieldCheck&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func checkTarget (condition: FieldConditionBool) -&amp;gt; FieldCheck {
    return { change in
        return { field in
            if condition.apply(field) {
                return change(field)
            }
            else {
                return field
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nel definire &lt;code&gt;checkTarget&lt;/code&gt; possiamo vedere un altro caso in cui ragionare solo sui tipi ci aiuta a capire cosa poi dobbiamo effettivamente fare nel codice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la funzione deve ritornare un dato di tipo &lt;code&gt;FieldCheck&lt;/code&gt;, che è una funzione che prende in ingresso un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, quindi la prima riga della funzione è appunto &lt;code&gt;return { change in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldCheck&lt;/code&gt; è una funzione che ritorna un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, che come definito prima corrisponde a una funzione che prende in ingresso un &lt;code&gt;Field&lt;/code&gt;, quindi la seconda riga è &lt;code&gt;return { field in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChange&lt;/code&gt; deve ritornare un &lt;code&gt;Field&lt;/code&gt;, ma a questo punto possiamo applicare la nostra condizione sul campo in ingresso: se la condizione è verificata allora ritorniamo il campo trasformato, mentre se non lo è &amp;ldquo;facciamo uscire&amp;rdquo; il campo esattamente come è &amp;ldquo;entrato&amp;rdquo;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Come si può vedere, abbiamo iniziato a implementare funzioni ragionando quasi esclusivamente sui tipi coinvolti. Vediamo alcuni esempi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ifTargetId (id: UniqueKey) -&amp;gt; FieldCheck {
    return checkTarget (FieldCondition { $0.id == id })
}

let visibleField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field1)
let hiddenField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field2)

let isTrue5 = visibleField.visibility == .Visible
let isTrue6 = hiddenField.visibility == .Hidden

let fields = [field1,field2]
let newFields = fields.map(ifTargetId(&amp;quot;field2&amp;quot;)(setHidden))

let isTrue7 = newFields[0].visibility == .Visible
let isTrue8 = newFields[1].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;il-tipo-form&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-tipo-form:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Abbiamo implementato quindi alcuni strumenti per manipolare i singoli campi: a questo punto proviamo a unire il tutto definendo un &lt;code&gt;Form&lt;/code&gt; come contenitore strutturato di campi, insieme ad alcune funzioni di manipolazione. Intanto &lt;strong&gt;pensiamo al tipo da assegnare al nostro form&lt;/strong&gt;: una possibilità è quella di definire alcuni blocchi costruttivi che ne descrivono la struttura:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// sezione: è una semplice lista di campi
struct Section {
    let fields: [Field]
}

/// step: un gruppo di sezioni, ad esempio una pagina
struct Step {
    let sections: [Section]
}

/// form: un insieme di pagine
struct Form {
    let steps: [Step]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ci sono però due problemi con questo approccio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stiamo prematuramente fornendo al nostro form &lt;strong&gt;una struttura rigida&lt;/strong&gt;: se in futuro decidessimo di voler creare una sottostruttura rispetto a &lt;code&gt;Section&lt;/code&gt; sarebbe probabilmente molto complesso modificare il tutto;&lt;/li&gt;
&lt;li&gt;nello scrivere le logiche di ricerca e manipolazione dei campi ci ritroveremmo a dover gestire le &lt;code&gt;struct&lt;/code&gt; appena definite: stiamo quindi automaticamente &lt;strong&gt;accoppiando&lt;/strong&gt; un particolare modello di dati con la logica di manipolazione dei form, che &lt;strong&gt;dovrebbero essere adattabili a più modelli, senza cambiare la logica&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per evitare questi problemi gli approcci possibili sono molti: un&amp;rsquo;opzione, ad esempio, è quella definire un tipo di dato corrispondente a un contenitore &lt;em&gt;ricorsivo&lt;/em&gt; per un valore generico, che chiameremo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Un valore di tipo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; definisce due casi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;branch&lt;/em&gt;, cioè una lista di valori di tipo T;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;root&lt;/em&gt;, cioè una lista di altri &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;enum Node&amp;lt;T&amp;gt; {
    case Branch([T])
    case Root([Node&amp;lt;T&amp;gt;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possiamo quindi definire un &lt;code&gt;Form&lt;/code&gt; come una versione specializzata di &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; dove &lt;code&gt;T&lt;/code&gt; è &lt;code&gt;Field&lt;/code&gt;, e definiremo un paio di funzioni di convenienza per generare un &lt;em&gt;branch&lt;/em&gt; di &lt;code&gt;Field&lt;/code&gt; o una &lt;em&gt;root&lt;/em&gt; di &lt;code&gt;Form&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias Form = Node&amp;lt;Field&amp;gt;

func branch (fields: [Field]) -&amp;gt; Form {
    return Node.Branch(fields)
}

func root (nodes: [Form]) -&amp;gt; Form {
    return Node.Root(nodes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modifica-di-un-form-e-ricerca-di-un-campo:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modifica di un form e ricerca di un campo&lt;/h2&gt;

&lt;p&gt;Come accadeva per &lt;code&gt;Field&lt;/code&gt;, la prima operazione che vogliamo poter effettuare su &lt;code&gt;Form&lt;/code&gt; è quella modificarlo; definiamo quindi il tipo &lt;code&gt;FormChange&lt;/code&gt; in maniera a simile a come avevamo definito &lt;code&gt;FieldChange&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FormChange = Form -&amp;gt; Form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supponiamo ad esempio di avere un form, e voler applicare una modifica a un campo presente nel form, ottenendo un nuovo form con il campo modificato: abbiamo bisogno di una funzione che potremmo chiamare &lt;code&gt;changeFromFieldChange&lt;/code&gt; che prende in ingresso un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un &lt;code&gt;FormChange&lt;/code&gt;; grazie alla struttura ricorsiva del tipo &lt;code&gt;Form&lt;/code&gt; definito, possiamo scrivere in poche righe una funzione che attraversa un form nei suoi vari livelli e lo ricostruisce applicando la modifica passata in ingresso a ogni campo, tenendo eventualmente conto di una certa condizione per verificare se un certo campo è interessato dalla modifica o meno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeFromFieldChange (fieldChange: FieldChange) -&amp;gt; FormChange {
    return { form in
        switch form {
        case .Branch (let fields):
            return branch(fields.map(fieldChange))
        case .Root (let subforms):
            return root(subforms.map(changeFromFieldChange(fieldChange)))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione verifica se un form è del tipo &lt;code&gt;.Branch&lt;/code&gt; o &lt;code&gt;.Root&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nel primo caso, ricostruisce il &lt;em&gt;branch&lt;/em&gt; applicando la funzione &lt;code&gt;FieldChange&lt;/code&gt; in ingresso a ogni campo nel &lt;em&gt;branch&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;nel secondo caso, ricostruisce il &lt;em&gt;root&lt;/em&gt; applicando ricorsivamente la stessa funzione &lt;code&gt;changeFromFieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per migliorare la leggibilità possiamo definire una nuova funzione &lt;code&gt;updateField&lt;/code&gt; identica a &lt;code&gt;changeFromFieldChange&lt;/code&gt; che dichiara &lt;strong&gt;in maniera più espressiva&lt;/strong&gt; il tipo di operazione che vogliamo poter effettuare su un form, e cioè aggiornare un certo campo in base a una certa trasformazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let updateField = changeFromFieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vediamo quindi un esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let form = branch([field1,field2])

let newForm = updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere dall&amp;rsquo;esempio, otteniamo &lt;code&gt;newForm&lt;/code&gt; componendo alcune funzioni definite in precedenza con &lt;code&gt;updateField&lt;/code&gt;: se l&amp;rsquo;id del campo bersaglio è &amp;ldquo;field1&amp;rdquo;, nascondiamo il campo.&lt;/p&gt;

&lt;p&gt;Come verificare se il campo con id &amp;ldquo;field1&amp;rdquo; è effettivamente nascosto? Come ultima operazione vogliamo definire una funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; che ci permetta di cercare uno o più campi in un form in base a una certa condizione: la condizione sarà ancora di tipo &lt;code&gt;FieldConditionBool&lt;/code&gt;, cioè da un campo otteniamo un valore &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt;. Per scrivere la funzione ragioniamo sul tipo di dato ritornato: esso deve corrispondere a una funzione che prende un form e ritorna un array di campi; chiameremo questo tipo &lt;code&gt;FieldGet&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldGet = Form -&amp;gt; [Field]

func fieldsWithCondition (condition: FieldConditionBool) -&amp;gt; FieldGet {
    return { form in
        switch form {
        case .Branch(let fields):
            return fields.filter(condition.apply)
        case .Root(let subforms):
            return subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; opera ricorsivamente, come è ovvio che sia considerando la natura ricorsiva del tipo di dato &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Vediamo qualche applicazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fieldsWithId (id: UniqueKey) -&amp;gt; FieldGet {
    return fieldsWithCondition (FieldConditionBool { $0.id == id })
}

let allFields: FieldGet = fieldsWithCondition (FieldConditionBool { _ in true })

let twoFields = allFields(form)

let isTrue9 = count(twoFields) == 2

let isTrue10 = fieldsWithId(&amp;quot;field1&amp;quot;)(form)[0].visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithId&lt;/code&gt; prende una &lt;code&gt;UniqueKey&lt;/code&gt; e permette di ottenere tutti i campi con quell&amp;rsquo;id (presumibilmente l&amp;rsquo;array risultante conterrà un solo elemento); &lt;code&gt;allFields&lt;/code&gt; genera semplicemente un array con tutti i campi: da notare che la &lt;em&gt;closure&lt;/em&gt; &lt;code&gt;{ _ in true }&lt;/code&gt; ignora il valore in ingresso e ritorna sempre &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Usando &lt;code&gt;fieldsWithId&lt;/code&gt; possiamo infine verificare che il campo con id &amp;ldquo;field1&amp;rdquo; sia effettivamente nascosto, in base alle manipolazioni precedenti:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isTrue11 = fieldsWithId(&amp;quot;field1&amp;quot;)(newForm)[0].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;conclusione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusione:9546cc279181b22e90a8ccdde798a866&#34;&gt;Conclusione&lt;/h2&gt;

&lt;p&gt;Per concludere, abbiamo visto come partendo da &lt;strong&gt;tipi&lt;/strong&gt;, che siano essi relativi a singoli valori o a funzioni, è stato possibile iniziare a scrivere una libreria composta da semplici tipi di base e funzioni elementari che vengono composte via via a livelli di astrazione più alti. Definendo tipi specifici per molte astrazioni siamo riusciti a &lt;strong&gt;gestire meglio la complessità&lt;/strong&gt; inerente nel manipolare e comporre funzioni, al punto da poter &lt;strong&gt;trattare funzioni complesse come semplici dati&lt;/strong&gt; da passare ad altre funzioni. In un articolo successivo vedremo come estendere la libreria qui iniziata, abbracciando completamente la composizione funzionale e usando operatori specificamente definiti per migliorare la chiarezza del codice e rendere più semplice la manipolazione e combinazione delle funzioni.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;Nello scrivere questo articolo si è scelto specificamente di non definire operatori su misura per comporre le funzioni, per evitare un ulteriore appesantimento legato alla presenza di codice dalla sintassi poco familiare. La chiamata di una funzione in Swift è c-like: si scrive il nome della funzione e poi si inseriscono i dati di ingresso tra due parentesi tonde; questo purtroppo può portare a diverse chiamate in parentesi annidate; inoltre, può non risultar chiara una chiamata del tipo &lt;code&gt;updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)&lt;/code&gt;: come accennato, in un articolo futuro vedremo come usare operatori personalizzati per rendere il tutto più semplice e leggibile.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;La chiamata &lt;code&gt;subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)&lt;/code&gt;, nella funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt;, è piuttosto inefficiente dal punto di vista della performance: l&amp;rsquo;inefficienza è dovuta al fatto che a ogni chiamata vengono generati array intermedi dovuti alle varie mappature dei dati; non è in realtà necessario creare questi array intermedi: basta utilizzare procedure &amp;ldquo;lazy&amp;rdquo;, che vedremo in un articolo futuro.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;riferimenti:9546cc279181b22e90a8ccdde798a866&#34;&gt;Riferimenti&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tomas Petricek - &lt;a href=&#34;http://tomasp.net/blog/type-first-development.aspx&#34;&gt;Why type-first development matters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Michael Feathers - &lt;a href=&#34;http://www.infoq.com/presentations/Type-Functional-Design&#34;&gt;A Type Driven Approach to Functional Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Johannes Weiß - &lt;a href=&#34;https://speakerdeck.com/johannesweiss/type-driven-development-in-swift&#34;&gt;Type Driven Development in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Luca Cardelli - &lt;a href=&#34;http://www.lucacardelli.name/Papers/TypefulProg.pdf&#34;&gt;Typeful Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il codice mostrato nell&amp;rsquo;articolo è disponibile su &lt;a href=&#34;https://gist.github.com/broomburgo/ba8e5dd6cd509fdfd781&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>