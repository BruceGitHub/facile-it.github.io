<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Type First Development on Facile.it Engineering</title>
    <link>engineering.facile.it/categories/type-first-development/</link>
    <description>Recent content in Type First Development on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 May 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="engineering.facile.it/categories/type-first-development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Type First Development in Swift</title>
      <link>/engineering.facile.it/blog/ita/type-first-development-in-swift/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>/engineering.facile.it/blog/ita/type-first-development-in-swift/</guid>
      <description>

&lt;p&gt;Con &lt;em&gt;Type First Development&lt;/em&gt; può intendersi un approccio allo sviluppo di nuove funzionalità o moduli di un software partendo dai &lt;strong&gt;tipi&lt;/strong&gt; di dati coinvolti: non si tratta quindi di un pattern o una pratica codificata, ma solo di &lt;strong&gt;un possibile punto di partenza&lt;/strong&gt; per iniziare il ragionamento. Ragionando esclusivamente sui tipi, prima ancora di pensare alle singole specifiche implementazioni dei vari blocchi di codice, è possibile costruire più facilmente una mappa dei vari di flussi di dati che attraversano il nostro software, e verificare immediatamente se stiamo scrivendo qualcosa di sensato, solido ed adeguatamente estendibile.&lt;/p&gt;

&lt;p&gt;Ragionare sui tipi di dato è un classico approccio usato nel paradigma di programmazione noto come &lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_programming&#34;&gt;&lt;em&gt;programmazione funzionale&lt;/em&gt;&lt;/a&gt;, e il presente articolo adotta tale paradigma in maniera piuttosto pura.&lt;/p&gt;

&lt;h2 id=&#34;indice:9546cc279181b22e90a8ccdde798a866&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#il-type-system-di-swift&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#costruiamo-un-form-il-tipo-field&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#funzioni-generiche-e-composizione-funzionale&#34;&gt;Funzioni generiche e composizione funzionale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#il-tipo-form&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;Modifica di un form e ricerca di un campo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusione&#34;&gt;Conclusione&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;il-type-system-di-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-type-system-di-swift:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/h2&gt;

&lt;p&gt;Il linguaggio &lt;strong&gt;Swift&lt;/strong&gt;, usato nello sviluppo di software per Mac OSX e iOS, si presta molto bene all&amp;rsquo;approccio basato sui tipi illustrato in questo articolo, a causa di due particolari caratteristiche del linguaggio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Type_system#Static_type-checking&#34;&gt;staticamente tipizzato&lt;/a&gt;, cioè ogni parametro, costante o variabile che sia, è caratterizzato da uno specifico tipo, e se una funzione vuole in ingresso un valore di un certo tipo, chiamare la funzione con un valore di un altro tipo risulterà in un errore di compilazione;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Strong_and_weak_typing&#34;&gt;fortemente tipizzato&lt;/a&gt;, cioè non esiste alcuna conversione implicita tra i tipi: ad esempio, in Swift &lt;code&gt;1&lt;/code&gt; è diverso da &lt;code&gt;true&lt;/code&gt; e i due valori non posso essere usati indifferentemente nello stesso contesto;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift è molto rigido, ma è in tale rigore che risiede la sua potenza: usare tipi errati provoca un errore di compilazione, e manipolando adeguatamente i tipi di dato nella costruzione di funzioni è possibile verificare gran parte della correttezza del proprio codice già nella fase di compilazione, evitando potenziali problemi in fase di esecuzione.&lt;/p&gt;

&lt;p&gt;Swift usa molti termini ereditati da C, come &lt;code&gt;struct&lt;/code&gt; e &lt;code&gt;enum&lt;/code&gt;, ma il loro significato è completamente diverso, ad esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;una &lt;code&gt;struct&lt;/code&gt; in Swift può dichiarare metodi ed essere estesa con interfacce;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enum&lt;/code&gt; in Swift è ciò che in altri linguaggi è spesso chiamato &amp;ldquo;sum type&amp;rdquo; o &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Tagged_union&#34;&gt;tagged union&lt;/a&gt;&amp;rdquo;, e a ogni &lt;code&gt;case&lt;/code&gt; possono essere assegnati dei valori associati, ad esempio &lt;code&gt;case Text(String)&lt;/code&gt; rappresenta il caso &lt;code&gt;Text&lt;/code&gt; e ha un valore &lt;code&gt;String&lt;/code&gt; associato.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per illustrare un modo per applicare l&amp;rsquo;approccio &lt;em&gt;Type First&lt;/em&gt; nello sviluppo in Swift inizieremo a scrivere una libreria per gestire &lt;strong&gt;form&lt;/strong&gt;, quindi liste strutturate di campi valorizzati, utili per raccogliere dati degli utenti tramite moduli da compilare, per effettuare sondaggi o inserire i parametri di query a un server.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;costruiamo-un-form-il-tipo-field&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;costruiamo-un-form-il-tipo-field:9546cc279181b22e90a8ccdde798a866&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Un possibile tipo di dato da cui partire è &lt;strong&gt;Field&lt;/strong&gt;, il campo, cioè il mattone costruttivo di base di un form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: String
    let name: String
    let value: String
    let visible: Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Questa definizione di Field è molto basilare, il ché non è un problema nelle prime fasi dello sviluppo, ma &lt;strong&gt;sembra poco estendibile&lt;/strong&gt;, per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; è definito come &lt;code&gt;String&lt;/code&gt; - ad esempio testo inserito dall&amp;rsquo;utente - ma un campo potrebbe contenere altri tipi di valori, ad esempio un checkbox si/no, oppure un preciso valore selezionato da una lista;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;visibile&lt;/code&gt; è definito come &lt;code&gt;Bool&lt;/code&gt;, e vuole indicare se il campo è visibile oppure nascosto, ma se volessimo assegnare altri valori di visibilità, ad esempio &amp;ldquo;evidenziato&amp;rdquo; o &amp;ldquo;oscurato&amp;rdquo; dovremmo aggiungere altri parametri &lt;code&gt;Bool&lt;/code&gt;, che alla fine potrebbero andare in contrasto l&amp;rsquo;uno con l&amp;rsquo;altro;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo risolvere immediatamente il problema, &lt;strong&gt;senza cadere nell&amp;rsquo;eccessiva ottimizzazione preventiva&lt;/strong&gt;, semplicemente modificando il tipo di &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visible&lt;/code&gt; con degli &lt;code&gt;enum&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum FieldValue: Equatable {
    case Text(String)
    case Empty
}

func == (lhs: FieldValue, rhs: FieldValue) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Empty, .Empty):
        return true
    case (.Text(let lhsText), .Text(let rhsText)):
        return lhsText == rhsText
    default:
        return false
    }
}

enum FieldVisibility: Equatable {
    case Visible
    case Hidden
}

func == (lhs: FieldVisibility, rhs: FieldVisibility) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Visible, .Visible), (.Hidden, .Hidden):
        return true
    default:
        return false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo fatto adottare il protocollo &lt;code&gt;Equatable&lt;/code&gt; a entrambi i tipi, in modo da poter confrontare &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visibility&lt;/code&gt; di due campi per verificare se sono uguali: il vantaggio degli &lt;code&gt;enum&lt;/code&gt; è che &lt;strong&gt;possiamo facilmente aggiungere nuovi casi&lt;/strong&gt; senza rompere il codice esistente, ci basterà gestire i nuovi &lt;code&gt;case&lt;/code&gt; via via che vengono aggiunti.&lt;/p&gt;

&lt;p&gt;Un&amp;rsquo;altra piccola modifica utile corrisponde a ridefinire il tipo del parametro &lt;code&gt;id&lt;/code&gt;: a tale parametro deve essere assegnata &lt;strong&gt;una chiave univoca&lt;/strong&gt;, diversa per ogni campo, quindi può convenire definire un tipo &lt;code&gt;UniqueKey&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias UniqueKey = String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift, la keyword &lt;code&gt;typealias&lt;/code&gt; ci permette di definire un &lt;em&gt;alias&lt;/em&gt; di un tipo, cioè un termine che corrisponde esattamente a quel tipo, e permette di:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;migliorare la leggibilità&lt;/strong&gt;, la chiarezza e la compattezza del codice;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;facilitare la manipolazione dei tipi&lt;/strong&gt;, come vedremo a breve;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ogni volta in cui una funzione richiederà &lt;code&gt;UniqueKey&lt;/code&gt; sapremo che in quel campo sarà necessario inserire una stringa univoca, che identifica un particolare campo.&lt;/p&gt;

&lt;p&gt;Definiamo nuovamente &lt;code&gt;Field&lt;/code&gt; incorporando i nuovi tipi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: UniqueKey    
    let name: String
    let value: FieldValue
    let visibility: FieldVisibility
    init (_ id: Key, _ name: String, _ value: FieldValue, _ visibility: FieldVisibility) {
        self.id = id
        self.name = name
        self.value = value
        self.visibility = visibility
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo aggiunto anche un costruttore di convenienza che ci permetterà di creare un &lt;code&gt;Field&lt;/code&gt; semplicemente passando i 4 dati richiesti.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/h2&gt;

&lt;p&gt;La prima e più semplice operazione che vogliamo poter effettuare su &lt;code&gt;Field&lt;/code&gt; è quella di modificarlo in qualche modo: ogni operazione di questo tipo, in Swift, può essere indicata con &lt;code&gt;Field -&amp;gt; Field&lt;/code&gt;, cioè una trasformazione che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e produce un &lt;code&gt;Field&lt;/code&gt; in uscita:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChange = Field -&amp;gt; Field
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;operatore &lt;code&gt;-&amp;gt;&lt;/code&gt; ha lo stesso significato che ha già in &lt;a href=&#34;http://en.wikipedia.org/wiki/Haskell_(programming_language&#34;&gt;Haskell&lt;/a&gt;): definisce il tipo di una funzione che prende in ingresso un dato del tipo indicato a sinistra dell&amp;rsquo;operatore, e ritorna un dato del tipo indicato a destra dell&amp;rsquo;operatore (in questo caso entrambi i dati sono di tipo &lt;code&gt;Field&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;È da evidenziare che &lt;code&gt;FieldChange&lt;/code&gt; non rappresenta un tipo di &amp;ldquo;dato&amp;rdquo; in senso stretto, ma &lt;strong&gt;un tipo di &amp;ldquo;funzione&lt;/strong&gt;&amp;ldquo;: in effetti, definendo &lt;code&gt;FieldChange&lt;/code&gt;, possiamo trattare le funzioni di quel tipo come se fossero dati.&lt;/p&gt;

&lt;p&gt;Per fare un esempio potremmo definire la funzione &lt;code&gt;setVisibility&lt;/code&gt;, che prende in ingresso un valore di &lt;code&gt;FieldVisibility&lt;/code&gt; e ritorna, appunto, un &lt;code&gt;FieldChange&lt;/code&gt;, cioè un&amp;rsquo;altra funzione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibility (visibility: FieldVisibility) -&amp;gt; FieldChange {
    return { field in
        return Field (
            field.id,
            field.name,
            field.value,
            visibility
        )
    }
}

/// alcuni esempi
let setHidden = setVisibility(.Hidden)
let visibleField1 = Field (&amp;quot;&amp;quot;,&amp;quot;&amp;quot;, .Empty, .Visible)
let isTrue1 = visibleField1.visibility == .Visible
let hiddenField1 = setHidden(visibleField1)
let isTrue2 = hiddenField1.visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Negli esempi mostrati, &lt;code&gt;setHidden&lt;/code&gt; è una funzione ma dal punto di vista sintattico è indistinguibile da un qualsiasi altro valore, e il suo tipo (cioè &lt;code&gt;FieldChange&lt;/code&gt;) è dedotto dal compilatore di Swift in base alla definizione della funzione.&lt;/p&gt;

&lt;p&gt;Una funzionalità che vogliamo certamente introdurre nella libreria corrisponde al poter operare una trasformazione su un campo in base a un qualche parametro definito in un altro campo: ad esempio, un particolare campo mostra un check che permette di mostrare/nascondere altri campi. Definiamo quindi un nuovo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChangeGenerator = Field -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è il tipo di una funzione dalla quale otteniamo, in base allo stato un certo campo origine, una certa trasformazione di tipo &lt;code&gt;FieldChange&lt;/code&gt;, cioè qualcosa che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e ritorna un &lt;code&gt;Field&lt;/code&gt; in uscita: si tratta quindi di una funzione che ritorna un&amp;rsquo;altra funzione, di tipo diverso. Vorremmo ad esempio poter scrivere una funzione del tipo &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, che imposta un valore di visibilità in base allo stato di un campo origine: ok, ma quale valore di visibilità? Dipende dal campo origine, e possiamo risolvere il problema definendo un nuovo tipo di funzione, che prende in ingresso un campo, e ritorna un valore di visibilità:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition = Field -&amp;gt; FieldVisibility
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La nostra funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt; semplicemente prenderà ingresso un dato di tipo &lt;code&gt;FieldCondition&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition) -&amp;gt; FieldChangeGenerator {
    return { origin in
        let newVisibility = condition(origin)
        return setVisibility(newVisibility)
    }
}

/// alcuni esempi

let setVisibleIfNotEmpty = setVisibilityIfOrigin { field in
    switch field.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
}

let nonEmptyField = Field (&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, .Text(&amp;quot;something&amp;quot;), .Visible)

let anotherVisibleField = setVisibleIfNotEmpty(nonEmptyField)(invisibleField)

let isTrue3 = anotherVisibleField.visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;funzioni-generiche-e-composizione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;funzioni-generiche-e-composizione-funzionale:9546cc279181b22e90a8ccdde798a866&#34;&gt;Funzioni generiche e composizione funzionale&lt;/h2&gt;

&lt;p&gt;In realtà la nostra &lt;code&gt;FieldCondition&lt;/code&gt; sembra essere un po&amp;rsquo; limitata: ritorna un valore di &lt;code&gt;FieldVisibility&lt;/code&gt;, mentre una vera &lt;em&gt;condition&lt;/em&gt; &lt;strong&gt;dovrebbe ritornare un valore generico&lt;/strong&gt;, a seconda dei casi: ad esempio, potrebbe cambiare il &lt;strong&gt;valore&lt;/strong&gt; di un campo bersaglio in base allo stato di un campo origine. L&amp;rsquo;ideale sarebbe scrivere qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition&amp;lt;T&amp;gt; = Field -&amp;gt; T
/// errore di compilazione!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sfortunatamente in Swift non è possibile scrivere dei &lt;code&gt;typealias&lt;/code&gt; generici, ma possiamo facilmente aggirare l&amp;rsquo;ostacolo costruendo una &lt;code&gt;struct&lt;/code&gt; generica che contiene un solo parametro, al quale è assegnata una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct FieldCondition&amp;lt;T&amp;gt; {
    let apply: Field -&amp;gt; T
    init(_ apply: Field -&amp;gt; T) {
        self.apply = apply
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se prima abbiamo scritto semplicemente una funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, l&amp;rsquo;idea è riuscire ora a scrivere &lt;strong&gt;una funzione generica&lt;/strong&gt; &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; che ritorna un &lt;code&gt;FieldChangeGenerator&lt;/code&gt; che trasforma un campo bersaglio rispetto a un certo parametro, definito in base allo stato di un campo origine: come scrivere questa funzione? &lt;strong&gt;Ragioniamo sui tipi&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FieldCondition&amp;lt;T&amp;gt;&lt;/code&gt; è un contenitore per una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è un alias per &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;per completare la catena abbiamo bisogno di una trasformazione del tipo &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; perché unendo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt; e &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; otteniamo appunto &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo scrivere quindi la funzione generica di cui sopra:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setTargetIfOrigin&amp;lt;T&amp;gt; (condition: FieldCondition&amp;lt;T&amp;gt;, generate: T -&amp;gt; FieldChange) -&amp;gt; FieldChangeGenerator {
    return { field in
        return generate(condition.apply(field))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se tutto sembra molto astratto è perché &lt;strong&gt;lo è&lt;/strong&gt;: stiamo gradualmente costruendo degli strumenti di manipolazione dei dati (e delle funzioni, che sono anch&amp;rsquo;esse dati) operando su astrazioni successive.&lt;/p&gt;

&lt;p&gt;Nella funzione &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; c&amp;rsquo;è un parametro &lt;code&gt;generate&lt;/code&gt; che è definito come &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt;: cosa è &lt;code&gt;T&lt;/code&gt;? È semplicemente lo stesso tipo di dato con il quale viene passata la condizione in &lt;code&gt;condition&lt;/code&gt;; se passiamo una condizione sulla visibilità, ad esempio, &lt;code&gt;T&lt;/code&gt; sarà &lt;code&gt;FieldVisibility&lt;/code&gt;: &lt;strong&gt;una funzione generica si specializza nel momento in cui è definito il tipo concreto da assegnare ai tipi generici&lt;/strong&gt;. Volendo fare un esempio concreto, possiamo ridefinire la funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition&amp;lt;FieldVisibility&amp;gt;) -&amp;gt; FieldChangeGenerator {
    return setTargetIfOrigin (condition) { visibility in setVisibility(visibility) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione chiama &lt;code&gt;setTargetIfOrigin&lt;/code&gt;, passando una condizione del tipo &lt;code&gt;FieldCondition&amp;lt;FieldVisibility&amp;gt;&lt;/code&gt;: il secondo parametro dovrà essere quindi una funzione del tipo &lt;code&gt;FieldVisibility -&amp;gt; FieldChange&lt;/code&gt;, e possiamo usare la funzione &lt;code&gt;setVisibility&lt;/code&gt; definita prima. Vediamo qualche altro esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let setVisibleIfNotEmpty = setVisibilityIfOrigin (FieldCondition { origin in
    switch origin.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
})

let copyValue = setTargetIfOrigin (FieldCondition { $0.value}) { value in
    return { target in
        return Field(target.id,target.name,value,target.visibility)
    }
}

let field1 = Field(&amp;quot;field1&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;1&amp;quot;),.Visible)
let field2 = Field(&amp;quot;field2&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;2&amp;quot;),.Visible)

let newField1 = copyValue(field2)(field1)

let isTrue4 = newField1.value == .Text(&amp;quot;2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Può essere interessante spendere qualche parola per la funzione &lt;code&gt;copyValue&lt;/code&gt; definita nell&amp;rsquo;esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la condizione è chiaramente del tipo &lt;code&gt;FieldCondition&amp;lt;FieldValue&amp;gt;&lt;/code&gt; perché la &lt;em&gt;closure&lt;/em&gt; passata ritorna il &lt;code&gt;value&lt;/code&gt; del campo;&lt;/li&gt;
&lt;li&gt;nella seconda &lt;em&gt;closure&lt;/em&gt; passata, il valore è usato per costruire un nuovo campo, uguale al bersaglio tranne proprio per quel valore;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quindi &lt;code&gt;copyValue&lt;/code&gt;, che ricordiamo è di tipo &lt;code&gt;FieldChangeGenerator&lt;/code&gt;, è una trasformazione che prende il valore di un campo origine e lo assegna a un campo bersaglio.&lt;/p&gt;

&lt;p&gt;Nel caso in cui avessimo una serie di campi e volessimo applicare una certa trasformazione a un solo campo particolare, avremmo bisogno di un check sul campo bersaglio. Come al solito, pensiamo prima al &lt;strong&gt;tipo&lt;/strong&gt; di questo check: sarà qualcosa che prende un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un altro &lt;code&gt;FieldChange&lt;/code&gt;, che potrebbe essere uguale a quello in ingresso, oppure diverso in base a una certa condizione applicata al campo bersaglio.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCheck = FieldChange -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per quanto riguarda la condizione, possiamo usare lo stesso FieldCondition&lt;T&gt; di prima, ma in questo caso lo specializzeremo direttamente in &lt;code&gt;FieldCondition&amp;lt;Bool&amp;gt;&lt;/code&gt; perché quello che ci interessa sapere è se un certo campo bersaglio è interessato oppure no da una certa trasformazione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldConditionBool = FieldCondition&amp;lt;Bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Definiamo quindi una funzione &lt;code&gt;checkTarget&lt;/code&gt; che prende in ingresso una condizione, e ritorna un &lt;code&gt;FieldCheck&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func checkTarget (condition: FieldConditionBool) -&amp;gt; FieldCheck {
    return { change in
        return { field in
            if condition.apply(field) {
                return change(field)
            }
            else {
                return field
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nel definire &lt;code&gt;checkTarget&lt;/code&gt; possiamo vedere un altro caso in cui ragionare solo sui tipi ci aiuta a capire cosa poi dobbiamo effettivamente fare nel codice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la funzione deve ritornare un dato di tipo &lt;code&gt;FieldCheck&lt;/code&gt;, che è una funzione che prende in ingresso un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, quindi la prima riga della funzione è appunto &lt;code&gt;return { change in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldCheck&lt;/code&gt; è una funzione che ritorna un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, che come definito prima corrisponde a una funzione che prende in ingresso un &lt;code&gt;Field&lt;/code&gt;, quindi la seconda riga è &lt;code&gt;return { field in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChange&lt;/code&gt; deve ritornare un &lt;code&gt;Field&lt;/code&gt;, ma a questo punto possiamo applicare la nostra condizione sul campo in ingresso: se la condizione è verificata allora ritorniamo il campo trasformato, mentre se non lo è &amp;ldquo;facciamo uscire&amp;rdquo; il campo esattamente come è &amp;ldquo;entrato&amp;rdquo;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Come si può vedere, abbiamo iniziato a implementare funzioni ragionando quasi esclusivamente sui tipi coinvolti. Vediamo alcuni esempi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ifTargetId (id: UniqueKey) -&amp;gt; FieldCheck {
    return checkTarget (FieldCondition { $0.id == id })
}

let visibleField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field1)
let hiddenField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field2)

let isTrue5 = visibleField.visibility == .Visible
let isTrue6 = hiddenField.visibility == .Hidden

let fields = [field1,field2]
let newFields = fields.map(ifTargetId(&amp;quot;field2&amp;quot;)(setHidden))

let isTrue7 = newFields[0].visibility == .Visible
let isTrue8 = newFields[1].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;il-tipo-form&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-tipo-form:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Abbiamo implementato quindi alcuni strumenti per manipolare i singoli campi: a questo punto proviamo a unire il tutto definendo un &lt;code&gt;Form&lt;/code&gt; come contenitore strutturato di campi, insieme ad alcune funzioni di manipolazione. Intanto &lt;strong&gt;pensiamo al tipo da assegnare al nostro form&lt;/strong&gt;: una possibilità è quella di definire alcuni blocchi costruttivi che ne descrivono la struttura:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// sezione: è una semplice lista di campi
struct Section {
    let fields: [Field]
}

/// step: un gruppo di sezioni, ad esempio una pagina
struct Step {
    let sections: [Section]
}

/// form: un insieme di pagine
struct Form {
    let steps: [Step]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ci sono però due problemi con questo approccio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stiamo prematuramente fornendo al nostro form &lt;strong&gt;una struttura rigida&lt;/strong&gt;: se in futuro decidessimo di voler creare una sottostruttura rispetto a &lt;code&gt;Section&lt;/code&gt; sarebbe probabilmente molto complesso modificare il tutto;&lt;/li&gt;
&lt;li&gt;nello scrivere le logiche di ricerca e manipolazione dei campi ci ritroveremmo a dover gestire le &lt;code&gt;struct&lt;/code&gt; appena definite: stiamo quindi automaticamente &lt;strong&gt;accoppiando&lt;/strong&gt; un particolare modello di dati con la logica di manipolazione dei form, che &lt;strong&gt;dovrebbero essere adattabili a più modelli, senza cambiare la logica&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per evitare questi problemi gli approcci possibili sono molti: un&amp;rsquo;opzione, ad esempio, è quella definire un tipo di dato corrispondente a un contenitore &lt;em&gt;ricorsivo&lt;/em&gt; per un valore generico, che chiameremo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Un valore di tipo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; definisce due casi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;branch&lt;/em&gt;, cioè una lista di valori di tipo T;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;root&lt;/em&gt;, cioè una lista di altri &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;enum Node&amp;lt;T&amp;gt; {
    case Branch([T])
    case Root([Node&amp;lt;T&amp;gt;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possiamo quindi definire un &lt;code&gt;Form&lt;/code&gt; come una versione specializzata di &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; dove &lt;code&gt;T&lt;/code&gt; è &lt;code&gt;Field&lt;/code&gt;, e definiremo un paio di funzioni di convenienza per generare un &lt;em&gt;branch&lt;/em&gt; di &lt;code&gt;Field&lt;/code&gt; o una &lt;em&gt;root&lt;/em&gt; di &lt;code&gt;Form&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias Form = Node&amp;lt;Field&amp;gt;

func branch (fields: [Field]) -&amp;gt; Form {
    return Node.Branch(fields)
}

func root (nodes: [Form]) -&amp;gt; Form {
    return Node.Root(nodes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modifica-di-un-form-e-ricerca-di-un-campo:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modifica di un form e ricerca di un campo&lt;/h2&gt;

&lt;p&gt;Come accadeva per &lt;code&gt;Field&lt;/code&gt;, la prima operazione che vogliamo poter effettuare su &lt;code&gt;Form&lt;/code&gt; è quella modificarlo; definiamo quindi il tipo &lt;code&gt;FormChange&lt;/code&gt; in maniera a simile a come avevamo definito &lt;code&gt;FieldChange&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FormChange = Form -&amp;gt; Form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supponiamo ad esempio di avere un form, e voler applicare una modifica a un campo presente nel form, ottenendo un nuovo form con il campo modificato: abbiamo bisogno di una funzione che potremmo chiamare &lt;code&gt;changeFromFieldChange&lt;/code&gt; che prende in ingresso un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un &lt;code&gt;FormChange&lt;/code&gt;; grazie alla struttura ricorsiva del tipo &lt;code&gt;Form&lt;/code&gt; definito, possiamo scrivere in poche righe una funzione che attraversa un form nei suoi vari livelli e lo ricostruisce applicando la modifica passata in ingresso a ogni campo, tenendo eventualmente conto di una certa condizione per verificare se un certo campo è interessato dalla modifica o meno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeFromFieldChange (fieldChange: FieldChange) -&amp;gt; FormChange {
    return { form in
        switch form {
        case .Branch (let fields):
            return branch(fields.map(fieldChange))
        case .Root (let subforms):
            return root(subforms.map(changeFromFieldChange(fieldChange)))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione verifica se un form è del tipo &lt;code&gt;.Branch&lt;/code&gt; o &lt;code&gt;.Root&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nel primo caso, ricostruisce il &lt;em&gt;branch&lt;/em&gt; applicando la funzione &lt;code&gt;FieldChange&lt;/code&gt; in ingresso a ogni campo nel &lt;em&gt;branch&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;nel secondo caso, ricostruisce il &lt;em&gt;root&lt;/em&gt; applicando ricorsivamente la stessa funzione &lt;code&gt;changeFromFieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per migliorare la leggibilità possiamo definire una nuova funzione &lt;code&gt;updateField&lt;/code&gt; identica a &lt;code&gt;changeFromFieldChange&lt;/code&gt; che dichiara &lt;strong&gt;in maniera più espressiva&lt;/strong&gt; il tipo di operazione che vogliamo poter effettuare su un form, e cioè aggiornare un certo campo in base a una certa trasformazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let updateField = changeFromFieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vediamo quindi un esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let form = branch([field1,field2])

let newForm = updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere dall&amp;rsquo;esempio, otteniamo &lt;code&gt;newForm&lt;/code&gt; componendo alcune funzioni definite in precedenza con &lt;code&gt;updateField&lt;/code&gt;: se l&amp;rsquo;id del campo bersaglio è &amp;ldquo;field1&amp;rdquo;, nascondiamo il campo.&lt;/p&gt;

&lt;p&gt;Come verificare se il campo con id &amp;ldquo;field1&amp;rdquo; è effettivamente nascosto? Come ultima operazione vogliamo definire una funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; che ci permetta di cercare uno o più campi in un form in base a una certa condizione: la condizione sarà ancora di tipo &lt;code&gt;FieldConditionBool&lt;/code&gt;, cioè da un campo otteniamo un valore &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt;. Per scrivere la funzione ragioniamo sul tipo di dato ritornato: esso deve corrispondere a una funzione che prende un form e ritorna un array di campi; chiameremo questo tipo &lt;code&gt;FieldGet&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldGet = Form -&amp;gt; [Field]

func fieldsWithCondition (condition: FieldConditionBool) -&amp;gt; FieldGet {
    return { form in
        switch form {
        case .Branch(let fields):
            return fields.filter(condition.apply)
        case .Root(let subforms):
            return subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; opera ricorsivamente, come è ovvio che sia considerando la natura ricorsiva del tipo di dato &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Vediamo qualche applicazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fieldsWithId (id: UniqueKey) -&amp;gt; FieldGet {
    return fieldsWithCondition (FieldConditionBool { $0.id == id })
}

let allFields: FieldGet = fieldsWithCondition (FieldConditionBool { _ in true })

let twoFields = allFields(form)

let isTrue9 = count(twoFields) == 2

let isTrue10 = fieldsWithId(&amp;quot;field1&amp;quot;)(form)[0].visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithId&lt;/code&gt; prende una &lt;code&gt;UniqueKey&lt;/code&gt; e permette di ottenere tutti i campi con quell&amp;rsquo;id (presumibilmente l&amp;rsquo;array risultante conterrà un solo elemento); &lt;code&gt;allFields&lt;/code&gt; genera semplicemente un array con tutti i campi: da notare che la &lt;em&gt;closure&lt;/em&gt; &lt;code&gt;{ _ in true }&lt;/code&gt; ignora il valore in ingresso e ritorna sempre &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Usando &lt;code&gt;fieldsWithId&lt;/code&gt; possiamo infine verificare che il campo con id &amp;ldquo;field1&amp;rdquo; sia effettivamente nascosto, in base alle manipolazioni precedenti:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isTrue11 = fieldsWithId(&amp;quot;field1&amp;quot;)(newForm)[0].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;conclusione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusione:9546cc279181b22e90a8ccdde798a866&#34;&gt;Conclusione&lt;/h2&gt;

&lt;p&gt;Per concludere, abbiamo visto come partendo da &lt;strong&gt;tipi&lt;/strong&gt;, che siano essi relativi a singoli valori o a funzioni, è stato possibile iniziare a scrivere una libreria composta da semplici tipi di base e funzioni elementari che vengono composte via via a livelli di astrazione più alti. Definendo tipi specifici per molte astrazioni siamo riusciti a &lt;strong&gt;gestire meglio la complessità&lt;/strong&gt; inerente nel manipolare e comporre funzioni, al punto da poter &lt;strong&gt;trattare funzioni complesse come semplici dati&lt;/strong&gt; da passare ad altre funzioni. In un articolo successivo vedremo come estendere la libreria qui iniziata, abbracciando completamente la composizione funzionale e usando operatori specificamente definiti per migliorare la chiarezza del codice e rendere più semplice la manipolazione e combinazione delle funzioni.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;Nello scrivere questo articolo si è scelto specificamente di non definire operatori su misura per comporre le funzioni, per evitare un ulteriore appesantimento legato alla presenza di codice dalla sintassi poco familiare. La chiamata di una funzione in Swift è c-like: si scrive il nome della funzione e poi si inseriscono i dati di ingresso tra due parentesi tonde; questo purtroppo può portare a diverse chiamate in parentesi annidate; inoltre, può non risultar chiara una chiamata del tipo &lt;code&gt;updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)&lt;/code&gt;: come accennato, in un articolo futuro vedremo come usare operatori personalizzati per rendere il tutto più semplice e leggibile.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;La chiamata &lt;code&gt;subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)&lt;/code&gt;, nella funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt;, è piuttosto inefficiente dal punto di vista della performance: l&amp;rsquo;inefficienza è dovuta al fatto che a ogni chiamata vengono generati array intermedi dovuti alle varie mappature dei dati; non è in realtà necessario creare questi array intermedi: basta utilizzare procedure &amp;ldquo;lazy&amp;rdquo;, che vedremo in un articolo futuro.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;riferimenti:9546cc279181b22e90a8ccdde798a866&#34;&gt;Riferimenti&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tomas Petricek - &lt;a href=&#34;http://tomasp.net/blog/type-first-development.aspx&#34;&gt;Why type-first development matters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Michael Feathers - &lt;a href=&#34;http://www.infoq.com/presentations/Type-Functional-Design&#34;&gt;A Type Driven Approach to Functional Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Johannes Weiß - &lt;a href=&#34;https://speakerdeck.com/johannesweiss/type-driven-development-in-swift&#34;&gt;Type Driven Development in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Luca Cardelli - &lt;a href=&#34;http://www.lucacardelli.name/Papers/TypefulProg.pdf&#34;&gt;Typeful Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il codice mostrato nell&amp;rsquo;articolo è disponibile su &lt;a href=&#34;https://gist.github.com/broomburgo/ba8e5dd6cd509fdfd781&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>