<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OOP on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/oop/</link>
    <description>Recent content in OOP on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 31 May 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://engineering.facile.it/categories/oop/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Why type hints and interfaces are not visual debt</title>
      <link>https://engineering.facile.it/blog/eng/visual-debt-typehints/</link>
      <pubDate>Wed, 31 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/visual-debt-typehints/</guid>
      <description>

&lt;p&gt;A few days ago I stumbled on a strange tweet that was highlighting a controversy about scalar type hints.&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;it&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Scalar type hints &amp;amp; return types vs no scalar type hints &amp;amp; return types is &lt;a href=&#34;https://twitter.com/hashtag/PHP?src=hash&#34;&gt;#PHP&lt;/a&gt;&amp;#39;s new spaces vs tabs&lt;/p&gt;&amp;mdash; Cees-Jan ðŸ”Š Kiewiet (@WyriHaximus) &lt;a href=&#34;https://twitter.com/WyriHaximus/status/865524687257862144&#34;&gt;19 maggio 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;After asking references about this, someone alluded to this very short video: &lt;a href=&#34;https://laracasts.com/series/php-bits/episodes/1&#34;&gt;&lt;strong&gt;&amp;ldquo;PHP Bits: Visual Debt&amp;rdquo;&lt;/strong&gt;&lt;/a&gt; (it&amp;rsquo;s only 3 minutes, please watch it before continue reading). After that, the author of the video was dragged into the conversation, and it blew up into a big tweetstorm in the following few hours.&lt;/p&gt;

&lt;p&gt;The core of the controversy was the fact that the author of the video classified as &lt;strong&gt;&lt;em&gt;visual debt&lt;/em&gt;&lt;/strong&gt; a lot of stuff in his PHP example, like interfaces, scalar type hints and the final keyword.&lt;/p&gt;

&lt;h2 id=&#34;my-opinion-on-the-matter&#34;&gt;My opinion on the matter&lt;/h2&gt;

&lt;p&gt;I can agree with the bottom line of the video:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Am I necessarily getting a benefit [&amp;hellip;] ?  Question everything&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Every choice in our line of work is always a &lt;strong&gt;trade-off&lt;/strong&gt; between benefits and cons, and every new introduction in a projects should be evaluated and agreed upon between team members. But my personal preference leans a lot towards the opposite side in this specific matter: as I stated in a &lt;a href=&#34;https://engineering.facile.it/blog/eng/how-php-7-tdd-helped-me-sleep-better/&#34;&gt;previous blog post here&lt;/a&gt;, I love the new additions that PHP 7 brought to us like scalar and return type hints, and I use them as often as I can, because I discovered that &lt;strong&gt;they bring a lot of benefits&lt;/strong&gt; to the code that I write.&lt;/p&gt;

&lt;p&gt;Probably this was influenced by the fact that previously I worked with C++, where types are a lot more intrusive compared with PHP 5; but over time and with usage, I learned the great benefits that we can achieve with this addition to our PHP 7 codebases. In general, I think that type hints, and other language features that create a more &amp;ldquo;rigid&amp;rdquo; code, are &lt;strong&gt;helpful during the evolution of a codebase&lt;/strong&gt;, and so they are really needed in long-running projects, where the maintainability of code is crucial. It may be less true in a &amp;ldquo;release and forget&amp;rdquo; type of project, but I think that it would still be like betting againt oneself.&lt;/p&gt;

&lt;p&gt;In this blog post I would like to explain myself and the reasons behind my arguments, recounting them.&lt;/p&gt;

&lt;h2 id=&#34;scalar-type-hints-as-safeguards&#34;&gt;Scalar type hints as safeguards&lt;/h2&gt;

&lt;p&gt;In the video, the example had all along this class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Event implements EventInterface
{
    protected $events = [];
    
    public function listen(string $name, callable $handler): void
    {
        $this-&amp;gt;events[$name][] = $handler;
    }

    public function fire(string $name): bool
    {
        if (! array_key_exists($name, $this-&amp;gt;events)) {
            return false;
        }
        
        foreach($this-&amp;gt;events[$name] as $event) {
            $event();
        }

        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The author suggests to remove all type hints, since the code should still work and you could get rid of a lot of additional, not needed complications. I disagree completely with this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type hints are safeguards&lt;/strong&gt; here, because they let you reduce to the bare minimum all the checks that you should do here before accepting the input arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;because it&amp;rsquo;s used as a key for an array, &lt;code&gt;$name&lt;/code&gt; can only be a string (or an int, but it would not make sense)&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;events&lt;/code&gt; property can only accept callables, because its elements are invoked inside the foreach of the &lt;code&gt;fire()&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;because we don&amp;rsquo;t need to insert additional &lt;code&gt;if&lt;/code&gt;s in our methods, we &lt;strong&gt;reduce the number of possible paths of execution&lt;/strong&gt;, hence reducing the number of cases that we need to check in our tests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;type-hints-and-interfaces-as-contracts&#34;&gt;Type hints and interfaces as contracts&lt;/h2&gt;

&lt;p&gt;In the video, it was suggested to also get rid of the interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;interface EventInterface
{
    public function listen(string $name, callable $handler): void;

    public function fire(string $name): bool;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I agree that &lt;strong&gt;an interface should be written only if needed&lt;/strong&gt;, like if you want to write multiple concrete implementation of it with different inheritance hierarchy. But this doesn&amp;rsquo;t mean that we will not have any interface at all: we still have the concrete implementation.&lt;/p&gt;

&lt;p&gt;That is not the same of having a pure interface, but we will still be able to determine a &lt;strong&gt;contract&lt;/strong&gt;, a list of method signatures that tells us what that object will accept as valid method calls. This kind of contracts are a must in object oriented programming, because they dictate how your object will interconnect, communicate and cooperate, and they are especially useful in combination with stricter type hints and &lt;strong&gt;unit testing&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When we write unit test, we use the real instance of the class which is under test, and everything else should be mocked. That means that we will use some test mocking library (i.e. I prefer &lt;a href=&#34;https://github.com/phpspec/prophecy&#34;&gt;Prophecy&lt;/a&gt;, which is included in PHPUnit) to mimick the behavior of nearby objects.&lt;/p&gt;

&lt;p&gt;How type hints would help us in this case? If we would have to mock the &lt;code&gt;EventInterface&lt;/code&gt; (or the concrete class, it&amp;rsquo;s unimportant here), having the return type hints for example would help us in &lt;strong&gt;writing good mocks&lt;/strong&gt;, and not wrong ones.&lt;/p&gt;

&lt;p&gt;But how? Nearly every mocking library creates a mock extending at runtime the original class, since the mock needs to pass every check and type hint as if it was the original class; this means that it can&amp;rsquo;t change the method signature, hence preserving the original return type hint.&lt;/p&gt;

&lt;p&gt;This will translate in errors and test failures if we would write a mock that doesn&amp;rsquo;t return the proper type, like in this example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Person
{
    public function shout(): bool
    {
        $event = new Event();
        if ($event-&amp;gt;fire(&#39;shout&#39;)) {
            // someone was listening!
            return true;
        }
        // ...
    }
}

class PersonTest extends PHPUnit\Framework\TestCase
{
    public function testShout()
    {
        $event = $this-&amp;gt;prophesize(EventInterface::class);
        $event-&amp;gt;fire(&#39;shout&#39;)
            -&amp;gt;shouldBeCalled();
        // ...
        
        $person = new Person();
        $person-&amp;gt;shout();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ phpunit
# ...
1) PersonTest::testShout
TypeError: Return value of Double\EventInterface\P2118::fire() must be a string, null returned
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This mock, once used, &lt;strong&gt;will make the test fail&lt;/strong&gt;. Why? Because the &lt;code&gt;fire()&lt;/code&gt; method can only return a boolean, and by default (if not instructed differently) Prophecy&amp;rsquo;s mocks will return &lt;code&gt;null&lt;/code&gt;. Without the &lt;code&gt;: bool&lt;/code&gt; return type hint, the mock would return &lt;code&gt;null&lt;/code&gt; but the test would not fail, and the class under test would silently cast or interpret the return value as &lt;code&gt;false&lt;/code&gt;, possibly causing an unintended behavior or a false positive.&lt;/p&gt;

&lt;p&gt;This means that having complete type hints in your interfaces and method signatures only &lt;strong&gt;makes your code more cohesive and your unit test more robust&lt;/strong&gt;; this kind of enforcing helps a lot also with refactoring, since changing a method&amp;rsquo;s signature would cause failures in all the related tests that include a mock of that interface, as it could become inconsistent and unreliable after this change.&lt;/p&gt;

&lt;h2 id=&#34;use-interfaces-as-behavior-checks&#34;&gt;Use interfaces as behavior checks&lt;/h2&gt;

&lt;p&gt;One of the counter example that popped up during the discussion on Twitter was this one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Fireman
{
    // ...
}

class Building
{
    public function putOutFire(Fireman $fireman);
}

$building-&amp;gt;putOutFire(new StrongAndAblePerson()); // type error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was cited to show how sometimes type hints can be a hindrance more that something helpful in your code: why a strong, capable person shouldn&amp;rsquo;t be able to put out a fire? Who&amp;rsquo;s the &lt;code&gt;Building&lt;/code&gt; class to decide that? Are we maybe violating the Single Responsibility Principle?&lt;/p&gt;

&lt;p&gt;I think that this is misguided for a simple reason: it was &lt;strong&gt;wrong to check against a concrete implementation&lt;/strong&gt; instead of an interface; and that&amp;rsquo;s not evident because, in my opinion, the example was &lt;strong&gt;cut too short&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s speculate on the content of the &lt;code&gt;putOutFire()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Building
{
    public function putOutFire(Fireman $fireman)
    {
        $fireman-&amp;gt;wearProtectiveGear();
        $fireman-&amp;gt;shootWaterAtFlames();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why we have a type hint in the &lt;code&gt;putOutFire()&lt;/code&gt; method? Surely because we want to rely on some method that a &lt;code&gt;Fireman&lt;/code&gt; instance would give to us in the method body (i.e. the &lt;code&gt;wearProtectiveGear()&lt;/code&gt; and &lt;code&gt;shootWaterAtFlames()&lt;/code&gt;); if we remove the type hint, we would have no guarantees that those methods exists on the argument, and we would have to either use a &lt;code&gt;method_exists()&lt;/code&gt; call twice (oh, the horror!) or expose our &lt;code&gt;Building&lt;/code&gt; class to a possible fatal error.&lt;/p&gt;

&lt;p&gt;To take the example further, we can make the &lt;code&gt;StrongAndAblePerson&lt;/code&gt; capable of put out a fire if we &lt;strong&gt;extract the needed methods in an interface&lt;/strong&gt;, defining a contract of what our &lt;code&gt;putOutFire()&lt;/code&gt; needs to know and use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;interface TrainedFireFighter
{
    public function wearProtectiveGear(): void;
    public function shootWaterAtFlames(): void;
}

class StrongAndAblePerson implements TrainedFireFighter { ... }
class Fireman implements TrainedFireFighter { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; now we can have the &lt;code&gt;putOutFire()&lt;/code&gt; method with a broader type hint, that would accept both a &lt;code&gt;Fireman&lt;/code&gt; and any other class that implements the &lt;code&gt;TrainedFireFighter&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Building
{
    public function putOutFire(TrainedFireFighter $firefighter)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-final-keyword&#34;&gt;The final keyword&lt;/h2&gt;

&lt;p&gt;The only point of the video which I find relatable is the remark on the &lt;code&gt;final&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;Apart from the funny joke (&lt;em&gt;&amp;ldquo;I&amp;rsquo;m not your daddy!&amp;rdquo;&lt;/em&gt;), I find the final keyword &lt;strong&gt;not very usable in closed projects&lt;/strong&gt;, since its only usefulness is to impede the extension of some object. When the persons that could work on a codebase are well known and they can be coordinated, I think it&amp;rsquo;s better to leave that liberty to the coders, and just have an agreement on what can and cannot be done with that class.&lt;/p&gt;

&lt;p&gt;On the other hand, this keyword becomes useful when we are talking about &lt;strong&gt;open sourced code&lt;/strong&gt;: using it is a clear statement that reduces the surface of the API that the library is exposing to end users, in the same way &lt;code&gt;private&lt;/code&gt; is limiting access to properties.&lt;/p&gt;

&lt;p&gt;Straightforwardly, the maintainer of the code is saying that this class is not extensible, because it may change internally without notice; this concept is also well explained by Marco Pivetta in his signature &amp;ldquo;Extremely defensive PHP&amp;rdquo; talk (which we cited also in our &lt;a href=&#34;https://engineering.facile.it/blog/eng/php-day-2017/&#34;&gt;previous blog post&lt;/a&gt;, &lt;a href=&#34;https://ocramius.github.io/extremely-defensive-php/#/90&#34;&gt;see related slide here&lt;/a&gt;) and &lt;a href=&#34;http://ocramius.github.io/blog/when-to-declare-classes-final/&#34;&gt;in his blog post about it&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-practical-example&#34;&gt;A practical example&lt;/h2&gt;

&lt;p&gt;I would like to conclude this blog post with a practical example. I maintain &lt;a href=&#34;https://github.com/facile-it/paraunit/&#34;&gt;facile-it/paraunit&lt;/a&gt;, a parallelization tool that works on top of PHPUnit. In the past few days I was working on supporting PHPUnit v6, and that lead to bumping the minimum PHP supported version of the package to 7.0: &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93&#34;&gt;https://github.com/facile-it/paraunit/pull/93&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since previously the minimum supported version was PHP 5.3, I took the opportunity to go over the whole codebase and clean it up, using all the new language features that I could now take for granted: &lt;code&gt;::class&lt;/code&gt; shortcuts, array short syntax, but more importantly the aforementioned &lt;strong&gt;scalar and return type hints&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This is the perfect example to show that adding those type hints on already working code made a &lt;strong&gt;non-trivial difference&lt;/strong&gt; even if I wasn&amp;rsquo;t changing the objects&amp;rsquo; behavior, and it forced me to fix some of this stuff:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it forced me &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/files#diff-049f05e192bb0dcb9cf59ad2bbd43ceaR79&#34;&gt;to define more explicitly a default behavior&lt;/a&gt;, since a &lt;code&gt;null&lt;/code&gt; was no longer accepted in place of a string&lt;/li&gt;
&lt;li&gt;this also lead me to &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/commits/6aa9286256ed47c7b4500b990e030588b18b7770&#34;&gt;write an additional test&lt;/a&gt; for an uncovered, very common case&lt;/li&gt;
&lt;li&gt;it made me realize that I had &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/files#diff-f3225dfaa1d4e63e21a7e51880c63bbbR40&#34;&gt;a regex silently failing&lt;/a&gt; returning a bad result, and I had to take better care of it, leading to a simpler and more robust approach&lt;/li&gt;
&lt;li&gt;this lead to &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/commits/b5463b122e87f14dbaf6fa2ff78ba53f14ae737a#diff-59b76fc4702a8549daa568e542d71498R42&#34;&gt;additional tests too&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;it made me discover a &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/commits/61c786c6faa0020465abd8243ee1415883193a94#diff-4fd831bf7fb1767a7a49e0954a98fb05R98&#34;&gt;specific behavior of the SPL file iterator classes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;strict-types-enforcing&#34;&gt;Strict types enforcing&lt;/h3&gt;

&lt;p&gt;In the last part of this PR, I also added the &lt;code&gt;declare(strict_types=1)&lt;/code&gt; directive everywhere in my code. This directive changes the behavior of type hints: with it, passed values are no longer silently casted (if possible) to the type-hinted, required type, but instead they &lt;strong&gt;trigger an immediate error if the type doesn&amp;rsquo;t match&lt;/strong&gt;; for example, passing a &lt;code&gt;&amp;quot;10&amp;quot;&lt;/code&gt; string into a &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; type hint will no longer trigger an automatic conversion to &lt;code&gt;10&lt;/code&gt; or &lt;code&gt;10.0&lt;/code&gt;, but trigger an error.&lt;/p&gt;

&lt;p&gt;I would admit that this is a matter of personal preference, and I would not suggest to use this everywhere, especially if there isn&amp;rsquo;t a very thorough test coverage; it may lead to unneeded failures in very unsuspecting places, and it may cause friction when intergrating code with external libraries that take advantage of the implicit type casting that PHP has always done.&lt;/p&gt;

&lt;p&gt;But even in this little use case, &lt;a href=&#34;https://travis-ci.org/facile-it/paraunit/jobs/236293288&#34;&gt;it lead to discover a small issue&lt;/a&gt; with an outdated test code, were I was &lt;strong&gt;passing an empty string instead of a boolean&lt;/strong&gt;: that happened because I refactored a constructor some time ago, and I forgot to update the tests, and I missed it since the &lt;strong&gt;tests were not failing&lt;/strong&gt;. The error was even well highlighted by my IDE now, but before it was casted silently to a bool, and it matched the expected behavior by sheer luck!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/visual-debt-typehints/phpstorm-error-highlight.png&#34; alt=&#34;The error highlighted in PHPStorm&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Type hints and other new PHP language construct help writing more cohesive, rigid code, that may lead to some &amp;ldquo;pain&amp;rdquo; while writing code and (mostly) tests; but this effort is just &lt;strong&gt;paying in advance&lt;/strong&gt;: a lot of bugs get discovered earlier, and refactoring and changing code become easier, since pieces of code that doesn&amp;rsquo;t match anymore are more visible.&lt;/p&gt;

&lt;p&gt;In the example PR, the amount of changed code that is not method signatures is trivial, but I drastically reduced the amount of possible deviations that my code could take if a wrong value is passed through it, and I fixed and tested a few additional cases that I was forgetting about. Also, the usage of the &lt;code&gt;declare(strict_types=1)&lt;/code&gt; enforces even further this approach, raising the confidence that I have in the codebase.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Please mutate responsibly: 3 ways to improve your mutable objects</title>
      <link>https://engineering.facile.it/blog/eng/please-mutate-responsibly-3-ways-to-improve-your-mutable-objects/</link>
      <pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/please-mutate-responsibly-3-ways-to-improve-your-mutable-objects/</guid>
      <description>

&lt;p&gt;Maintaining &lt;strong&gt;state&lt;/strong&gt; is the main cause of complexity and headaches in software development: without a careful consideration of state, our projects will inevitably become impossible to understand. In fact, various development techniques and programming styles are mainly there to handle state in a responsible way: for example, &lt;a href=&#34;https://en.wikipedia.org/wiki/Monad_(functional_programming)&#34;&gt;&lt;strong&gt;monads&lt;/strong&gt;&lt;/a&gt;, as used in functional programming, are often employed for this very task. A good general way of managing state is trying to make it &lt;strong&gt;immutable&lt;/strong&gt;, either through the use &lt;a href=&#34;https://en.wikipedia.org/wiki/Value_type&#34;&gt;value types&lt;/a&gt;, that is, types which instances are passed around with &lt;a href=&#34;https://en.wikipedia.org/wiki/Object_copying#Deep_copy&#34;&gt;deep copy&lt;/a&gt; semantics, or simple &lt;em&gt;immutable objects&lt;/em&gt;, which have reference semantics but because they&amp;rsquo;re immutable their state is fixed.&lt;/p&gt;

&lt;p&gt;Unfortunately the &lt;em&gt;processes&lt;/em&gt; we usually represent in code are all but immutable: the state of any running software is probably going to change as time passes, as a result of &lt;em&gt;foreign interactions&lt;/em&gt;, a.k.a., &lt;em&gt;side effects&lt;/em&gt;. This means that something, somewhere has to mutate, and to be more precise we can say that the information stored in a certain object is going to change: actually, an &lt;strong&gt;information&lt;/strong&gt; by itself is a &lt;strong&gt;constant&lt;/strong&gt; value, but from time to time that object is going to store different pieces of information, some are going to be new, others are going to be outdated. So there&amp;rsquo;s no escape from mutation: the point is to mutate &lt;strong&gt;responsibly&lt;/strong&gt;, that is, to not be reckless with our mutable objects, and treat them in a special way so that we can still reason about our code and easily understand the state of our system at any given moment.&lt;/p&gt;

&lt;p&gt;The already cited techniques based on monads represent a good way to solve the problem, but monads only really work in a functional programming context, something that&amp;rsquo;s not everyone&amp;rsquo;s cup of tea, and to be really productive while using them you need to &lt;em&gt;think in terms of monads&lt;/em&gt;, and treat them as primitive objects. I don&amp;rsquo;t want to talk about monads or functional programming in general, my focus for this article is analyzing mutability in software, while identifying common techniques that can be leveraged in any programming language/paradigm to improve our code. In particular I want to talk about 3 specific problems that arise while working with mutable objects, and 3 solutions to address them. To quickly summarize, my suggestions will be the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;be idempotent;&lt;/li&gt;
&lt;li&gt;react to change;&lt;/li&gt;
&lt;li&gt;proceed one-way only.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s see each one of them in detail by developing a concrete example: an object that represents a &lt;em&gt;payment process&lt;/em&gt;, which at any moment can be in various states, like &lt;em&gt;possible&lt;/em&gt;, &lt;em&gt;started&lt;/em&gt;, &lt;em&gt;working&lt;/em&gt;, &lt;em&gt;succeeded&lt;/em&gt; and &lt;em&gt;failed&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;be-idempotent&#34;&gt;Be idempotent&lt;/h2&gt;

&lt;p&gt;To mutate an object from the outside we usually &lt;em&gt;tell&lt;/em&gt; the object to &lt;em&gt;do&lt;/em&gt; something. If we truly want to respect the object-oriented paradigm, and in particular if we don&amp;rsquo;t want to violate &lt;strong&gt;encapsulation&lt;/strong&gt;, we shouldn&amp;rsquo;t make assumptions about the internal state of a certain object after a certain method call; still, we cannot help but making assumptions about the way our entire &lt;em&gt;system&lt;/em&gt; is going to work after a method call, otherwise it would be impossible to reason about code. But if our changes are &lt;em&gt;incremental&lt;/em&gt;, it&amp;rsquo;s going to be really hard to understand the system even after a simple method call. Not all changes are created equal: if the resulting system&amp;rsquo;s state is affected by the previous one, before the change takes place, then it&amp;rsquo;s going to be basically impossible to reason about the system after the change, because in our reasoning we should take into account all the possible conditions the system was in. An incremental change, for example a method call to &lt;em&gt;increase a counter&lt;/em&gt;, will overload our mind of conditional paths and will cause bugs.&lt;/p&gt;

&lt;p&gt;For example, for our &lt;code&gt;PaymentProcess&lt;/code&gt; we don&amp;rsquo;t want to be able to generically &lt;em&gt;advance&lt;/em&gt; the payment state: we want to advance it to a particular stage, with a clean method call that should be &lt;a href=&#34;https://en.wikipedia.org/wiki/Idempotence&#34;&gt;&lt;em&gt;idempotent&lt;/em&gt;&lt;/a&gt;, that is, calling it 1 time, 2 times or 100 times &lt;strong&gt;has to be the same&lt;/strong&gt;. This also means that if more objects call the same method, it will be like if only one object called it, and this will completely remove a running cause of bugs: multiple, uncoordinated interactions of the same type with an object. Idempotence is a simple concept, but it&amp;rsquo;s extremely powerful: with it, we don&amp;rsquo;t need to keep track if a particular operation has already occurred (thus saving some state), but to properly implement it we need the correct semantics: while &lt;em&gt;delta&lt;/em&gt; operations are very frequent in real life (think about increasing the volume of a TV set) and are usually harmless, they can be dangerous in software development, an in general it&amp;rsquo;s important to understand the what &lt;em&gt;feels&lt;/em&gt; natural in real life is not necessarily a good thing in software engineering, or engineering in general.&lt;/p&gt;

&lt;p&gt;Also, notice that while an idempotent method call will always have the same result on a particular instance, it doesn&amp;rsquo;t mean that will have the same result on &lt;em&gt;different&lt;/em&gt; instances - more on this later.&lt;/p&gt;

&lt;h2 id=&#34;react-to-change&#34;&gt;React to change&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.reactivemanifesto.org&#34;&gt;Reactive programming&lt;/a&gt; has been big the last few years, and that&amp;rsquo;s mostly thanks both to the popularity achieved by functional programming in OOP circles, and to the diffusion of architectures based on microservices. But the idea of &lt;em&gt;being reactive&lt;/em&gt; in software development has been around for much more than that: for example, the &lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;&lt;strong&gt;observer pattern&lt;/strong&gt;&lt;/a&gt; has been there for decades, and the basic underlying idea is that of &lt;em&gt;connecting&lt;/em&gt; objects by establishing relations between them in which a state change is automatically propagated to a collection of &lt;em&gt;observers&lt;/em&gt;. It is responsibility of an observer to react to what just happened, while the &lt;em&gt;observable&lt;/em&gt; object doesn&amp;rsquo;t really care about what the others will do. This will allow us to achieve the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a nice &lt;em&gt;decoupling&lt;/em&gt; between a mutable object and other objects that for any reason are interested in its mutation; no custom interface will be needed, just a simple fixed method (like &lt;code&gt;next&lt;/code&gt;) to pass around the new information;&lt;/li&gt;
&lt;li&gt;a more &lt;em&gt;declarative&lt;/em&gt; code style, in which our method calls will only describe the intent of connecting one or more objects to a chain of reactions (and &lt;a href=&#34;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&#34;&gt;functional reactive programming&lt;/a&gt; is particularly good a that).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;About our payment example, whatever object is interested in a change of state, like for example UI objects the will show different views to the user based on the current payment stage, should really subscribe to our payment object to receive &lt;em&gt;signals&lt;/em&gt; about its mutation: the payment object itself should then send these changes to the observers. Notice that I used the  word &lt;em&gt;send&lt;/em&gt; and not &lt;em&gt;broadcast&lt;/em&gt;: the change of state of a particular object should usually not be treated as an all-encompassing &lt;em&gt;event&lt;/em&gt;. Events are really about application wide changes (like a phone call during the execution of a mobile application): there are many ways to implement our observables and observers, the point is simply to have a clean, fixed API to &lt;em&gt;emit&lt;/em&gt; an information, and &lt;a href=&#34;http://reactivex.io&#34;&gt;ReactiveX&lt;/a&gt; could be a nice starting point to get an idea about the possible APIs.&lt;/p&gt;

&lt;h2 id=&#34;proceed-one-way-only&#34;&gt;Proceed one-way only&lt;/h2&gt;

&lt;p&gt;This might be controversial but it&amp;rsquo;s extremely important. Consider the following case: our payment process object has idempotent methods and a reactive API, so a view controller object can keep a UI updated and send back user interactions to advance the process. But while the process is in &amp;ldquo;working&amp;rdquo; stage something goes wrong and the process fails: not a problem, we actually considered the &amp;ldquo;failed&amp;rdquo; stage, so the &lt;code&gt;PaymentProcess&lt;/code&gt; is updated accordingly. But we would actually like to retry the payment, and of course update everything accordingly in our reactive chain. What should we do? Set our &lt;code&gt;PaymentProcess&lt;/code&gt; back to &amp;ldquo;working&amp;rdquo;? That would be possible, but it&amp;rsquo;s going to make everything more complex, because all the observers should in theory take into account the fact the this is not the first attempt to pay (the UI for example could show a &amp;ldquo;retry&amp;rdquo; message instead of the usual one).&lt;/p&gt;

&lt;p&gt;In general, we want to &lt;em&gt;solve&lt;/em&gt; a state problem, we don&amp;rsquo;t want to distribute it to multiple objects.&lt;/p&gt;

&lt;p&gt;Another case could be a complete stop of the payment process (the user could cancel it, for example, or the session could expire): we don&amp;rsquo;t want to bring back the &lt;code&gt;PaymentProcess&lt;/code&gt; instance, forcing all observer to do some kind of cleanup. In any case, a process that goes back and forth makes reasoning about code really hard, because &lt;strong&gt;it makes the future more complex&lt;/strong&gt;: all the objects that depend on a mutable object are going to be easier to implement if we can assume that the mutability will only proceed in one direction. Of course this is not easy to implement, but in this case it&amp;rsquo;s really natural to think about it: if the milk is running out in the evening, I cannot expect the bottle to magically refill for the morning, so I should start thinking about a different breakfast. Processes that are invertible usually require some form of external, high-level coordination, and from an architectural standpoint the idea of an object that mutates in any possible way might seem harmless: but at the implementation level this will cause problems, and bugs are in the implementation, not in the architecture. While implementing new features, refactoring, debugging or simply studying a codebase we reason about the code, not the architecture, and &lt;em&gt;coordinator&lt;/em&gt; objects are classic jack-of-all-trades at the architecture level: but unfortunately, an implementation that requires external coordination is going to be more complex and error-prone, so it&amp;rsquo;s better to be clear about the mutation path for an object.&lt;/p&gt;

&lt;p&gt;In our particular case, we could consider one or more &amp;ldquo;retry&amp;rdquo; stages, or a single &amp;ldquo;retry&amp;rdquo; stage with an associated object that represents the number of retries. And about the possibility of going back to the beginning, in that case we should really &lt;strong&gt;discard the whole process&lt;/strong&gt;: the process owner, that would have likely activated the various accessory objects (like the ones for the UI) should &lt;em&gt;listen&lt;/em&gt; for an &amp;ldquo;abort&amp;rdquo; stage, that would make it kill everything and start the process anew. There might be performance concerns: to mutate objects is usually faster than recreating them, but again, it can be managed and it&amp;rsquo;s better to have cleaner, more understandable code from the beginning, so that it&amp;rsquo;s going to be easier to make fine calibrations in later stages, than to create a mess in the name of early optimizations.&lt;/p&gt;

&lt;p&gt;One final question: if the process is one-way only, what happens if some object tries to set it to a previous stage with a method call? &lt;strong&gt;Absolutely nothing&lt;/strong&gt;. The &lt;em&gt;ignore-if-impossible&lt;/em&gt; semantics is actually clean and reasonable, and we don&amp;rsquo;t need errors or exceptions to handle: even if this has to be taken into account at every method call, the important thing is to be &lt;strong&gt;clear&lt;/strong&gt; about it, and the alternative is much worse. This whole article could be summarized in the phrase &lt;strong&gt;&amp;ldquo;clear semantics are what makes mutability bearable&amp;rdquo;&lt;/strong&gt;. In this particular case, the fact that a method call is ignored or not doesn&amp;rsquo;t change our reasoning: I&amp;rsquo;m not going to make assumptions about the state of &lt;code&gt;PaymentProcess&lt;/code&gt; after the call, because I&amp;rsquo;m actually reacting to its changes in a separate context.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We considered a bunch of possible problems to think about when implementing mutable objects, and some options to confront them. Of course these ideas are purposely very general: every problem is different, every codebase is unique. But applying even just one of these techniques will most likely result in more clear and understandable code. I also didn&amp;rsquo;t talk about application-wide mutation, because that&amp;rsquo;s really an architectural thing; my goal is to raise awareness about the concept of mutation and variable instance properties in every single class. We should always &lt;strong&gt;avoid&lt;/strong&gt; mutation when possible, and concentrate our variable state in a few, carefully controlled places; but if we&amp;rsquo;re not careful, even a single mutating class in a multiple class project could wreak havoc, and force use to debug and fix a system that we thought was clean and well structured.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>No Country For If Else</title>
      <link>https://engineering.facile.it/blog/eng/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/no-country-for-if-else/</guid>
      <description>

&lt;p&gt;There is an &lt;strong&gt;unwanted guest&lt;/strong&gt; with us as we write code and build software projects: it&amp;rsquo;s the code that&amp;rsquo;s &lt;strong&gt;already written&lt;/strong&gt;, and we must take into account its complexity as the code base increases in size. High complexity of the existing code can make the following activities particularly difficult:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;understanding the meaning of old code, written by others or ourselves;&lt;/li&gt;
&lt;li&gt;tracing the causes of bugs, i.e. errors, in code;&lt;/li&gt;
&lt;li&gt;making changes to a certain procedure;&lt;/li&gt;
&lt;li&gt;adding features to existing structures;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even if we approach the development of new software with &lt;a href=&#34;https://en.wikipedia.org/wiki/Agile_software_development&#34;&gt;agile methodologies&lt;/a&gt;, we always have to deal with the existing code, and to do that we must at least be able to &lt;strong&gt;understand it without overexertion&lt;/strong&gt;. So when I talk about &lt;em&gt;complexity&lt;/em&gt; I am referring in particular to the difficulty with which a programmer can &lt;em&gt;reason about&lt;/em&gt; the existing code: the preface of the well-known academic textbook &lt;a href=&#34;http://deptinfo.unice.fr/~roy/sicp.pdf&#34;&gt;Structure and Interpretation of Computer Programs&lt;/a&gt; contains the following sentence:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I couldn&amp;rsquo;t agree more: the time spent by a programmer in writing new code is &lt;strong&gt;only a fraction&lt;/strong&gt; of his/her total working time; much of it is spent reading the existing code, to correct, extend, modify or simply understand it. Generating more understandable code, about which it&amp;rsquo;s easier to reason, we can more easily evaluate the &lt;strong&gt;correctness&lt;/strong&gt; of what we wrote so far or, if the obtained behavior is not the one expected, find the error. Of course this shouldn&amp;rsquo;t undo the techniques that we routinely use to test the correctness of software &lt;em&gt;a posteriori&lt;/em&gt;: indeed, no technical or scientific discipline is exempt from empirical tests, and in fact the empirical approach to software engineering is accepted in the academic community, as evidenced by the &lt;a href=&#34;http://static.springer.com/sgw/documents/1525357/application/pdf/10664_JournalMetrics_Flyer.pdf&#34;&gt;existence&lt;/a&gt; of the &lt;a href=&#34;http://link.springer.com/journal/10664&#34;&gt;Empirical Software Engineering&lt;/a&gt; journal. My personal position is in the middle: software testing is important, but it&amp;rsquo;s also important to think in advance about its correctness, to avoid causes of &lt;strong&gt;accidental complexity&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;index&#34;&gt;Index&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-importance-of-abstraction&#34;&gt;The importance of abstraction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#measuring-complexity&#34;&gt;Measuring complexity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-structured-solution&#34;&gt;Example: structured solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-oo-solution&#34;&gt;Example: OO solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-functional-solution&#34;&gt;Example: functional solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#an-empirical-validation&#34;&gt;An empirical validation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusions&#34;&gt;Conclusions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;the-importance-of-abstraction&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-importance-of-abstraction&#34;&gt;The importance of abstraction&lt;/h2&gt;

&lt;p&gt;As we&amp;rsquo;ve seen in a &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/&#34;&gt;previous article&lt;/a&gt;, rather than the inherent complexity related to the logic of our software, we must worry about the &lt;a href=&#34;http://shaffner.us/cs/papers/tarpit.pdf&#34;&gt;accidental complexity&lt;/a&gt; we introduce in the code by adopting &lt;strong&gt;non-optimal, pointlessly complicated solutions&lt;/strong&gt;: the excessive use of &lt;em&gt;if-else-for-switch&lt;/em&gt; control structures tends to make the code hard to understand, maintain and test; see for example the well-known &lt;a href=&#34;http://c2.com/cgi/wiki?ArrowAntiPattern&#34;&gt;Arrow Anti-Pattern&lt;/a&gt;. It should be noted that the introduction of &lt;a href=&#34;https://en.wikipedia.org/wiki/Structured_programming&#34;&gt;structured programming&lt;/a&gt;, i.e. programming based on the aforementioned control structures, was a &lt;strong&gt;major step forward&lt;/strong&gt; in software development between the &amp;lsquo;60s and the &amp;lsquo;70s: it allowed to program at a higher level of abstraction than the previous style, removing the need to manually manage code execution order with the &lt;a href=&#34;https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF&#34;&gt;infamous&lt;/a&gt; &lt;code&gt;goto&lt;/code&gt; statement.&lt;/p&gt;

&lt;p&gt;Software development paradigms change when programmers find themselves managing larger and more complex projects: to avoid being entangled by the excessive complexity of our own code, or code written by others that we still maintain, we have to work at &lt;strong&gt;higher levels of abstraction&lt;/strong&gt;. How much high? A good answer could be the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;at a high level of abstraction we can tell the system to do what we want, without specifying how to do it&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At an appropriate level of abstraction we can focus on the &lt;em&gt;what&lt;/em&gt; and let the system decide the &lt;em&gt;how&lt;/em&gt;. Obviously there&amp;rsquo;s no &amp;ldquo;maximum&amp;rdquo; level of abstraction, and as programmers we always find ourselves working &lt;strong&gt;halfway&lt;/strong&gt; between the moving electrical charges in a microprocessor, and the needs of our company&amp;rsquo;s business: however, working at a low abstraction level will greatly increase the risk of introducing accidental complexity, and we must be able to identify those cases. For example, when we use a control structure such as &lt;em&gt;if-else&lt;/em&gt; within a relatively large procedure, we are &lt;em&gt;manually&lt;/em&gt; making a decision based on the current state of our system: it would be much better to develop a software component, for example an object, which is able to &lt;strong&gt;make that kind of decision for us&lt;/strong&gt;; our role, at that point, will be to &lt;em&gt;declare&lt;/em&gt; the required functionality. Mixing the &lt;em&gt;what&lt;/em&gt; with the &lt;em&gt;how&lt;/em&gt; will make it particularly hard to understand what a block of code is going to do, because it can lead to the obfuscation of a procedure&amp;rsquo;s &lt;strong&gt;intent&lt;/strong&gt; - connected to the business logic - with the &lt;strong&gt;implementation details&lt;/strong&gt;, which are separate concepts, often completely independent (the same intention can be expressed with different lower level implementations).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple example. Suppose we have the following function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue1 (value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	var x: A?
	if cond1 == true {
		if cond2 == true {
			x = nil
		}
		else {
			x = value
		}
	}
	else {
		if cond2 == true {
			x = value
		}
		else {
			x = nil
		}
	}
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the expressed intent is rather simple, what&amp;rsquo;s really going on is not immediately obvious; let&amp;rsquo;s analyze the function step-by-step:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a variable &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;A?&lt;/code&gt; is declared;&lt;/li&gt;
&lt;li&gt;the first condition is checked:

&lt;ul&gt;
&lt;li&gt;if the first condition is true, then the second condition is checked:

&lt;ul&gt;
&lt;li&gt;if the second condition is true, then the variable is set to &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;if the second condition is false, then the variable is set to &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;if the first condition is false, the second condition is checked:

&lt;ul&gt;
&lt;li&gt;if the second condition is true, then the variable is set to &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;if the second condition is false, then the variable is set to &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;the variable &lt;code&gt;x&lt;/code&gt; is returned;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To think about it, the intent is the following: return &lt;code&gt;value&lt;/code&gt; if the conditions are different from each other, otherwise return &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue2 (value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	return cond1 != cond2 ? value : nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have greatly simplified the function, making it easier to understand &lt;strong&gt;just by looking at it&lt;/strong&gt; once. But in a more complex case, with many different conditions and possible code routes, it may not suffice to just try and simplify the conditions.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;measuring-complexity&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;measuring-complexity&#34;&gt;Measuring complexity&lt;/h2&gt;

&lt;p&gt;A unit of measure often taken into account in assessing the complexity of a method or function is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Cyclomatic_complexity&#34;&gt;cyclomatic complexity&lt;/a&gt; (CC): it&amp;rsquo;s defined as the degree of complexity generated by the use of multiple control structures in a procedure. You can calculate the number of CC for a structured procedure by representing it with a &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_graph&#34;&gt;directed graph&lt;/a&gt; and counting the number of nodes and arcs. For example, we can represent the &lt;code&gt;optionalValue1&lt;/code&gt; function with the following graph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(value,cond1,cond2)]
|
|-&amp;gt; [var x] -&amp;gt; [cond1 == true ?]
               |
               |-y-&amp;gt; [cond2 == true ?]
               |     |
               |     |-y-&amp;gt; [x = nil] --------|
               |     |-n-&amp;gt; [x = value] ------|
               |                             |
               |-n-&amp;gt; [cond2 == true ?]       |
                     |                       |
                     |-y-&amp;gt; [x = value] ------|
                     |-n-&amp;gt; [x = nil] --------|
                                             |-&amp;gt; [return x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a single connected graph, the number of CC is calculated according to the following formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC = [number of arcs] - [number of nodes] + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the &lt;code&gt;defaultValue1&lt;/code&gt; you can see that CC = 4. Apparently the simplified version&lt;code&gt;defaulValue2&lt;/code&gt; has a lower cyclomatic complexity, but in reality, as indicated in T.J.McCabe&amp;rsquo;s &lt;a href=&#34;http://www.literateprogramming.com/mccabe.pdf&#34;&gt;original article&lt;/a&gt;, CC can only be calculated for a &lt;em&gt;completely structured&lt;/em&gt; procedure, that is a procedure with a single entry point and a single exit point; CC should also take into account &lt;strong&gt;all the possible cases&lt;/strong&gt; for a condition, and &lt;code&gt;if cond1 != cond2&lt;/code&gt; has precisely four possible cases. A dissertation of possible evolutions of CC, considering multiple entry/exit points for a module, is a available &lt;a href=&#34;http://www.acis.pamplin.vt.edu/faculty/tegarden/wrk-pap/SQJ.PDF&#34;&gt;here&lt;/a&gt;. Thus, we won&amp;rsquo;t keep account of CC in the rest of the article for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the complexity that interests us is the one related to the &amp;ldquo;understandability&amp;rdquo; of a function, and unstructured patterns (such as &lt;code&gt;guard clause&lt;/code&gt;, early &lt;code&gt;return&lt;/code&gt; or conditional expressions like the one generated by the ternary operator &lt;code&gt;?:&lt;/code&gt;) can often make a function or method easier to understand;&lt;/li&gt;
&lt;li&gt;the goal is to write a program by composing many small functions whose complexity is the &lt;strong&gt;minimum possible&lt;/strong&gt;, e.g. no control structures, so it will have little value to measure the number of CC for each function;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, it seemed important to mention cyclomatic complexity in this article, but rather than &lt;em&gt;measuring&lt;/em&gt; accidental complexity, we are interested in &lt;strong&gt;removing it completely&lt;/strong&gt; by replacing conditional statements, often used of structured programming, with something else. Notice that a conditional &lt;em&gt;expression&lt;/em&gt; is a &lt;strong&gt;simpler&lt;/strong&gt; concept than a conditional &lt;em&gt;statement&lt;/em&gt;: in the former, the entire expression simply returns something based on one or more conditions; in the latter, based on some state, the code could contain various statements, i.e., commands that could be executed or not.&lt;/p&gt;

&lt;p&gt;Say you have a function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func getCorrectValueConsideringConditions &amp;lt;A&amp;gt; (cond1: Condition&amp;lt;A&amp;gt;, cond2: Condition&amp;lt;A&amp;gt;, cond3: Condition&amp;lt;A&amp;gt; ...) -&amp;gt; A? {
	/// do stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case we have a large number of conditions attached to a value of type &lt;code&gt;A&lt;/code&gt;, and we might need to evaluate each of these conditions with several &lt;em&gt;if-else&lt;/em&gt; and/or nested &lt;em&gt;switch&lt;/em&gt; statements. One way to simplify this problem could consist in &lt;em&gt;abstracting&lt;/em&gt; the concept of &lt;em&gt;condition&lt;/em&gt;, turning it into a &lt;em&gt;static relationship&lt;/em&gt; between a few parameters and a value of type &lt;code&gt;A&lt;/code&gt;: we should therefore create a system that is able to &lt;em&gt;solve&lt;/em&gt; any number of relations, possibly in &lt;strong&gt;any order&lt;/strong&gt;, and according to them deduce the resulting value.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see a practical example.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;example-structured-solution&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;example-structured-solution&#34;&gt;Example: structured solution&lt;/h2&gt;

&lt;p&gt;A person goes to the employment office to find a job: according to certain attributes (job preferences, young/old, number of children younger than 18) the person could be sent to a certain desk to choose a job, or outside in case no job is available for a person with those attributes. Here is the complete procedure (the realism is not important, it&amp;rsquo;s just an example):&lt;/p&gt;

&lt;p&gt;A person &lt;strong&gt;p1&lt;/strong&gt; comes to the desk &lt;strong&gt;d1&lt;/strong&gt; to seek employment; &lt;strong&gt;p1&lt;/strong&gt; has a list of job preferences, but could also accept other jobs outside the list; &lt;strong&gt;p1&lt;/strong&gt; also has a list of jobs that would certainly never accept;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; is young you get from &lt;strong&gt;p1&lt;/strong&gt; a list &lt;strong&gt;l1&lt;/strong&gt; of preferences;

&lt;ul&gt;
&lt;li&gt;if &lt;strong&gt;l1&lt;/strong&gt; is too small, you ask &lt;strong&gt;p1&lt;/strong&gt; to enlarge the list with secondary preferences;&lt;/li&gt;
&lt;li&gt;you match the preferences with the available jobs and get list &lt;strong&gt;l2&lt;/strong&gt; of jobs to choose;&lt;/li&gt;
&lt;li&gt;if &lt;strong&gt;l2&lt;/strong&gt; is empty, you ask &lt;strong&gt;p1&lt;/strong&gt; if they want the full list of the positions;&lt;/li&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; chooses a job, they&amp;rsquo;re sent to desk &lt;strong&gt;d2&lt;/strong&gt; to continue the procedure;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; is elderly, you ask &lt;strong&gt;p1&lt;/strong&gt; to choose from the list &lt;strong&gt;l3&lt;/strong&gt; of suitable jobs for older people;

&lt;ul&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; chooses a job, they&amp;rsquo;re sent to desk &lt;strong&gt;d3&lt;/strong&gt; to continue the procedure;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; has children, in any case the list of available jobs will be affected by the number of children:

&lt;ul&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; has one child younger than 18, they will choose a job from the list &lt;strong&gt;l4&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; has two children younger than 18, they will choose a job from the list &lt;strong&gt;l5&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;in the two previous cases, if &lt;strong&gt;p1&lt;/strong&gt; chooses a job, &lt;strong&gt;p1&lt;/strong&gt; is sent to desk &lt;strong&gt;d4&lt;/strong&gt; to continue with the procedure;&lt;/li&gt;
&lt;li&gt;if &lt;strong&gt;p1&lt;/strong&gt; has three or more children younger than 18, &lt;strong&gt;p1&lt;/strong&gt; is sent to desk &lt;strong&gt;d5&lt;/strong&gt; to continue the procedure;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &amp;ldquo;structured&amp;rdquo; approach to the problem could consist in writing a function in which the entire procedure is expressed with a series of &lt;em&gt;if-else&lt;/em&gt; statements, or &lt;em&gt;switch&lt;/em&gt; in the case of the number of children.&lt;/p&gt;

&lt;p&gt;The project related to this article is available on &lt;a href=&#34;https://github.com/broomburgo/NoCountryForIfElse&#34;&gt;github&lt;/a&gt;: I strongly recommend to check the code as the article goes on; &lt;code&gt;.swift&lt;/code&gt; files are just text files, and can be opened with any text editor. In the file &lt;code&gt;common.swift&lt;/code&gt; you&amp;rsquo;ll find common structures and functions to all the proposed solutions. In particular, we will represent a &amp;ldquo;person&amp;rdquo; with &lt;code&gt;struct Person&lt;/code&gt;, basically a immutable &lt;em&gt;value object&lt;/em&gt; that collects the various attributes considered in the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Person {
Â Â Â Â 
Â Â Â Â let name: String
Â Â Â Â let isYoung: Bool
Â Â Â Â let childrenCount: Int
Â Â Â Â let likedJobsMain: [String]
Â Â Â Â let likedJobsSecondary: [String]
Â Â Â Â let dislikedJobs: [String]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea is to write a function called &lt;code&gt;placeNameForPerson&lt;/code&gt;, returning the next destination&amp;rsquo;s name for the input person: the destination could be another desk &lt;code&gt;d2, d3, d4, d5&lt;/code&gt;, or &lt;code&gt;outside&lt;/code&gt; in case the person leaves the employment agency without a job. &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; returns the name of the destination considering the input &lt;code&gt;Person&lt;/code&gt; and also requires a second input, a &lt;code&gt;DeskWithJobs&lt;/code&gt;, i.e. a desk with several lists of available jobs, considering the various cases. In the structured solution, the entire execution logic is written in the function &lt;code&gt;placeNameForPerson_structured&lt;/code&gt;, and is in fact based upon nested conditional tests.&lt;/p&gt;

&lt;p&gt;We can immediately see that it is rather hard to understand what happens in the function just by reading it once: probably, in a &amp;ldquo;real&amp;rdquo; software, a function like this would probably be annotated with &lt;strong&gt;several comments&lt;/strong&gt;. In addition, it can be easily seen that to trace a bug in a function like this would require a step-by-step debugging procedure, because the large number of conditions makes the function basically not testable in an efficient way. Finally, changing conditions or introducing more of them would probably be really hard.&lt;/p&gt;

&lt;p&gt;The underlying problem is actually due to the fact that, with a structured approach, we&amp;rsquo;re &lt;strong&gt;mixing the intent with the implementation&lt;/strong&gt;: in this case the intent is to associate groups of conditions to specific results, but these relations are &amp;ldquo;hidden&amp;rdquo; within the code and must be deduced from it; for example, if we are asked what is the door for an elderly person with two children, we&amp;rsquo;d be forced to follow the flow of code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;because the first condition is related to the number of children, we immediately enter the branch &lt;code&gt;childrenCount != 0&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;at this point we enter the &lt;code&gt;case 2&lt;/code&gt; for the number of children;&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s a condition for checking that there&amp;rsquo;s a job available;&lt;/li&gt;
&lt;li&gt;a positive choice would lead to the &amp;ldquo;d4&amp;rdquo; desk;&lt;/li&gt;
&lt;li&gt;where&amp;rsquo;s the &amp;ldquo;young/old&amp;rdquo; condition? Is there a bug? By analyzing the branch &lt;code&gt;childrenCount == 0&lt;/code&gt; we can verify that this condition is actually checked, but it&amp;rsquo;s simply irrelevant for the other branch;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is a relatively long way to understand one simple thing, and it is noteworthy that if we wanted to make changes to the procedure, we should always run the entirety of it to make sure we covered all possible cases and there are no conflicts or ambiguities.&lt;/p&gt;

&lt;p&gt;We can do better.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;example-oo-solution&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;example-oo-solution&#34;&gt;Example: OO solution&lt;/h2&gt;

&lt;p&gt;OO design is a often a work of &lt;strong&gt;both reason and creativity&lt;/strong&gt;: frequently, a same problem can be solved with multiple OO approaches. As said before, our intent is to &lt;em&gt;abstract&lt;/em&gt; the concept of &lt;em&gt;condition&lt;/em&gt;; considering this approach, let&amp;rsquo;s try and establish some foundation, in order to identify the responsibilities and behaviors to be assigned to each class:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we want to represent each condition as if it were a single &lt;em&gt;check&lt;/em&gt; separated from the others, e.g. with a &lt;code&gt;Check&lt;/code&gt; type characterized by methods that verify whether a given person passes a step or not;&lt;/li&gt;
&lt;li&gt;we want to represent separately the checks related to a person&amp;rsquo;s attribute, like the number of children, to those related to the list of jobs to choose from;&lt;/li&gt;
&lt;li&gt;we want to build objects that are able to combine multiple checks into a single check;&lt;/li&gt;
&lt;li&gt;we want to create an object that represents a list of checks, and is able to assess whether the person is going to pass one and only one of those checks, or no check;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The file &lt;code&gt;oo.swift&lt;/code&gt; contains the complete implementation of the OO solution. We define a &lt;code&gt;protocol PersonCheckType&lt;/code&gt;, i.e., an interface that declares a &lt;code&gt;personIsValid&lt;/code&gt; method that returns &lt;code&gt;true&lt;/code&gt; if a certain &lt;code&gt;Person&lt;/code&gt; passes the check:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol PersonCheckType {
Â Â Â Â func personIsValid(person: Person) -&amp;gt; Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then some classes implementing the &lt;code&gt;PersonCheckType&lt;/code&gt; protocol are declared, which individually test the various inherent attributes of a &lt;code&gt;Person&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The type &lt;code&gt;JobsType&lt;/code&gt; simply declares a &lt;code&gt;availableJobs&lt;/code&gt; property to collect the available jobs: from it more &lt;em&gt;checks&lt;/em&gt; are derived, also of type &lt;code&gt;PersonCheckType&lt;/code&gt;, that verify whether a person is valid from the point of view of preferred jobs.&lt;/p&gt;

&lt;p&gt;Finally, the type &lt;code&gt;NextDeskType&lt;/code&gt; declares a &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; method by which you can define what the name of the next desk for a person will be; the method returns &lt;code&gt;String?&lt;/code&gt; because maybe there&amp;rsquo;s no desk for a certain person:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol NextDeskType {
Â Â Â Â func nextDeskNameForPerson(person: Person) -&amp;gt; String?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From &lt;code&gt;NextDeskType&lt;/code&gt; we derive the following classes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CheckNode&lt;/code&gt;, which represents a node in the decision-making structure of the software;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CheckStructure&lt;/code&gt;, which represents the entire tree of nodes;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, the implementation of &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; in &lt;code&gt;CheckStructure&lt;/code&gt; corresponds exactly to the solution of the problem: find the name of destination desk.&lt;/p&gt;

&lt;p&gt;The idea is to create some simple &lt;strong&gt;unit checks&lt;/strong&gt;, using various classes of type &lt;code&gt;PersonCheckType&lt;/code&gt;, and combine those into concrete objects of the class &lt;code&gt;CheckNode&lt;/code&gt;, thus defining our &lt;code&gt;CheckStructure&lt;/code&gt;. In &amp;ldquo;pure&amp;rdquo; OO style, we defined classes called &lt;code&gt;ComposedCheck&lt;/code&gt; and &lt;code&gt;MultipleCheck&lt;/code&gt; to compose more checks into one, and &lt;code&gt;FailingCheck&lt;/code&gt; to encapsulate a check that is required to fail. None of the implemented methods has conditional structures related to the &lt;em&gt;business logic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As an example, here&amp;rsquo;s the implementation for the class &lt;code&gt;ChildrenCountCheck&lt;/code&gt;, which validates a person considering the number of children:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ChildrenCountCheck: PersonCheckType {
    
    let childrenCount: Int
    init(_ childrenCount: Int) {
        self.childrenCount = childrenCount
    }
    
    func personIsValid(person: Person) -&amp;gt; Bool {
        return person.childrenCount == childrenCount
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;structure&lt;/code&gt; object defined in &lt;code&gt;main.swift&lt;/code&gt; contains the list of conditions, in the form of properly configured objects; as you can see, the list is easily readable and the conditions are clear: thus, we can &lt;em&gt;declare&lt;/em&gt; the intent, separated from the implementation details.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;example-functional-solution&#34;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;example-functional-solution&#34;&gt;Example: functional solution&lt;/h2&gt;

&lt;p&gt;In structuring the OO solution we have adopted a &lt;strong&gt;composition principle&lt;/strong&gt;: atomic objects with simple behavior, properly prepared, composed with each other in order to obtain more complex structures. In particular, each of our objects represents a specific &lt;em&gt;atomic behavior&lt;/em&gt;, that&amp;rsquo;s combined with others to obtain a &lt;em&gt;compound behavior&lt;/em&gt;. &lt;strong&gt;The abstraction holds&lt;/strong&gt;, and we can accept the fact that the objects we&amp;rsquo;re using are black boxes that encapsulate a single decision on a person: by creating a larger box with smaller boxes inside, we can define a more complex condition. However there are two problems specific to the OO approach:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;each class requires a lot of code just to build the &amp;ldquo;decision-in-the-box&amp;rdquo; abstraction;&lt;/li&gt;
&lt;li&gt;objects&amp;rsquo; composition is based on the methods of the objects themselves, that results, again, in writing a lot of code, which could obfuscate the intent;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can get the same result, namely to create a complex decision-making structure from simple components, more clearly by using &lt;strong&gt;functional programming&lt;/strong&gt;. The functional code is described in &lt;code&gt;functional.swift&lt;/code&gt;. We always start by the immutable &lt;code&gt;struct Person&lt;/code&gt; and create, for convenience, another simple data container, &lt;code&gt;struct DeskNode&lt;/code&gt;, which simply pairs the name of a node to the name of a optional destination desk. For the rest, we will exclusively define functions, by modeling the entire problem as a series of data transformations.&lt;/p&gt;

&lt;p&gt;In this case &lt;code&gt;PersonCheck&lt;/code&gt; is a &lt;strong&gt;type of function&lt;/strong&gt;, which associates a &lt;code&gt;Person&lt;/code&gt; to a &lt;code&gt;Bool&lt;/code&gt;. We also define the type of function &lt;code&gt;PersonNode&lt;/code&gt;, which associates a certain &lt;code&gt;DeskNode&lt;/code&gt; to a &lt;code&gt;Person&lt;/code&gt;, and that has basically the purpose that the &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; method had in the OO solution.&lt;/p&gt;

&lt;p&gt;Finally, we represent the various &amp;ldquo;nodes&amp;rdquo; with a function of type &lt;code&gt;JobsNode&lt;/code&gt;, which constructs a &lt;code&gt;PersonNode&lt;/code&gt; based on a certain &lt;code&gt;PersonCheck&lt;/code&gt;: in this way, to build a list of &lt;code&gt;PersonNode&lt;/code&gt; we&amp;rsquo;ll just need to apply the various checks (&lt;code&gt;PersonCheck&lt;/code&gt;) to the respective nodes (&lt;code&gt;JobsNode&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The method most frequently adopted in functional programming to compose functions is to use custom operators. We want, for example, compose the various &lt;code&gt;PersonCheck&lt;/code&gt; as if we were composing simple &lt;code&gt;Bool&lt;/code&gt; values, by defining &lt;strong&gt;AND&lt;/strong&gt; and &lt;strong&gt;OR&lt;/strong&gt; operators. By association with the classic &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; we define respectively the operators &lt;code&gt;&amp;lt;&amp;amp;&amp;gt;&lt;/code&gt; is &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, also copying &lt;a href=&#34;https://en.wikipedia.org/wiki/Operator_associativity&#34;&gt;precedence and associativity&lt;/a&gt; rules from the standard library. To improve readability and clarity of functions&amp;rsquo; composition, we also declare a &lt;em&gt;function application&lt;/em&gt; operator, defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;infix operator &amp;lt;*&amp;gt; {
Â Â Â Â associativity left
Â Â Â Â precedence 100
}
func &amp;lt;*&amp;gt; &amp;lt;A, B&amp;gt; (left: A -&amp;gt; B, right: A) -&amp;gt; B {
Â Â Â Â return left(right)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see from the definition that the operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; basically applies an argument (positioned to the right of the operator) to a certain function (positioned to the left of the operator): thus, it represents an alternative way to apply a function other than writing its arguments in &lt;strong&gt;parentheses&lt;/strong&gt;, and is particularly suitable for improving the readability of the code when we use &lt;a href=&#34;https://en.wikipedia.org/wiki/Higher-order_function&#34;&gt;higher-order functions&lt;/a&gt;. We can see these operators at work in &lt;code&gt;main.swift&lt;/code&gt;, when we define our nodes, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;node(&amp;quot;old&amp;quot;, nextDeskName: &amp;quot;d3&amp;quot;)
Â Â Â Â &amp;lt;*&amp;gt; oldCheck
Â Â Â Â &amp;lt;&amp;amp;&amp;gt; mustFail(childrenChecks)
Â Â Â Â &amp;lt;&amp;amp;&amp;gt; checkExtendedJobs(availableJobsElderly)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above-mentioned function builds a &lt;code&gt;PersonNode&lt;/code&gt; named &amp;ldquo;old&amp;rdquo; that returns the desk &amp;ldquo;d3&amp;rdquo; if the input &lt;code&gt;Person&lt;/code&gt; complies with following conditions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oldCheck&lt;/code&gt;: the person is elderly;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mustFail(childrenChecks)&lt;/code&gt;: the person must not have children;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkExtendedJobs(availableJobsElderly)&lt;/code&gt;: the senior citizens jobs set and the person&amp;rsquo;s favorite jobs set must have some intersection;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At first glance it may seem difficult to understand, but you just need to get the basic abstractions on which functional composition is based in order to appreciate its &lt;strong&gt;power and expressiveness&lt;/strong&gt;. The array &lt;code&gt;nodes&lt;/code&gt;, in &lt;code&gt;main.swift&lt;/code&gt;, contains all the nodes of the problem, represented as functions: compared to the OO solution contained in &lt;code&gt;structure&lt;/code&gt;, the functional one is more clear and readable.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;an-empirical-validation&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;an-empirical-validation&#34;&gt;An empirical validation&lt;/h2&gt;

&lt;p&gt;In designing the &amp;ldquo;OO&amp;rdquo; and &amp;ldquo;functional&amp;rdquo; solutions it was made the specific choice that the order in which the checks occur should be irrelevant: in this way we can remove a known cause of accidental complexity, the one of &amp;ldquo;control&amp;rdquo;, i.e, the &lt;strong&gt;order&lt;/strong&gt; in which the operations are carried out (we talked about it &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/#cause-di-complessita&#34;&gt;here&lt;/a&gt;). To do this, you must have &lt;strong&gt;non-ambiguous&lt;/strong&gt; checks: at most one check must pass for a certain person. It&amp;rsquo;d be probably possible to write a formal method to prove that a given set of conditions is non-ambiguous, and then write a unit test based on such proof, but in this case an &lt;em&gt;empirical approach&lt;/em&gt; seems more suitable and &lt;strong&gt;easier&lt;/strong&gt; to implement.&lt;/p&gt;

&lt;p&gt;It was therefore choosen to use a &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt; approach: QuickCheck is a library for the &lt;a href=&#34;https://www.haskell.org&#34;&gt;Haskell&lt;/a&gt; language, that allows you to automatically test that certain functions satisfy certain properties. The idea is to verify that a particular function always behaves in the same way, testing it with &lt;strong&gt;a large number of random inputs&lt;/strong&gt;: in our case, the function is just the list of checks, and the input is a value of type &lt;code&gt;Person&lt;/code&gt;. To verify that the checks are not ambiguous we can just try them with a large number of randomly generated persons: if for a certain value of &lt;code&gt;Person&lt;/code&gt; two or more checks are positive, the test stops and the ambiguous checks&amp;rsquo; names are logged. In the case of two ambiguous checks, to solve the problem it will suffice to make one of them more specific, for example by requiring that the other fails. We will use here the term &lt;em&gt;QuickCheck&lt;/em&gt; to indicate the empirical test implemented, but in fact the original library does much more: please refer to the &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;linked&lt;/a&gt; page for all the information.&lt;/p&gt;

&lt;p&gt;The functions &lt;code&gt;quickCheck_functional&lt;/code&gt; and &lt;code&gt;quickCheck_oo&lt;/code&gt;  implement the required feature: they generate a large number of random &lt;code&gt;Person&lt;/code&gt;, and verify that the number of passed checks for each person is either 0 or 1. We can try this test by adding a new node. For example, suppose that at some point, after some time that the code was successfully used to solve the problem, you choose to add a new condition: there&amp;rsquo;s a special desk for older people with only one child. Notice that modifying the code of the function &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; would be rather complicated: we should probably &lt;strong&gt;change more than one decision branch&lt;/strong&gt;, adding the same condition at different points, and the likelyhood of error would be high. On the other side, with the other two solutions we just need to add a new node. However, after adding the node, by executing the program we will see that QuickCheck fails, printing the following message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ambiguous nodes: [1 child, 1 child old]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QuickCheck is informing us that the nodes called &amp;ldquo;one child&amp;rdquo; and &amp;ldquo;one child old&amp;rdquo; are &lt;strong&gt;ambiguous&lt;/strong&gt;: in fact, if the &lt;code&gt;Person&lt;/code&gt; has one child and is old, the check for both nodes will pass. To solve the problem it will suffice to introduce another condition in the &amp;ldquo;one child&amp;rdquo; node: the seniority check must fail.&lt;/p&gt;

&lt;p&gt;In the project you&amp;rsquo;ll also find a &lt;code&gt;quickCheck_consistency&lt;/code&gt; function, which performs a &lt;em&gt;sanity check&lt;/em&gt;: it verifies that the target desk for a large number of randomly generated &lt;code&gt;Person&lt;/code&gt; remains the same in the 3 cases: structured, oo and functional.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusions&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;We have seen three ways to solve the same relatively complex problem, and in two of them we were able to get a &lt;strong&gt;more manageable&lt;/strong&gt;, extensible and modifiable code by working at a &lt;strong&gt;higher level of abstraction&lt;/strong&gt;. In particular, the &amp;ldquo;functional&amp;rdquo; way allowed us to write more compact code, characterized by a more evident intent, at the (low) cost of an initial step of abstraction, represented by custom operators. But the key to the whole process is once again to be found in the aforementioned phrase in &lt;em&gt;Structure and Interpretation of Computer Programs&lt;/em&gt;, which I quote again:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Adopting a more &lt;strong&gt;declarative&lt;/strong&gt; style, where the &lt;em&gt;business logic&lt;/em&gt; code &amp;ldquo;declares the intent&amp;rdquo;, describing the &amp;ldquo;what&amp;rdquo; and not the &amp;ldquo;how&amp;rdquo;, you can write more clear and readable software. This software will probably also be more &lt;em&gt;testable&lt;/em&gt; because it is based on lower level &lt;strong&gt;atomic components&lt;/strong&gt;, easy to test individually, which are combined through patterns of composition, also easily testable and provable. The ultimate goal is to build software architectures that are able to &lt;strong&gt;automatically solve problems&lt;/strong&gt;, which are described in code by using &lt;strong&gt;basic building blocks&lt;/strong&gt;. Finally, we have seen how a mixed &amp;ldquo;reasoned&amp;rdquo; and &amp;ldquo;empirical&amp;rdquo; approach can give excellent results; &lt;em&gt;a priori&lt;/em&gt; reasoning and &lt;em&gt;a posteriori&lt;/em&gt; verification are both useful tools, but their union is particularly powerful: indeed, every scientific discipline requires both the logical-mathematical reasoning for the definition of the theories, and the experimental verification to test their validity.&lt;/p&gt;

&lt;p&gt;The tools are there, we just need to &lt;strong&gt;start using them&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>No Country For If Else</title>
      <link>https://engineering.facile.it/blog/ita/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/no-country-for-if-else/</guid>
      <description>

&lt;p&gt;C&amp;rsquo;Ã¨ un &lt;strong&gt;ospite indesiderato&lt;/strong&gt; che ci accompagna sempre mentre scriviamo codice e realizziamo progetti software: si tratta del &lt;strong&gt;codice giÃ  esistente&lt;/strong&gt;, e dobbiamo tener conto della sua complessitÃ  man mano che la &lt;em&gt;code base&lt;/em&gt; aumenta di dimensioni. Un&amp;rsquo;elevata complessitÃ  del codice puÃ² rendere le seguenti attivitÃ  particolarmente difficili:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;comprendere il significato di codice vecchio, scritto da altri o da se stessi;&lt;/li&gt;
&lt;li&gt;tracciare le cause di bug, cioÃ¨ errori, nel codice;&lt;/li&gt;
&lt;li&gt;eseguire modifiche a una certa procedura;&lt;/li&gt;
&lt;li&gt;aggiungere funzionalitÃ  a strutture giÃ  esistenti;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Anche approcciando lo sviluppo di nuovo software con &lt;a href=&#34;https://en.wikipedia.org/wiki/Agile_software_development&#34;&gt;metodologie agili&lt;/a&gt;, dobbiamo comunque fare i conti con il codice esistente, e per farlo dobbiamo almeno essere in grado di &lt;strong&gt;comprenderlo senza sforzi eccessivi&lt;/strong&gt;. Dunque quando parlo di &lt;em&gt;complessitÃ &lt;/em&gt; mi riferisco in particolare alla difficoltÃ  con la quale una programmatore Ã¨ in grado di &lt;em&gt;ragionare&lt;/em&gt; sul codice. La prefazione del noto testo accademico &lt;a href=&#34;http://deptinfo.unice.fr/~roy/sicp.pdf&#34;&gt;Structure and interpretation of computer programs&lt;/a&gt; contiene la seguente frase:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Non potrei essere piÃ¹ d&amp;rsquo;accordo: il tempo speso da un programmatore a scrivere nuovo codice rappresenta solo &lt;strong&gt;una minima parte&lt;/strong&gt; del suo tempo totale di lavoro; molto tempo Ã¨ passato a leggere il codice esistente, per correggerlo, estenderlo, modificarlo o semplicemente comprenderlo. Generando codice piÃ¹ comprensibile, sul quale sia piÃ¹ semplice ragionare, possiamo valutare piÃ¹ facilmente la &lt;strong&gt;correttezza&lt;/strong&gt; di quanto abbiamo scritto o, in caso di comportamento non atteso, trovare agevolmente l&amp;rsquo;errore. Ovviamente tutto questo non deve prescindere dalle tecniche che abitualmente utilizziamo per testare la correttezza del software &lt;em&gt;a posteriori&lt;/em&gt;: d&amp;rsquo;altronde, nessuna disciplina tecnico/scientifica Ã¨ esente da verifiche empiriche, e in effetti l&amp;rsquo;approccio empirico all&amp;rsquo;ingegneria del software Ã¨ preso in considerazione anche in ambito accademico, come dimostra l&amp;rsquo;&lt;a href=&#34;http://static.springer.com/sgw/documents/1525357/application/pdf/10664_JournalMetrics_Flyer.pdf&#34;&gt;esistenza&lt;/a&gt; della rivista &lt;a href=&#34;http://link.springer.com/journal/10664&#34;&gt;Empirical Software Engineering&lt;/a&gt;. La mia personale posizione Ã¨ nel mezzo: il testing Ã¨ importante, ma Ã¨ anche importante ragionare &lt;em&gt;a priori&lt;/em&gt; sul proprio design, sulla sua correttezza, e sulla presenza di eventuale &lt;strong&gt;complessitÃ  accidentale&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#l-importanza-dell-astrazione&#34;&gt;L&amp;rsquo;importanza dell&amp;rsquo;astrazione&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#misurare-la-complessita&#34;&gt;Misurare la complessitÃ &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-strutturata&#34;&gt;Esempio: soluzione strutturata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-oo&#34;&gt;Esempio: soluzione OO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-soluzione-funzionale&#34;&gt;Esempio: soluzione funzionale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#una-verifica-empirica&#34;&gt;Una verifica empirica&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusioni&#34;&gt;Conclusioni&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;l-importanza-dell-astrazione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;l-importanza-dell-astrazione&#34;&gt;L&amp;rsquo;importanza dell&amp;rsquo;astrazione&lt;/h2&gt;

&lt;p&gt;Come abbiamo visto in un &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/&#34;&gt;precedente articolo&lt;/a&gt;, piÃ¹ che della complessitÃ  intrinseca legata alla logica del nostro software, dobbiamo preoccuparci della &lt;a href=&#34;http://shaffner.us/cs/papers/tarpit.pdf&#34;&gt;complessitÃ  accidentale&lt;/a&gt; che introduciamo adottando &lt;strong&gt;soluzioni non ottimali e inutilmente complicate&lt;/strong&gt;: l&amp;rsquo;utilizzo eccessivo di strutture di controllo &lt;em&gt;if-else-for-switch&lt;/em&gt; tende a rendere il codice difficile da comprendere, da mantenere e da testare; si veda ad esempio il noto &lt;a href=&#34;http://c2.com/cgi/wiki?ArrowAntiPattern&#34;&gt;Arrow Anti-Pattern&lt;/a&gt;. Ãˆ da notare che l&amp;rsquo;introduzione della &lt;a href=&#34;https://en.wikipedia.org/wiki/Structured_programming&#34;&gt;programmazione &lt;em&gt;strutturata&lt;/em&gt;&lt;/a&gt;, cioÃ¨ quella basata proprio sulle strutture di controllo appena citate, ha rappresentato &lt;strong&gt;un grande passo avanti&lt;/strong&gt; nello sviluppo del software a cavallo tra gli anni &amp;lsquo;60 e &amp;lsquo;70: essa ha permesso di programmare a un piÃ¹ alto livello di astrazione rispetto allo stile precedente, rimuovendo la necessitÃ  di gestire manualmente l&amp;rsquo;ordine di esecuzione del codice con il &lt;a href=&#34;https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF&#34;&gt;famigerato&lt;/a&gt; comando &lt;code&gt;goto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I paradigmi di sviluppo cambiano quando i programmatori si ritrovano a dover gestire progetti sempre piÃ¹ corposi e complessi: per evitare di essere imbrigliati dalla eccessiva complessitÃ  del proprio codice, o del codice scritto altri che ci troviamo comunque a mantenere, dobbiamo lavorare a &lt;strong&gt;piÃ¹ alti livelli di astrazione&lt;/strong&gt;. Quanto alti? Una buona risposta a questa domanda potrebbe essere la seguente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;a un elevato livello di astrazione possiamo dire al sistema di fare ciÃ² che vogliamo, senza specificare come farlo&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A un adeguato livello di astrazione possiamo concentrarci sul &lt;em&gt;cosa&lt;/em&gt; lasciando che sia il sistema a decidere il &lt;em&gt;come&lt;/em&gt;. Ovviamente non esiste un &amp;ldquo;massimo&amp;rdquo; livello di astrazione, e in quanto programmatori ci troviamo sempre a lavorare &lt;strong&gt;a metÃ  strada&lt;/strong&gt; tra le cariche elettriche in movimento in un microprocessore, e le necessitÃ  di business della nostra azienda: dobbiamo tuttavia essere in grado di identificare i casi nei quali stiamo lavorando a un livello di astrazione troppo basso, poichÃ© a tale livello puÃ² aumentare molto il rischio di fare errori e introdurre complessitÃ  accidentale. Ad esempio, nel momento in cui usiamo una struttura di controllo come &lt;em&gt;if-else&lt;/em&gt; all&amp;rsquo;interno di una procedura relativamente grande, stiamo &lt;em&gt;manualmente&lt;/em&gt; prendendo una decisione in base allo stato del nostro sistema: molto meglio sarebbe sviluppare un elemento software, ad esempio un oggetto, che sia in grado di &lt;strong&gt;prendere quella decisione al posto nostro&lt;/strong&gt;; il nostro ruolo, a quel punto, sarÃ  &lt;em&gt;dichiarare&lt;/em&gt; la funzionalitÃ  di quell&amp;rsquo;elemento. Mescolare il &lt;em&gt;cosa&lt;/em&gt; con il &lt;em&gt;come&lt;/em&gt; Ã¨ una delle principali cause di difficoltÃ  nel comprendere cosa fa un blocco di codice, perchÃ© puÃ² portare all&amp;rsquo;oscuramento dell&amp;rsquo;&lt;strong&gt;intento&lt;/strong&gt; di una procedura, legato alla logica di business, con i &lt;strong&gt;dettagli di implementazione&lt;/strong&gt;, che sono concetti separati e spesso del tutto indipendenti (uno stesso intento puÃ² essere realizzato con diverse implementazioni a piÃ¹ basso livello).&lt;/p&gt;

&lt;p&gt;Vediamo un semplice esempio. Supponiamo di avere la seguente funzione:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue1(value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	var x: A?
	if cond1 == true {
		if cond2 == true {
			x = nil
		}
		else {
			x = value
		}
	}
	else {
		if cond2 == true {
			x = value
		}
		else {
			x = nil
		}
	}
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anche se la funzione Ã¨ piuttosto semplice, non Ã¨ immediatamente evidente cosa stia succedendo; vediamolo passo-passo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ã¨ dichiarata una variabile &lt;code&gt;x&lt;/code&gt; di tipo &lt;code&gt;A?&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;si verifica la prima condizione:

&lt;ul&gt;
&lt;li&gt;se la prima condizione Ã¨ vera, si verifica la seconda condizione:

&lt;ul&gt;
&lt;li&gt;se la seconda condizione Ã¨ vera, la variabile Ã¨ impostata a &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;se la seconda condizione Ã¨ falsa, la variabile Ã¨ impostata a &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se la prima condizione Ã¨ falsa, si verifica la seconda condizione:

&lt;ul&gt;
&lt;li&gt;se la seconda condizione Ã¨ vera, la variabile Ã¨ impostata a &lt;code&gt;value&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;se la seconda condizione Ã¨ falsa, la variabile Ã¨ impostata a  &lt;code&gt;nil&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ã¨ ritornata la variabile &lt;code&gt;x&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basta pensarci un attimo per capire che, perchÃ© a &lt;code&gt;x&lt;/code&gt; venga assegnato &lt;code&gt;value&lt;/code&gt; le due condizioni devono essere semplicemente diverse tra loro. Possiamo inoltre pensare a un&amp;rsquo;altra semplificazione: non Ã¨ necessario dichiarare la variabile &lt;code&gt;x&lt;/code&gt;, basta ritornare &lt;code&gt;value&lt;/code&gt; se le due condizioni sono diverse, altrimenti ritornare &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func &amp;lt;A&amp;gt; optionalValue2(value: A, cond1: Bool, cond2: Bool) -&amp;gt; A? {
	return cond1 != cond2 ? value : nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo semplificato molto la funzione, rendendola piÃ¹ facile da comprendere: ora &lt;strong&gt;basta un&amp;rsquo;occhiata&lt;/strong&gt; per capire cosa fa. Ma in un caso piÃ¹ complesso, con tante diverse condizioni e percorsi possibili, puÃ² non bastare semplificare le condizioni.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;misurare-la-complessita&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;misurare-la-complessitÃ &#34;&gt;Misurare la complessitÃ &lt;/h2&gt;

&lt;p&gt;Un&amp;rsquo;unitÃ  di misura presa spesso in considerazione nel valutare la complessitÃ  di un metodo o una funzione Ã¨ la &lt;a href=&#34;https://en.wikipedia.org/wiki/Cyclomatic_complexity&#34;&gt;complessitÃ  ciclomatica&lt;/a&gt; (CC): essa rappresenta il livello di complessitÃ  generato dall&amp;rsquo;uso di molteplici strutture di controllo in un metodo o una funzione. Ãˆ possibile calcolare il numero di CC per una procedura strutturata rappresentando quest&amp;rsquo;ultima con un &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_graph&#34;&gt;grafo diretto&lt;/a&gt; e contando il numero di archi e nodi. Ad esempio, possiamo rappresentare la funzione &lt;code&gt;optionalValue1&lt;/code&gt; con il seguente grafo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(value,cond1,cond2)]
|
|-&amp;gt; [var x] -&amp;gt; [cond1 == true ?]
               |
               |-y-&amp;gt; [cond2 == true ?]
               |     |
               |     |-y-&amp;gt; [x = nil] --------|
               |     |-n-&amp;gt; [x = value] ------|
               |                             |
               |-n-&amp;gt; [cond2 == true ?]       |
                     |                       |
                     |-y-&amp;gt; [x = value] ------|
                     |-n-&amp;gt; [x = nil] --------|
                                             |-&amp;gt; [return x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per un singolo grafo connesso, il numero di CC Ã¨ calcolabile in base alla seguente formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CC = [numero archi] - [numero nodi] + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per la funzione &lt;code&gt;defaultValue1&lt;/code&gt; si puÃ² vedere che CC = 4. Apparentemente la versione semplificata &lt;code&gt;defaulValue2&lt;/code&gt; ha una complessitÃ  ciclomatica inferiore, ma in realtÃ , come indicato anche nella &lt;a href=&#34;http://www.literateprogramming.com/mccabe.pdf&#34;&gt;pubblicazione originale&lt;/a&gt; di T.J.McCabe, CC vale solo per una procedura &lt;em&gt;completamente strutturata&lt;/em&gt;, cioÃ¨ una procedura con un solo punto di ingresso e un solo punto di uscita; inoltre CC dovrebbe tener conto di &lt;strong&gt;tutti i casi possibili&lt;/strong&gt; quando si verifica una condizione, e &lt;code&gt;if cond1 != cond2&lt;/code&gt; ha appunto 4 casi possibili. Una trattazione delle possibili evoluzioni di CC tenendo conto di molteplici punti di ingresso e uscita per un modulo Ã¨ disponibile &lt;a href=&#34;http://www.acis.pamplin.vt.edu/faculty/tegarden/wrk-pap/SQJ.PDF&#34;&gt;qui&lt;/a&gt;. Quindi non terremo conto di CC nel resto dell&amp;rsquo;articolo per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la complessitÃ  che ci interessa Ã¨ quella relativa alla &amp;ldquo;comprensibilitÃ &amp;rdquo; di una funzione, e spesso pattern non strutturati (come &lt;code&gt;guard clause&lt;/code&gt;,&lt;code&gt;return&lt;/code&gt; anticipati o &lt;em&gt;conditional expression&lt;/em&gt; come quella prodotta dall&amp;rsquo;operatore ternario &lt;code&gt;?:&lt;/code&gt;) rendono una funzione o un metodo piÃ¹ semplici da capire;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;obiettivo Ã¨ scrivere un programma componendo tante piccole funzioni la cui complessitÃ  sia la &lt;strong&gt;minima possibile&lt;/strong&gt; (nessuna struttura di controllo), quindi avrÃ  poco valore misurare il numero di CC per ogni funzione;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mi Ã¨ parso comunque importante citare la complessitÃ  ciclomatica in questo articolo, ma piÃ¹ che &lt;em&gt;misurare&lt;/em&gt; la complessitÃ  accidentale, siamo interessati a &lt;strong&gt;rimuoverla del tutto&lt;/strong&gt;, sostituendo le decisioni condizionali tipiche della programmazione strutturata con qualcos&amp;rsquo;altro. Ãˆ da notare che una &lt;em&gt;espressione&lt;/em&gt; condizionale rappresenta un concetto &lt;strong&gt;piÃ¹ semplice&lt;/strong&gt; rispetto a una &lt;em&gt;istruzione&lt;/em&gt; condizionale: nel primo caso, l&amp;rsquo;intera espressione ritorna semplicemente un valore in base a una o piÃ¹ condizioni; nel secondo caso, una o piÃ¹ istruzioni potrebbero essere eseguite o meno in base allo stato del sistema.&lt;/p&gt;

&lt;p&gt;Immaginiamo di avere una funzione di questo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func getCorrectValueConsideringConditions &amp;lt;A&amp;gt; (#cond1: Condition&amp;lt;A&amp;gt;, cond2: Condition&amp;lt;A&amp;gt;, cond3: Condition&amp;lt;A&amp;gt; ...) -&amp;gt; A? {
	/// do stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo caso possiamo avere un gran numero di condizioni legate a un valore di tipo &lt;code&gt;A&lt;/code&gt;, e potrebbe essere necessario valutare ciascuna di queste con diversi &lt;em&gt;if-else&lt;/em&gt; e/o &lt;em&gt;switch&lt;/em&gt; annidati. Un modo per risolvere questo problema puÃ² consistere nell&amp;rsquo;&lt;em&gt;astrarre&lt;/em&gt; il concetto stesso di &lt;em&gt;condizione&lt;/em&gt;, trasformandolo in una &lt;em&gt;relazione statica&lt;/em&gt; tra un qualche parametro e un valore di tipo &lt;code&gt;A&lt;/code&gt;: dovremmo quindi realizzare un sistema che sia in grado di &lt;em&gt;risolvere&lt;/em&gt; un qualunque numero di relazioni, possibilmente in un &lt;strong&gt;qualunque ordine&lt;/strong&gt;, e in base ad esse dedurre il valore risultante.&lt;/p&gt;

&lt;p&gt;Vediamo un esempio pratico.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-strutturata&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-strutturata&#34;&gt;Esempio: soluzione strutturata&lt;/h2&gt;

&lt;p&gt;Una persona si reca all&amp;rsquo;ufficio di collocamento per cercare lavoro: in base ad alcuni attributi (preferenze, giovane/anziano, numero di figli di etÃ  inferiore ai 18 anni) essa puÃ² essere inviata a un certo sportello per selezionare un impiego tra i vari disponibili, oppure mandata fuori dall&amp;rsquo;ufficio nel caso in cui il set di attributi non generi una lista di lavori accettabili. Ecco la procedura completa (non Ã¨ importante il realismo, Ã¨ solo un esempio):&lt;/p&gt;

&lt;p&gt;Un persona &lt;strong&gt;p1&lt;/strong&gt; arriva allo sportello &lt;strong&gt;d1&lt;/strong&gt; per cercare un impiego; &lt;strong&gt;p1&lt;/strong&gt; ha una lista di preferenze lavorative, ma potrebbe accettare anche altri lavori fuori lista; &lt;strong&gt;p1&lt;/strong&gt; ha inoltre una lista di lavori che di sicuro non accetterebbe mai;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; Ã¨ giovane si ottiene da &lt;strong&gt;p1&lt;/strong&gt; una lista &lt;strong&gt;l1&lt;/strong&gt; di preferenze;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;l1&lt;/strong&gt; Ã¨ troppo piccola, si chiede a &lt;strong&gt;p1&lt;/strong&gt; di ingrandire la lista con preferenze secondarie;&lt;/li&gt;
&lt;li&gt;si inseriscono le preferenze nel sistema e si ottiene una lista &lt;strong&gt;l2&lt;/strong&gt; di posizioni disponibili;&lt;/li&gt;
&lt;li&gt;se la lista &lt;strong&gt;l2&lt;/strong&gt; Ã¨ vuota, si chiede a &lt;strong&gt;p1&lt;/strong&gt; se vuole visualizzare la lista completa delle posizioni;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; Ã¨ inviato allo sportello &lt;strong&gt;d2&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; Ã¨ anziano, si chiede a &lt;strong&gt;p1&lt;/strong&gt; di scegliere dalla lista &lt;strong&gt;l3&lt;/strong&gt; dei lavori adatti per gli anziani;

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; Ã¨ inviato allo sportello &lt;strong&gt;d3&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha figli, in ogni caso la lista delle posizioni disponibili sarÃ  influenzata dal numero di figli:

&lt;ul&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 1 figlio con etÃ  inferiore ai 18 anni, si presenta a &lt;strong&gt;p1&lt;/strong&gt; la lista &lt;strong&gt;l4&lt;/strong&gt; dei lavori adatti al suo caso;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 2 figli con etÃ  inferiore ai 18 anni, si presenta a &lt;strong&gt;p1&lt;/strong&gt; la lista &lt;strong&gt;l5&lt;/strong&gt; dei lavori adatti al suo caso;&lt;/li&gt;
&lt;li&gt;nei due casi precedenti, se &lt;strong&gt;p1&lt;/strong&gt; sceglie una posizione, &lt;strong&gt;p1&lt;/strong&gt; Ã¨ inviato allo sportello &lt;strong&gt;d4&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;se &lt;strong&gt;p1&lt;/strong&gt; ha 3 figli o piÃ¹, &lt;strong&gt;p1&lt;/strong&gt; Ã¨ inviato allo sportello &lt;strong&gt;d5&lt;/strong&gt; per proseguire con la procedura;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un approccio &amp;ldquo;strutturato&amp;rdquo; al problema puÃ² consistere nello scrivere una funzione in cui l&amp;rsquo;intera procedura Ã¨ espressa con una serie di &lt;em&gt;if-else&lt;/em&gt; e uno &lt;em&gt;switch&lt;/em&gt; (nel caso del numero di figli).&lt;/p&gt;

&lt;p&gt;Il progetto relativo a questo articolo Ã¨ disponibile su &lt;a href=&#34;https://github.com/broomburgo/NoCountryForIfElse&#34;&gt;GitHub&lt;/a&gt;: suggerisco di controllare il codice nel progetto man mano che si prosegue nella lettura dell&amp;rsquo;articolo; i file &lt;code&gt;.swift&lt;/code&gt; sono semplici file di testo, e possono essere visualizzati con qualsiasi editor. Nel file &lt;code&gt;common.swift&lt;/code&gt; sono indicate alcune strutture e funzioni comuni tra tutte le soluzioni al problema proposto. In particolare, indicheremo una &amp;ldquo;persona&amp;rdquo; con &lt;code&gt;struct Person&lt;/code&gt;, in sostanza un &lt;em&gt;value object&lt;/em&gt; immutabile che contiene i vari attributi considerati nel problema:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Person {
    
    let name: String
    let isYoung: Bool
    let childrenCount: Int
    let likedJobsMain: [String]
    let likedJobsSecondary: [String]
    let dislikedJobs: [String]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;idea Ã¨ quella di scrivere una funzione &lt;code&gt;placeNameForPerson&lt;/code&gt; che ritorni il nome della &lt;em&gt;destinazione successiva&lt;/em&gt; per la persona in ingresso al problema: tale destinazione puÃ² essere un altro sportello &lt;code&gt;d2,d3,d4,d5&lt;/code&gt; oppure &lt;code&gt;outside&lt;/code&gt; nel caso in cui la persona lasci l&amp;rsquo;ufficio di collocamento senza lavoro. La funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; ritorna appunto il nome del luogo di destinazione della persona in ingresso, e richiede anche un secondo input, un &lt;code&gt;DeskWithJobs&lt;/code&gt; cioÃ¨ uno sportello con diverse liste di lavori disponibili. Nel caso strutturato, l&amp;rsquo;intera logica di esecuzione Ã¨ indicata nella funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt;, ed Ã¨ appunto basata su verifiche condizionali annidate, legate alle caratteristiche dei parametri in ingresso.&lt;/p&gt;

&lt;p&gt;Si vede subito che Ã¨ piuttosto difficile capire cosa succeda nella funzione semplicemente leggendola: probabilmente, in un &amp;ldquo;vero&amp;rdquo; software, una funzione di questo tipo sarebbe annotata con &lt;strong&gt;un gran numero di commenti&lt;/strong&gt;. Inoltre, si vede facilmente che per tracciare un bug in una funzione del genere sarebbe necessario un debugging passo-passo, perchÃ© il gran numero di condizioni espresse rende la funzione sostanzialmente non testabile in maniera efficiente. Infine, se ci trovassimo a dover modificare la procedura, modificando delle condizioni o introducendone altre, avremmo vita dura.&lt;/p&gt;

&lt;p&gt;Il problema di fondo Ã¨ in realtÃ  dovuto al fatto che, con un approccio strutturato, stiamo &lt;strong&gt;mescolando l&amp;rsquo;intento con l&amp;rsquo;implementazione&lt;/strong&gt;: in questo caso l&amp;rsquo;intento Ã¨ associare gruppi di condizioni a specifici sportelli &amp;ldquo;target&amp;rdquo;, ma nella soluzione strutturata tali relazioni sono &amp;ldquo;nascoste&amp;rdquo; nel codice e devono essere dedotte da esso; se ad esempio ci venisse chiesto qual Ã¨ lo sportello per una persona anziana con 2 figli, dovremmo necessariamente seguire il flusso di codice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;poichÃ© la prima condizione Ã¨ relativa al numero di figli, entriamo subito nel branch &lt;code&gt;childrenCount != 0&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;a questo punto entriamo nel &lt;code&gt;case 2&lt;/code&gt; per il numero di figli;&lt;/li&gt;
&lt;li&gt;c&amp;rsquo;Ã¨ una condizione in base alla quale il codice verifica che c&amp;rsquo;Ã¨ un lavoro disponibile;&lt;/li&gt;
&lt;li&gt;a scelta positiva lo sportello di destinazione Ã¨ il &amp;ldquo;d4&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;dov&amp;rsquo;Ã¨ la condizione &amp;ldquo;giovane/anziano&amp;rdquo;? C&amp;rsquo;Ã¨ un bug nel codice? Analizzando il ramo &lt;code&gt;childrenCount == 0&lt;/code&gt; possiamo verificare che tale condizione Ã¨ effettivamente analizzata, ma Ã¨ semplicemente irrilevante per l&amp;rsquo;altro ramo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ãˆ una strada relativamente lunga per capire una cosa semplice, ed Ã¨ da notare che se volessimo fare delle modifiche, dovremmo sempre scorrere nuovamente l&amp;rsquo;intera procedura per verificare che abbiamo coperto tutti i casi possibili, e che non ci siano conflitti o ambiguitÃ .&lt;/p&gt;

&lt;p&gt;Possiamo fare di meglio.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-oo&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-oo&#34;&gt;Esempio: soluzione OO&lt;/h2&gt;

&lt;p&gt;Progettare una soluzione a oggetti Ã¨ spesso un&amp;rsquo;operazione &lt;strong&gt;tanto razionale quanto creativa&lt;/strong&gt;: in genere Ã¨ possibile immaginare moltissimi design OO per risolvere uno stesso problema. Come detto, il nostro intento Ã¨ di &lt;em&gt;astrarre&lt;/em&gt; il concetto di &lt;em&gt;condizione&lt;/em&gt;; basandoci su questo approccio, proviamo fissare qualche punto, in modo da identificare le responsabilitÃ  e i comportamenti da assegnare alla classi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vogliamo essere in grado di rappresentare ciascuna condizione come se fosse un &lt;em&gt;check&lt;/em&gt; separato dagli altri, quindi avremo certamente qualcosa che assomiglia a un tipo &lt;em&gt;Check&lt;/em&gt; caratterizzato da metodi che verificano se una certa persona passa un controllo o no;&lt;/li&gt;
&lt;li&gt;vogliamo rappresentare separatamente i check relativi a un attributo della persona, tipo il numero di figli, da quelli relativi alla lista di lavori tra cui scegliere;&lt;/li&gt;
&lt;li&gt;vogliamo costruire oggetti che siano in grado di combinare piÃ¹ check in un unico check;&lt;/li&gt;
&lt;li&gt;vogliamo creare un oggetto che rappresenti una lista di check e sia in grado di valutare se la persona passi uno dei check della lista, uno e solo uno, oppure non passi alcun check;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il file &lt;code&gt;oo.swift&lt;/code&gt; contiene l&amp;rsquo;implementazione completa della soluzione a oggetti. Ãˆ definito un &lt;code&gt;protocol PersonCheckType&lt;/code&gt;, cioÃ¨ un&amp;rsquo;interfaccia che dichiara un metodo &lt;code&gt;personIsValid&lt;/code&gt; che verifica se una certa &lt;code&gt;Person&lt;/code&gt; passa il check:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol PersonCheckType {
    func personIsValid(person: Person) -&amp;gt; Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sono quindi dichiarate alcune classi di tipo &lt;code&gt;PersonCheckType&lt;/code&gt; che permettono di verificare singolarmente ciascun attributo intrinseco di una &lt;code&gt;Person&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Il tipo &lt;code&gt;JobsType&lt;/code&gt; dichiara semplicemente un attributo &lt;code&gt;availableJobs&lt;/code&gt; per raccogliere i lavori disponibili nei vari casi: da esso derivano altri &lt;em&gt;check&lt;/em&gt;, a loro volta di tipo &lt;code&gt;PersonCheckType&lt;/code&gt;, che verificano se una persona sia valida dal punto di vista dei lavori preferiti.&lt;/p&gt;

&lt;p&gt;Infine, il tipo &lt;code&gt;NextDeskType&lt;/code&gt; dichiara un metodo &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; in base al quale Ã¨ possibile definire quale sia il nome del prossimo sportello per una persona; il metodo ritorna &lt;code&gt;String?&lt;/code&gt; perchÃ© per una certa persona potrebbe non essere disponibile alcuno sportello:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol NextDeskType {
    func nextDeskNameForPerson(person: Person) -&amp;gt; String?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dal tipo &lt;code&gt;NextDeskType&lt;/code&gt; deriviamo le seguenti classi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CheckNode&lt;/code&gt;, che rappresenta un nodo nella struttura decisionale del software;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CheckStructure&lt;/code&gt;, che rappresenta l&amp;rsquo;intera struttura di nodi;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In effetti, l&amp;rsquo;implementazione di &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; in &lt;code&gt;CheckStructure&lt;/code&gt; corrisponde esattamente alla soluzione del problema posto: trovare il nome dello sportello di destinazione.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;idea Ã¨ quella di creare alcuni semplici &lt;strong&gt;check unitari&lt;/strong&gt;, usando le varie classi di tipo &lt;code&gt;PersonCheckType&lt;/code&gt;, e combinare questi check in oggetti concreti di classe &lt;code&gt;CheckNode&lt;/code&gt;, definendo la nostra &lt;code&gt;CheckStructure&lt;/code&gt;. In puro stile OO, abbiamo definito classi chiamate &lt;code&gt;MultipleCheck&lt;/code&gt; e &lt;code&gt;ComposedCheck&lt;/code&gt; per poter comporre piÃ¹ check, e &lt;code&gt;FailingCheck&lt;/code&gt; per poter incapsulare un check di cui si richiede il fallimento. Nessuno dei metodi implementati presenta strutture decisionali che influenzino la &lt;em&gt;business logic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Come esempio si riporta l&amp;rsquo;implementazione della classe &lt;code&gt;ChildrenCountCheck&lt;/code&gt;, che si occupa di verificare se una persona abbia un certo numero di figli:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ChildrenCountCheck: PersonCheckType {
    
    let childrenCount: Int
    init(_ childrenCount: Int) {
        self.childrenCount = childrenCount
    }
    
    func personIsValid(person: Person) -&amp;gt; Bool {
        return person.childrenCount == childrenCount
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;oggetto &lt;code&gt;structure&lt;/code&gt; definito nel file &lt;code&gt;main.swift&lt;/code&gt; presenta la lista delle condizioni, sotto forma di oggetti adeguatamente configurati; come si puÃ² vedere, la lista Ã¨ ben leggibile e le condizioni sono chiare: siamo quindi riusciti a &lt;em&gt;dichiarare&lt;/em&gt; l&amp;rsquo;intento in maniera semplice e separata dai dettagli di implementazione.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-soluzione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-soluzione-funzionale&#34;&gt;Esempio: soluzione funzionale&lt;/h2&gt;

&lt;p&gt;Nello strutturare la soluzione OO abbiamo adottato un &lt;strong&gt;principio di composizione&lt;/strong&gt;: oggetti dal comportamento semplice, adeguatamente preparati, composti tra loro per poter ottenere strutture piÃ¹ complesse. In particolare ciascuno dei nostri oggetti rappresenta uno specifico &lt;em&gt;comportamento unitario&lt;/em&gt;, e i vari &lt;em&gt;comportamenti&lt;/em&gt; sono combinati per ottenere un &lt;em&gt;comportamento composto&lt;/em&gt;. &lt;strong&gt;L&amp;rsquo;astrazione regge&lt;/strong&gt;, e riusciamo ad accettare il fatto che gli oggetti &lt;em&gt;check&lt;/em&gt; siano scatole chiuse che incapsulano una singola decisione su una persona: creando una scatola piÃ¹ grande, con dentro scatole piÃ¹ piccole, possiamo rappresentare una condizione piÃ¹ complessa. Tuttavia ci sono due problemi tipici dell&amp;rsquo;approccio OO:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ogni singola classe richiede molto codice solo per costruire l&amp;rsquo;astrazione di &amp;ldquo;decisione nella scatola&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;la composizione tra oggetti Ã¨ basata sui metodi degli oggetti stessi, la qual cosa comporta, di nuovo, la scrittura di molto codice, che puÃ² offuscare l&amp;rsquo;intento;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ãˆ possibile ottenere piÃ¹ chiaramente lo stesso risultato, cioÃ¨ creare una struttura decisionale complessa a partire da componenti semplici, usando uno stile di &lt;strong&gt;programmazione funzionale&lt;/strong&gt;. Il codice funzionale Ã¨ descritto nel file &lt;code&gt;functional.swift&lt;/code&gt;. Partiamo sempre dall&amp;rsquo;immutabile &lt;code&gt;struct Person&lt;/code&gt; e definiamo, per comoditÃ , un altro semplice contenitore di dati, &lt;code&gt;struct DeskNode&lt;/code&gt;, che accoppia il nome di un nodo al nome di uno sportello di destinazione. Per il resto, definiremo solo ed esclusivamente funzioni, modellizzando l&amp;rsquo;intero problema con una serie di trasformazioni di dati.&lt;/p&gt;

&lt;p&gt;In questo caso &lt;code&gt;PersonCheck&lt;/code&gt; Ã¨ &lt;strong&gt;un tipo di funzione&lt;/strong&gt;, che associa una &lt;code&gt;Person&lt;/code&gt; a un &lt;code&gt;Bool&lt;/code&gt;. Definiamo inoltre il tipo di funzione &lt;code&gt;PersonNode&lt;/code&gt;, che associa un certo &lt;code&gt;DeskNode&lt;/code&gt; a una &lt;code&gt;Person&lt;/code&gt;, e che ha sostanzialmente lo scopo che aveva il metodo &lt;code&gt;nextDeskNameForPerson&lt;/code&gt; nella soluzione a oggetti.&lt;/p&gt;

&lt;p&gt;Rappresentiamo infine i vari &amp;ldquo;nodi&amp;rdquo; con una funzione del tipo &lt;code&gt;JobsNode&lt;/code&gt;, che costruisce un &lt;code&gt;PersonNode&lt;/code&gt; in base a un certo &lt;code&gt;PersonCheck&lt;/code&gt;: in questo modo, per costruire una lista di &lt;code&gt;PersonNode&lt;/code&gt; sarÃ  sufficiente applicare i vari &lt;em&gt;check&lt;/em&gt; (&lt;code&gt;PersonCheck&lt;/code&gt;) ai rispettivi nodi (&lt;code&gt;JobsNode&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Il metodo piÃ¹ spesso adottato in programmazione funzionale per comporre le funzioni Ã¨ quello di definire degli &lt;strong&gt;operatori personalizzati&lt;/strong&gt;. Vogliamo ad esempio comporre i vari &lt;code&gt;PersonCheck&lt;/code&gt; come se componessimo dei semplici &lt;code&gt;Bool&lt;/code&gt;, quindi ad esempio definendo degli operatori &lt;strong&gt;AND&lt;/strong&gt; e &lt;strong&gt;OR&lt;/strong&gt;. Ad imitazione dei classici &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; e &lt;code&gt;||&lt;/code&gt; definiremo rispettivamente gli operatori &lt;code&gt;&amp;lt;&amp;amp;&amp;gt;&lt;/code&gt; e &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, copiando regole di &lt;a href=&#34;https://en.wikipedia.org/wiki/Operator_associativity&#34;&gt;precedenza e associativitÃ &lt;/a&gt; dalla libreria standard. Per migliorare la leggibilitÃ  e la chiarezza della composizione tra funzioni, definiremo anche un operatore di &lt;em&gt;applicazione di funzione&lt;/em&gt;, nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;infix operator &amp;lt;*&amp;gt; {
    associativity left
    precedence 100
}
func &amp;lt;*&amp;gt; &amp;lt;A,B&amp;gt; (left: A -&amp;gt; B, right: A) -&amp;gt; B {
    return left(right)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vediamo dalla definizione che l&amp;rsquo;operatore &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; in sostanza &lt;em&gt;applica&lt;/em&gt; un argomento (posizionato a destra dell&amp;rsquo;operatore) a una certa funzione (posizionata a sinistra dell&amp;rsquo;operatore): esso rappresenta quindi un modo alternativo di applicare una funzione rispetto allo scrivere i suoi argomenti &lt;strong&gt;tra parentesi&lt;/strong&gt;, ed Ã¨ particolarmente adatto a migliorare la leggibilitÃ  del codice quando usiamo &lt;a href=&#34;https://en.wikipedia.org/wiki/Higher-order_function&#34;&gt;funzioni di ordine superiore&lt;/a&gt;. Vediamo gli operatori all&amp;rsquo;opera nel file &lt;code&gt;main.swift&lt;/code&gt;, quando definiamo i nostri nodi, ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;node(&amp;quot;old&amp;quot;, nextDeskName: &amp;quot;d3&amp;quot;)
    &amp;lt;*&amp;gt; oldCheck
    &amp;lt;&amp;amp;&amp;gt; mustFail(childrenChecks)
    &amp;lt;&amp;amp;&amp;gt; checkExtendedJobs(availableJobsElderly)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione sopraindicata costruisce un &lt;code&gt;PersonNode&lt;/code&gt; chiamato &lt;em&gt;old&lt;/em&gt; che ritorna lo sportello &lt;em&gt;d3&lt;/em&gt; se la &lt;code&gt;Person&lt;/code&gt; in ingresso rispetta un check composto formato dalle seguenti funzioni:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oldCheck&lt;/code&gt;: la persona Ã¨ anziana;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mustFail(childrenChecks)&lt;/code&gt;: la persona non deve avere figli;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkExtendedJobs(availableJobsElderly)&lt;/code&gt;: l&amp;rsquo;insieme dei lavori adatti agli anziani e l&amp;rsquo;insieme dei lavori preferiti dalla persona devono avere una qualche intersezione;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A un primo impatto lo stile funzionale puÃ² risultare poco comprensibile, ma Ã¨ sufficiente capire le astrazioni di base sulle quali Ã¨ realizzata la composizione funzionale per poterne apprezzare &lt;strong&gt;la potenza e l&amp;rsquo;espressivitÃ &lt;/strong&gt;. L&amp;rsquo;array &lt;code&gt;nodes&lt;/code&gt;, nel file &lt;code&gt;main.swift&lt;/code&gt;, contiene tutti i nodi del problema, rappresentati come funzioni: rispetto  alla soluzione a oggetti contenuta in &lt;code&gt;structure&lt;/code&gt;, quella funzionale appare piÃ¹ chiara e leggibile.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;una-verifica-empirica&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;una-verifica-empirica&#34;&gt;Una verifica empirica&lt;/h2&gt;

&lt;p&gt;Nel progettare le soluzioni &amp;ldquo;OO&amp;rdquo; e &amp;ldquo;funzionale&amp;rdquo; si Ã¨ specificamente scelto di costruire strutture di verifica nelle quali l&amp;rsquo;ordine con il quale i check sono eseguiti fosse irrilevante: in questo modo rimuoviamo una nota causa di complessitÃ  accidentale, quella del &amp;ldquo;controllo&amp;rdquo;, e cioÃ¨ dell&amp;rsquo;&lt;strong&gt;ordine&lt;/strong&gt; con il quale le operazioni sono eseguite (ne abbiamo parlato &lt;a href=&#34;http://engineering.facile.it/programmazione-funzionale-perche-preoccuparsi/#cause-di-complessita&#34;&gt;qui&lt;/a&gt;). Per fare ciÃ² Ã¨ tuttavia necessario che i check presenti nella lista &lt;strong&gt;non siano ambigui&lt;/strong&gt;: al massimo un solo check deve poter passare per una certa persona. Probabilmente sarebbe possibile impostare un &lt;strong&gt;metodo formale&lt;/strong&gt; per poter provare che un determinato set di condizioni sia non-ambiguo, e scrivere quindi un test unitario basato su tale prova, ma in questo caso un approccio &lt;em&gt;empirico&lt;/em&gt; sembra piÃ¹ adatto, e &lt;strong&gt;piÃ¹ semplice&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Si Ã¨ quindi scelto di procedere seguendo il metodo &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt;: si tratta di una libreria scritta per il linguaggio &lt;a href=&#34;https://www.haskell.org&#34;&gt;Haskell&lt;/a&gt; che permette di testare in modo automatico che le funzioni rispettino determinate &lt;em&gt;proprietÃ &lt;/em&gt;. L&amp;rsquo;idea Ã¨ quella di verificare che una funzione si comporti sempre nello stesso modo, testandola con &lt;strong&gt;un gran numero di input casuali&lt;/strong&gt;: nel nostro caso la funzione Ã¨ proprio la lista di check, e l&amp;rsquo;input Ã¨ un valore di tipo &lt;code&gt;Person&lt;/code&gt;. Per verificare che i check non siano ambigui possiamo semplicemente provarli con un gran numero di &lt;code&gt;Person&lt;/code&gt; generate casualmente: se per un certo valore di &lt;code&gt;Person&lt;/code&gt; due o piÃ¹ check risultano positivi, l&amp;rsquo;esecuzione del test si interrompe e sono stampati in console i nomi dei check incriminati. Se i check ambigui sono due, sarÃ  sufficiente rendere uno di essi piÃ¹ specifico, ad esempio richiedendo che l&amp;rsquo;altro fallisca. Useremo qui il termine &lt;em&gt;QuickCheck&lt;/em&gt; per indicare il test empirico implementato, ma in realtÃ  la libreria originale fa molto di piÃ¹: rimando alla pagina &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;linkata&lt;/a&gt; per tutte le informazioni.&lt;/p&gt;

&lt;p&gt;Le funzioni &lt;code&gt;quickCheck_oo&lt;/code&gt; e &lt;code&gt;quickCheck_functional&lt;/code&gt; implementano la funzionalitÃ  richiesta: generano un certo numero di &lt;code&gt;Person&lt;/code&gt; casuali, e verificano che il numero di &lt;code&gt;check&lt;/code&gt; superato per ogni &lt;code&gt;Person&lt;/code&gt; sia 0 o 1. Possiamo sfruttare immediatamente questo test aggiungendo un nuovo nodo. Supponiamo ad esempio che a un certo punto, dopo qualche tempo in cui il codice Ã¨ stato usato con successo per risolvere il problema, si scelga di aggiungere una nuova condizione: Ã¨ stato appositamente aperto uno sportello per persone anziane con un solo figlio. Si noti come modificare il codice della funzione &lt;code&gt;placeNameForPerson_structured&lt;/code&gt; sarebbe piuttosto complicato: probabilmente dovremmo modificare interi branch decisionali, &lt;strong&gt;aggiungendo la stessa condizione in diversi punti&lt;/strong&gt;, e la probabilitÃ  di sbagliare sarebbe molto alta. Con le altre due soluzioni, invece, si tratta semplicemente di aggiungere un nuovo check. Tuttavia, dopo aver aggiunto il nodo, se eseguiamo il programma vedremo che QuickCheck fallirÃ , stampando il seguente messaggio&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ambiguous nodes: [1 child, 1 child old]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QuickCheck ci sta informando che i nodi chiamati &amp;ldquo;1 child&amp;rdquo; e &amp;ldquo;1 child old&amp;rdquo; sono &lt;strong&gt;ambigui&lt;/strong&gt;: in effetti, se la &lt;code&gt;Person&lt;/code&gt; ha un figlio ed Ã¨ anziana, passeranno i check per entrambi i nodi. Per risolvere il problema sarÃ  sufficiente introdurre una condizione di fallimento nel nodo &amp;ldquo;1 child&amp;rdquo;: perchÃ© esso passi, deve fallire il check di anzianitÃ .&lt;/p&gt;

&lt;p&gt;Nel progetto Ã¨ implementata anche una funzione &lt;code&gt;quickCheck_consistency&lt;/code&gt; che esegue un test di sicurezza del tipo &lt;em&gt;sanity check&lt;/em&gt;: verifica infatti che lo sportello di destinazione di un gran numero di &lt;code&gt;Person&lt;/code&gt; generate casualmente rimanga lo stesso nei 3 metodi implementati.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusioni&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusioni&#34;&gt;Conclusioni&lt;/h2&gt;

&lt;p&gt;Abbiamo visto tre metodi per risolvere uno stesso problema relativamente complesso, e in due di essi siamo riusciti a ottenere un sistema &lt;strong&gt;piÃ¹ facilmente gestibile&lt;/strong&gt;, estendibile e modificabile in sicurezza, lavorando a un &lt;strong&gt;piÃ¹ alto livello di astrazione&lt;/strong&gt;. In particolare il metodo &amp;ldquo;funzionale&amp;rdquo; ci ha permesso di scrivere codice piÃ¹ compatto, caratterizzato da un intento piÃ¹ evidente, al costo (basso) di un passo iniziale di astrazione in piÃ¹, rappresentato dagli operatori personalizzati. Ma la chiave di lettura dell&amp;rsquo;intero processo Ã¨ ancora una volta da ricercarsi nella giÃ  citata frase presente in &lt;em&gt;Structure and Interpretation of Computer Programs&lt;/em&gt;, che riporto nuovamente:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;programs must be written for people to read, and only incidentally for machines to execute&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Adottando uno stile piÃ¹ &lt;strong&gt;dichiarativo&lt;/strong&gt;, in cui il codice proprio della &lt;em&gt;business logic&lt;/em&gt; &amp;ldquo;dichiara l&amp;rsquo;intento&amp;rdquo;, descrivendo il &amp;ldquo;cosa&amp;rdquo; e non il &amp;ldquo;come&amp;rdquo;, Ã¨ possibile scrivere software piÃ¹ chiaro e leggibile. Tale software sarÃ  probabilmente anche piÃ¹ &lt;em&gt;testabile&lt;/em&gt;, perchÃ© basato su &lt;strong&gt;componenti atomici&lt;/strong&gt; a piÃ¹ basso livello, individualmente facili da testare, che sono combinati attraverso strutture di composizione, anch&amp;rsquo;esse agilmente testabili e provabili. L&amp;rsquo;obiettivo finale Ã¨ quello di realizzare architetture software che siano in grado di &lt;strong&gt;risolvere automaticamente i problemi&lt;/strong&gt;, descritti nel codice sfruttando gli &lt;strong&gt;elementi costruttivi di base&lt;/strong&gt;. Abbiamo infine visto come un approccio misto tra &amp;ldquo;ragionato&amp;rdquo; e &amp;ldquo;empirico&amp;rdquo; possa garantire ottimi risultati; il ragionamento &lt;em&gt;a priori&lt;/em&gt; e la verifica &lt;em&gt;a posteriori&lt;/em&gt; sono entrambi strumenti utili, ma la loro unione risulta essere particolarmente potente: d&amp;rsquo;altronde, ogni disciplina scientifica richiede sia il ragionamento logico-matematico per la definizione delle teorie, sia la verifica sperimentale per poterne testare la validitÃ .&lt;/p&gt;

&lt;p&gt;Gli strumenti sono a disposizione, basta &lt;strong&gt;iniziare ad usarli&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>