<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/android/</link>
    <description>Recent content in Android on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Feb 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://engineering.facile.it/categories/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Use Kotlin Type-safe builders to create a form DSL</title>
      <link>https://engineering.facile.it/blog/eng/kotlin-dsl/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/kotlin-dsl/</guid>
      <description>

&lt;p&gt;Here at Facile.it we are constantly dealing with a lot of &lt;strong&gt;forms&lt;/strong&gt;: we use them to collect various information and data needed to feed our in-house comparing algorithms. These forms could be &lt;strong&gt;really complex&lt;/strong&gt;, having multiple rules and dependencies between fields, and they are likely to be &lt;strong&gt;changed and tuned frequently&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When I joined Facile.it, a lot of forms within the Android app needed to be updated or modified and sticking with the existing strategy would have required me to do &lt;strong&gt;a lot of work&lt;/strong&gt; just to add or remove a simple field. So I took a step back and I started thinking about a strategy that would have allowed me to define and structure a form in a more &lt;em&gt;flexible&lt;/em&gt; and &lt;em&gt;declarative&lt;/em&gt; way. I wanted to be able to declare the &lt;strong&gt;relationships&lt;/strong&gt; between fields, their &lt;strong&gt;validation rules&lt;/strong&gt; and their &lt;strong&gt;serialized representation&lt;/strong&gt; (how they are sent to the server).&lt;/p&gt;

&lt;p&gt;I firstly thought about defining it using some configuration file, maybe written in JSON or YAML. The &lt;em&gt;problem&lt;/em&gt; with this strategy was that it would also have required me to write a lot code to parse and validate those files to be able to create some sort of representation of the form in Java&amp;hellip;but don&amp;rsquo;t we already have the compiler for this kind of jobs?&lt;/p&gt;

&lt;p&gt;I still wanted to be able to have both a &lt;strong&gt;human readable representation&lt;/strong&gt; of the form and the right degree of &lt;strong&gt;flexibility&lt;/strong&gt; to integrate the form definition into the app code.
So I thought that creating a &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-specific_language&#34;&gt;Domain-Specific Language&lt;/a&gt; would have been a perfect strategy to solve the problem in an elegant and efficient way.
Writing a DSL in Java could have ended up into something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Form.create()
    .openSection(sectionId)
    .field(key1, &amp;quot;label1&amp;quot;, style, ...) 
    .field(key2, &amp;quot;label2&amp;quot;, style, ...) 
    .field(key3, &amp;quot;label3&amp;quot;, style, ...) 
    .closeSection()
    ...
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t think the previous code is readable nor flexible and it requires a lot of boilerplate to be written.&lt;/p&gt;

&lt;h2 id=&#34;kotlin-to-the-rescue&#34;&gt;Kotlin to the rescue!&lt;/h2&gt;

&lt;p&gt;Unlike Java, Kotlin (take a look at my &lt;a href=&#34;https://engineering.facile.it/blog/eng/kotlin-intro/&#34;&gt;previous post&lt;/a&gt; about it) has a lot of features that makes it really powerful when it comes to write internal DSLs. The results are very similar to Groovy (think about a Gradle file) but thanks to its type system they could be &lt;a href=&#34;https://kotlinlang.org/docs/reference/type-safe-builders.html#type-safe-builders&#34;&gt;Type-Safe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The builders you can write with Kotlin are extremely readable and easy to understand even for people that don&amp;rsquo;t know either the language or the DSL itself. Here&amp;rsquo;s how a form built using my final DSL looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val FORM = form {
    page(&amp;quot;Page 1 Title&amp;quot;) {
        section(&amp;quot;Section 1 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey1&amp;quot;) {
                checkbox(&amp;quot;Checkbox Field Label&amp;quot;) {
                    boolToStringConverter = { if (it == true) &amp;quot;Yes&amp;quot; else &amp;quot;No&amp;quot; }
                    rules = { listOf(NotMissing()) }
                }
            }
            field(key = &amp;quot;fieldKey2&amp;quot;) {
                picker(&amp;quot;Picker Field Label&amp;quot;) {
                    placeHolder = &amp;quot;Select a value&amp;quot;
                    possibleValues = Available(listOf(
                            1 keyTo &amp;quot;Value1&amp;quot;,
                            2 keyTo &amp;quot;Value2&amp;quot;,
                            3 keyTo &amp;quot;Value3&amp;quot;))
                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE
                }
            }
        }
        section(&amp;quot;Section 2 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey3&amp;quot;) {
                picker(&amp;quot;Picker Field Label&amp;quot;) {
                    placeHolder = &amp;quot;Select a value&amp;quot;
                    possibleValues = ToBeRetrieved(someWebService.getValues())
                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE
                }
            }
            field(key = &amp;quot;fieldKey4&amp;quot;) {
                input(&amp;quot;Input Text Field Label&amp;quot;) {
                    inputTextType = InputTextType.EMAIL
                    rules = { listOf(IsEmail()) }
                }
            }
            field(key = &amp;quot;fieldKey&amp;quot;) {
				        empty(&amp;quot;Empty Field&amp;quot;)
            }
        }
		    section(&amp;quot;Section 3 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey6&amp;quot;) {
                toggle(&amp;quot;Toggle Field Label&amp;quot;) {
                    boolToStringConverter = { if (it == true) &amp;quot;OK&amp;quot; else &amp;quot;KO&amp;quot; }
                    rules = { listOf(NotMissing()) }
                    representation = ALWAYS representAs SIMPLE_KEY_TO_VALUE
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is the result on Android using my &lt;a href=&#34;https://github.com/brescia123/forms&#34;&gt;Form library&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/kotlin-dsl/form_screen.png&#34; alt=&#34;Form screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cool, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;type-safe-builders&#34;&gt;Type-safe builders&lt;/h2&gt;

&lt;h3 id=&#34;some-kotlin-important-features&#34;&gt;Some Kotlin important features&lt;/h3&gt;

&lt;p&gt;To grasp how Type-safe builders work in Kotlin we need to understand some key Kotlin features and how they can be combined together:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Higher-Order Functions and Lambdas&lt;/strong&gt;: in Kotlin we are allowed to write functions that have &lt;em&gt;functions as parameters or return type&lt;/em&gt; (higher-order functions) and functions that are &lt;em&gt;not declared&lt;/em&gt;, but are passed immediately as an expression (lambdas). Because of this, we can write things like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Higher-Order Function
fun transformWith(path: String, function: (String) -&amp;gt; List&amp;lt;String&amp;gt;): List&amp;lt;String&amp;gt; {
    return function(this)
}

// Lambda
{ path: String -&amp;gt; path.split(&amp;quot;/&amp;quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to Kotlin syntactic sugar we can use them in these ways:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;transformWith(&amp;quot;some/path/to&amp;quot;, { path: String -&amp;gt; path.split(&amp;quot;/&amp;quot;) }) // -&amp;gt; [some, path, to]

// Functions which have a function as the last parameter can be written as follow
transformWith(&amp;quot;some/path/to&amp;quot;) { path -&amp;gt; path.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]

// If the lambda has only one parameter it can be ommitted and referenced as &amp;quot;it&amp;quot;
transformWith(&amp;quot;some/path/to&amp;quot;) { it.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Extension Functions&lt;/strong&gt;: they allow us to &lt;em&gt;extend&lt;/em&gt; a type with functions without modifying the original class. They are useful to add functionalities to classes we don&amp;rsquo;t have control on or to create utility methods without the need to create &amp;ldquo;Utils classes&amp;rdquo; that contains static methods, as we are used to as Java developers. To continue the previous example we can write:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Extension function
fun String.transformWith(function: (String) -&amp;gt; List&amp;lt;String&amp;gt;) {
    return function(this)
}

&amp;quot;some/path/to&amp;quot;.transformWith { receiverString: String -&amp;gt; receiverString(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]

// or more concisely 
&amp;quot;some/path/to&amp;quot;.transformWith { it.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we are referring to the string inside the closure of the extension function using &lt;code&gt;this&lt;/code&gt; as it will be the String object on which the method will be called.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Function Literals with Receiver&lt;/strong&gt;: similarly to extension functions you are also allowed to define functions with a receiver that will be referred to as &lt;code&gt;this&lt;/code&gt; inside the literal closure:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;val transformWith: String.() -&amp;gt; List&amp;lt;String&amp;gt; = { this.split(&amp;quot;/&amp;quot;) }

transformWith(&amp;quot;some/path/to&amp;quot;) // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To better understand function literals with receiver you should think of them as follow: &lt;em&gt;lambda is to normal function as function literal with receiver is to extension function&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// lambda
{ s: String -&amp;gt; s.split(&amp;quot;/&amp;quot;) }
// is to
fun function(s: String): List&amp;lt;String&amp;gt; { return s.split(&amp;quot;/&amp;quot;) }
// as
val functionLiteralWithReceiver = String.() -&amp;gt; List&amp;lt;String&amp;gt; = { this.split(&amp;quot;/&amp;quot;) }
// is to
fun String.extensionFunction(): List&amp;lt;String&amp;gt; { return function(this) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically function literals with receiver are extension functions that can be passed to other functions.&lt;/p&gt;

&lt;h3 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;Now we have all the elements required to understand and write a Type-safe builder.&lt;/p&gt;

&lt;p&gt;Combining the above mentioned Kotlin features we can now write a function and name it &lt;code&gt;form&lt;/code&gt;. This function will take as parameter a function literal with receiver usually called &lt;code&gt;init()&lt;/code&gt; and will do the follow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create a new Form object&lt;/li&gt;
&lt;li&gt;call &lt;code&gt;init()&lt;/code&gt; on it (that is using it as the receiver of the function literal)&lt;/li&gt;
&lt;li&gt;return the built object to the caller&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun form(init: Form.() -&amp;gt; Unit): Form {
    val form = Form() 
    form.init()
    return form
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s imagine that our Form class defines a function &lt;code&gt;field()&lt;/code&gt; that actually creates a field object and adds it to the list of fields contained within the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Form() {
    val fields: List&amp;lt;Field&amp;gt;
    ...
    fun field(key: String) { ... }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Taking advantage of Kotlin syntactic sugar we can use &lt;code&gt;form()&lt;/code&gt; passing it the &lt;code&gt;init()&lt;/code&gt; function as a lambda and call methods on the Form object to build it as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val builtForm = form() {
    // Here we can take advantage of the compiler and, as a result, of the IDE code completion
    field(&amp;quot;key1&amp;quot;) // == this.field(&amp;quot;key1&amp;quot;) where this is the object create by form()
    field(&amp;quot;key2&amp;quot;)
}
builtForm.getFields() // -&amp;gt; [Field(&amp;quot;key1&amp;quot;), Field(&amp;quot;key2&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see Type-Safe builders are an &lt;strong&gt;extremely powerful&lt;/strong&gt; and useful feature of Kotlin and they allow you to write very complex DSLs with a &lt;strong&gt;really readable and clear syntax&lt;/strong&gt;. They give you a lot of &lt;strong&gt;flexibility&lt;/strong&gt; letting you combine multiple builders to create a domain language that can meet your requirements.&lt;/p&gt;

&lt;p&gt;If you want to learn more about this subject check out the official &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;documentation&lt;/a&gt; or, for example, &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;kotlinx&lt;/a&gt;, an official project from the Kotlin team that allows you to create HTML documents with a custom DSL entirely written with Type-safe builders.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A new hope for the JVM: Kotlin</title>
      <link>https://engineering.facile.it/blog/eng/kotlin-intro/</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/kotlin-intro/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/kotlin-intro/logo_Kotlin.svg&#34; alt=&#34;Kotlin&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;premise&#34;&gt;Premise&lt;/h2&gt;

&lt;p&gt;Java is an &lt;strong&gt;old&lt;/strong&gt; programming language. Version 1.0 was released in 1996 by Sun Microsystems and  even though it has evolved and grown a lot over the past twenty years it is still carrying on some bad design choices such as &lt;em&gt;null&lt;/em&gt; (ask &lt;a href=&#34;https://en.wikipedia.org/wiki/Tony_Hoare?section=3#Apologies_and_retractions&#34;&gt;Tony Hoare&lt;/a&gt;), primitive types or lack of a proper function type. With the last version of the language (Java 8) Java tried to address some of these problems introducing concepts such as &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&#34;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&#34;&gt;lambda expression&lt;/a&gt;. Although these additions clearly represent a step forward for the language I still have the feeling that they are just &lt;em&gt;patches&lt;/em&gt; applied to &lt;strong&gt;mitigate problems&lt;/strong&gt; and not to solve them at their very source. For example &lt;code&gt;Optional&lt;/code&gt; could be used to reduce NPE (Null Pointer Exception) but it is clearly not designed for &lt;a href=&#34;https://twitter.com/mariofusco/status/780770300178956289&#34;&gt;this purpose&lt;/a&gt; and lambda expressions, implemented in Java 8 with SAM types, still force you to write an interface only to define a &lt;em&gt;function&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-android-world&#34;&gt;The Android world&lt;/h2&gt;

&lt;p&gt;All the above concerns about Java are even more problematic within the Android world where, due to the notorious &lt;a href=&#34;https://developer.android.com/about/dashboards/index.html&#34;&gt;fragmentation&lt;/a&gt; (a huge amount of devices are stuck with an &lt;strong&gt;outdated VM&lt;/strong&gt;), you are forced to target lower Java versions (6 and 7).
Google is addressing the problem with its new compiler &lt;a href=&#34;https://source.android.com/source/jack.html&#34;&gt;Jack&lt;/a&gt; that enables &lt;em&gt;some&lt;/em&gt; of the features of Java 8 maintaining backward compatibility with older OS versions. But still it lets us deal with the verbosity of the language and it doesn’t truly solve the problem.&lt;/p&gt;

&lt;h2 id=&#34;a-new-hope&#34;&gt;A new hope&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/kotlin-intro/kotlin_helloworld.png&#34; alt=&#34;Kotlin Hello World!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Back in 2011 the JetBrains team (the guys behind IntelliJ and so Android Studio) unveiled &lt;a href=&#34;https://kotlinlang.org/&#34;&gt;Kotlin&lt;/a&gt;, a new programming language that targets the JVM (and can also be compiled to JavaScript).
Kotlin is a statically-typed language that combines Object Oriented and functional features enforcing no particular philosophy of programming, and it introduces a whole new set of concepts and tools that helps making the code &lt;strong&gt;safer, cleaner and much more readable&lt;/strong&gt;.
Thanks to its nature it works everywhere Java do and it is also &lt;strong&gt;interoperable&lt;/strong&gt; with it, meaning it will not force you to rewrite the entire codebase to taste it: you can add it to your project a little at a time (&lt;a href=&#34;https://medium.com/@sergii/using-kotlin-for-tests-in-android-6d4a0c818776#.lyvd3h43x&#34;&gt;maybe starting with tests&lt;/a&gt; 😉). It also features a REPL &lt;code&gt;kotlinc-jvm&lt;/code&gt; that allows you to test language features with no effort (see the &lt;a href=&#34;https://kotlinlang.org/docs/tutorials/command-line.html#running-the-repl&#34;&gt;doc&lt;/a&gt; form more info).
I am going to rapidly cover some features of Kotlin that address the previously mentioned Java limitations.&lt;/p&gt;

&lt;h3 id=&#34;null-safety&#34;&gt;Null-safety&lt;/h3&gt;

&lt;p&gt;In Kotlin &lt;strong&gt;a variable cannot be null&lt;/strong&gt;. If you want or need a variable to be &lt;em&gt;nullable&lt;/em&gt; you have to add &lt;code&gt;?&lt;/code&gt; to the variable type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val x: Int = null // compile error
val y: Int? = null // ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to this information the compiler sees &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Int?&lt;/code&gt; as two completely different types and can therefore enforce the &lt;a href=&#34;http://kotlinlang.org/docs/reference/null-safety.html&#34;&gt;null-safety&lt;/a&gt; of your variables.
The &lt;code&gt;?.&lt;/code&gt; allows you to safe call methods on nullable variables without throwing NPE but simply returning null at the end of the  call chain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val x: Int? = null
x?.toString()?.substring(2) // no NPE, returns null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;?:&lt;/code&gt; operator (Elvis operator) allows you to provide a “default” value when the variable is &lt;code&gt;null&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// The two expressions are semantically equivalent:
text?.length ?: -1
(text.length != null) ? text.length  : -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;higher-order-functions-and-lambdas&#34;&gt;Higher-Order Functions and Lambdas&lt;/h3&gt;

&lt;p&gt;In Kotlin is possible to declare a method (or more generally a function) that returns or takes another &lt;strong&gt;function as parameter&lt;/strong&gt;. The syntax to define the &lt;a href=&#34;https://kotlinlang.org/docs/reference/lambdas.html&#34;&gt;function type&lt;/a&gt; is similar to other languages such as Scala or Swift and is very &lt;strong&gt;intuitive&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val function: (T1, T2) -&amp;gt; R = {t1, t2 -&amp;gt; r}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;data-classes&#34;&gt;Data classes&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class City(val name: String, val state: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://kotlinlang.org/docs/reference/data-classes.html&#34;&gt;Data classes&lt;/a&gt; address the verbosity of Java when dealing with classes that have the only purpose to hold data. With a single line you get &lt;code&gt;equals()/hashCode()&lt;/code&gt;, &lt;code&gt;toString()&lt;/code&gt; and getters/setters for free (and if you are a Java developer you already knows the benefits!)&lt;/p&gt;

&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;Java has to maintain backward compatibility with previous versions and still has to support the huge amount of developers and codebases present all around the world; therefore it is natural that every new feature and design change is to be considered, weighted and reasoned really carefully, inevitably &lt;strong&gt;slowing down its evolution&lt;/strong&gt;. But this does not have to mean that us, as Android developers, “tied” to the JVM, should not try more modern and advanced languages such as Kotlin. At bottom, a part of our job (one of the best!) is to try and &lt;strong&gt;experiment&lt;/strong&gt; new technologies and to &lt;strong&gt;learn&lt;/strong&gt; new concepts and techniques that improve our ability to address problems in the best possible way (and of course, to have some fun 😄).&lt;/p&gt;

&lt;p&gt;I think that it is fundamental for a software engineer to be &lt;strong&gt;exposed to more than a single programming language&lt;/strong&gt;: learning new patterns, exploring other programming paradigms or simply using and understanding a never-seen syntax has an immeasurable value for our growth and most of the times it turns out to be unexpectedly useful even when coding with ”our” language.
So why not do it with a language that allows us to continue working on projects targeting our beloved JVM?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Droidcon It 2016</title>
      <link>https://engineering.facile.it/blog/eng/droidcon-it-2016/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/droidcon-it-2016/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/droidconit-recap/logo_droidcon_it.png&#34; alt=&#34;Droidcon It&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The third edition of &lt;a href=&#34;http://it.droidcon.com/2016/&#34;&gt;Droidcon IT&lt;/a&gt; was, as expected, a great conference, full of interesting talks and people coming from all over the world. We saw a lot of GDEs (&lt;a href=&#34;https://developers.google.com/experts/all/technology/android&#34;&gt;Google Developer Expert&lt;/a&gt;) and also some Developer Advocates from Google, although it was not organized directly by the company. Back in March the Android team surprisingly released the brand new &lt;strong&gt;N Developer Preview&lt;/strong&gt; earlier than expected, so this year we were already able to talk about the new features in Android N and analyze them. Furthermore, there was talk of &lt;strong&gt;Kotlin&lt;/strong&gt;, &lt;strong&gt;RxJava&lt;/strong&gt; and a lot of other useful and interesting topics.&lt;/p&gt;

&lt;p&gt;In this post I&amp;rsquo;m going to recap the event and make some considerations about the most interesting (and funny) talks.&lt;/p&gt;

&lt;h1 id=&#34;day-1&#34;&gt;Day 1&lt;/h1&gt;

&lt;h2 id=&#34;keynote-wojtek-kalicinski-https-twitter-com-wkalic&#34;&gt;Keynote - &lt;em&gt;&lt;a href=&#34;https://twitter.com/wkalic&#34;&gt;Wojtek Kalicinski&lt;/a&gt;&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;The day 1 keynote was all about the N Developer Preview and was given by Wojtek Kalicinski, a developer advocate directly from Google.
Wojtek went through all the new improvements of the platform, both from user&amp;rsquo;s and developer&amp;rsquo;s point of view. Here’s a short summary of the most relevant ones:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Multi-window support&lt;/strong&gt;: probably the most requested user feature. I’ve always thought that its implementation would have been relatively straightforward, given the already responsive UI of Android, and in fact the code changes that are needed to support this feature are minimal. Just make sure you don’t lock screen orientation using &lt;code&gt;android:screenOrientation&lt;/code&gt; in your manifest.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better notifications&lt;/strong&gt;: in addition to a visual change of the notification panel, apps will now be able to let the user interact with bundled notifications individually or to reply from the notification itself directly. Moreover, if the app already supports Android Wear notifications, most of this will come for free, since the APIs are the same.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doze improvements&lt;/strong&gt;: the battery saving mode called Doze, now works — in a less aggressive mode — when the phone is in the user pocket or hands, and not only when the phone is stationary. Wojtek said that most of the apps should continue to work without any change — or eventually &lt;a href=&#34;http://developer.android.com/intl/ko/training/monitoring-device-state/doze-standby.html#assessing_your_app&#34;&gt;minimal&lt;/a&gt; —, but he strongly encouraged to test apps against this new feature.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JAVA 8 features!&lt;/strong&gt;: finally Google will allow developers to use a limited set of features from the latest version of the language (already two years old) including &lt;em&gt;lambdas&lt;/em&gt; (🎉) and &lt;em&gt;default and static interface methods&lt;/em&gt; (TODO: add DP2 apis). All of this is possibile thanks to the Jack&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; toolchain which is able to compile Java 8 syntax to Java 6 compatible bytecode: in this way, old phones’ support is guaranteed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other changes include improvements to &lt;a href=&#34;http://developer.android.com/intl/ko/preview/api-overview.html#background_optimizations&#34;&gt;Project Svelte&lt;/a&gt;, a new &lt;a href=&#34;http://developer.android.com/intl/ko/preview/api-overview.html#data_saver&#34;&gt;Data Saver&lt;/a&gt; feature, the addition of the &lt;a href=&#34;http://developer.android.com/intl/ko/preview/api-overview.html#tile_api&#34;&gt;Quick Settings Tile API&lt;/a&gt; and &lt;a href=&#34;http://developer.android.com/intl/ko/preview/api-overview.html&#34;&gt;many more&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The most interesting and encouraging aspect coming out from the keynote and the N Preview release itself, is the fact that Google is, finally, trying to fix the Android updates issue.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/droidconit-recap/n-preview-updates.png&#34; alt=&#34;N Preview Updates&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Not only the release of the new OS preview six months before its public release — instead of three — is really useful for third party developers to update apps to support new APIs, but hopefully it will also help phone manufactures to keep their custom Android implementations more aligned with the stock version release cycle. This will result in a better user experience and, more importantly to us, a better developer experience, making it closer to the iOS world where developers are not required to support five years old OS versions.&lt;/p&gt;

&lt;h2 id=&#34;perfmatters-for-android-hasan-hosgel-https-twitter-com-alosdev&#34;&gt;#PERFMATTERS for Android - &lt;em&gt;&lt;a href=&#34;https://twitter.com/alosdev&#34;&gt;Hasan Hosgel&lt;/a&gt;&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/alosdev/perfmatters-for-android-droidcon-turin-2016&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The talk was all about performance in Android. The speaker analyzed why #&lt;strong&gt;PERFMATTERS&lt;/strong&gt; on Android: the typical mobile user is generally &lt;em&gt;impatient&lt;/em&gt; and &lt;em&gt;intolerant&lt;/em&gt; and even just a couple of extra seconds during the start-up could make the difference in the user&amp;rsquo;s choice to use or not your app. Hasan went through a lot of interesting tips and tricks to improve performance, such as avoiding multi-pass nested layout — a topic discussed in more detail by Huyen Tue Dao during her &lt;a href=&#34;#lean-layouts&#34;&gt;talk&lt;/a&gt; —, avoiding memory leaks or having a cache on disk for data.&lt;/p&gt;

&lt;p&gt;Performance is crucial to &lt;strong&gt;engage the user&lt;/strong&gt; and I think the speaker did a great job in summarizing useful tips to improve it. Moreover most of them doesn’t alter the readability or the maintainability of the code, as is often the case for performance driven code changes.&lt;/p&gt;

&lt;h2 id=&#34;let-it-flow-unidirectional-data-flow-architecture-in-android-benjamin-augustin-https-twitter-com-dorvaryn&#34;&gt;Let it flow! Unidirectional data flow architecture in Android - &lt;a href=&#34;https://twitter.com/dorvaryn&#34;&gt;&lt;em&gt;Benjamin Augustin&lt;/em&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/dorvaryn/let-it-flow&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The use of patterns to structure the presentation layer (UI) in Android is still infrequent. During the last couple of years we have seen a lot of discussions about &lt;strong&gt;MVC&lt;/strong&gt;/&lt;strong&gt;MVP&lt;/strong&gt;/&lt;strong&gt;MVVM&lt;/strong&gt; patterns within the Android developers community, and some implementations of them.
During the talk the speaker presented a new approach that takes some concepts from the web development world like &lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;&lt;em&gt;Flux&lt;/em&gt;&lt;/a&gt; and &lt;a href=&#34;http://redux.js.org&#34;&gt;&lt;em&gt;Redux&lt;/em&gt;&lt;/a&gt;. The concept in a nutshell is that the UI, in addition to being as dumb as possible, should also be &lt;strong&gt;stateless&lt;/strong&gt;. In other words, the UI listens to state changes pushed by the business logic and updates itself accordingly.
Benjamin chose to focus more on the practical aspects and so he made the concept clear by directly building an &lt;a href=&#34;https://github.com/Dorvaryn/unidirectionalDataFlow&#34;&gt;app&lt;/a&gt; using Kotlin and RxJava.&lt;/p&gt;

&lt;p&gt;I personally likey approach that Benjamin showed us, since it has a lot of advantages. It makes the UI state completely &lt;strong&gt;predictable&lt;/strong&gt; and &lt;strong&gt;reproducible&lt;/strong&gt;: it allows us to represent an app state without the need to go through all the steps needed to reach it, thus it can be very useful in reproducing a bug or testing a particular situation. The problem is that, as you can see from the demo app, it adds a lot of boilerplate code and it&amp;rsquo;s also much more verbose and difficult to implement without tools like RxJava or Kotlin, that might be problematic to some.&lt;/p&gt;

&lt;h2 id=&#34;play-everywhere-providing-a-consistent-experience-across-very-different-devices-alessandro-bizzarri-http-it-droidcon-com-2016-speakers-alessandro-bizzarri-dima-kunin-http-it-droidcon-com-2016-speakers-dima-kunin&#34;&gt;Play everywhere: providing a consistent experience across very different devices - &lt;a href=&#34;http://it.droidcon.com/2016/speakers/alessandro-bizzarri/&#34;&gt;&lt;em&gt;Alessandro Bizzarri&lt;/em&gt;&lt;/a&gt; &amp;amp; &lt;a href=&#34;http://it.droidcon.com/2016/speakers/dima-kunin/&#34;&gt;&lt;em&gt;Dima Kunin&lt;/em&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The two speakers showed a high-level tour of how at &lt;strong&gt;Spotify&lt;/strong&gt; they  are able to provide a consistent experience across different devices — defined as the combination of its physical form and its OS.
They created their own &lt;strong&gt;design language&lt;/strong&gt; to support the majority of platforms used to define almost everything, from color palette and buttons style to animations and sounds.
They explained also how they use a &lt;strong&gt;C++ library&lt;/strong&gt; common to all platforms to reuse code; in particular on Android they use it through the NDK, a toolset to include C or C++ code in your app and call it from Java code.&lt;/p&gt;

&lt;p&gt;It was a light talk but still it was interesting to see how a big company like Spotify finds solutions to scale and maintain a &lt;strong&gt;consistent and engaging UX&lt;/strong&gt; across all of its user-base.&lt;/p&gt;

&lt;h2 id=&#34;loving-lean-layouts-huyen-tue-dao-https-twitter-com-queencodemonkey-a-name-lean-layouts-a&#34;&gt;Loving lean layouts - &lt;a href=&#34;https://twitter.com/queencodemonkey&#34;&gt;&lt;em&gt;Huyen Tue Dao&lt;/em&gt;&lt;/a&gt; &lt;a name=&#34;lean-layouts&#34;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/queencodemonkey/droidcon-italy-2016-loving-lean-layouts&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The speaker gave a really great talk about one of the best ways to keep an app smooth and responsive: &lt;strong&gt;optimize layouts&lt;/strong&gt; to be as flat as possible. The Android UI layer will call &lt;code&gt;measure()&lt;/code&gt; and    &lt;code&gt;layout()&lt;/code&gt; methods — two times in the case of &lt;code&gt;RelativeLayout&lt;/code&gt; — through all the hierarchy of views to be able to draw the layout; so, for example, having a useless root level  or useless views will result in more measure/layout passes, thus poor performance. Huyen explained how sometimes the solution to this problem may be to choose the right view or layout, but it could be useful to know that there is always the possibility to implement a custom &lt;code&gt;ViewGroup&lt;/code&gt; to mitigate the number of measure/layout passes or even a totally custom &lt;code&gt;View&lt;/code&gt; that overrides &lt;code&gt;onDraw()&lt;/code&gt; to draw everything by hand.&lt;/p&gt;

&lt;p&gt;The talk was very easy to follow and really useful: most of the advices covered are often ignored because singularly they have less impact, but, if taken all together and especially as good habits, they could really make the difference in maintain the &lt;strong&gt;UI smooth and lag-free&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;day-2&#34;&gt;Day 2&lt;/h1&gt;

&lt;h2 id=&#34;android-reactive-programming-with-rxjava-ivan-morgillo-https-twitter-com-hamen&#34;&gt;Android reactive programming with RxJava - &lt;a href=&#34;https://twitter.com/hamen&#34;&gt;&lt;em&gt;Ivan Morgillo&lt;/em&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;During last couple of years RxJava has been echoing all over the Android developers community and given its huge popularity I was surprised to see that Droidcon IT offered only one talk about it.&lt;/p&gt;

&lt;p&gt;Fortunately Ivan Morgillo is a topic expert — he also wrote a &lt;a href=&#34;https://www.packtpub.com/application-development/rxjava-essentials&#34;&gt;book&lt;/a&gt; about RxJava and Android — and during the talk he went through some of the &lt;strong&gt;basics of reactive programming&lt;/strong&gt; (&lt;code&gt;Observables&lt;/code&gt;, &lt;code&gt;Observer&lt;/code&gt;, &lt;code&gt;Subscription&lt;/code&gt;…) and a lot of useful &lt;strong&gt;operators&lt;/strong&gt;, which are one of the strengths of RxJava and Reactive extensions (Rx*) in general.&lt;/p&gt;

&lt;p&gt;To be honest I was hoping for a more theoretical talk with an analysis of the advantages and disadvantages of embracing the reactive pattern in our Android projects. It was instead a lot practical and it covered a great number of common use cases where reactive programming could really help to make code mode readable and maintainable.&lt;/p&gt;

&lt;h2 id=&#34;you-can-do-better-with-kotlin-svetlana-isakova-https-github-com-svtk&#34;&gt;You can do better with Kotlin - &lt;a href=&#34;https://github.com/svtk&#34;&gt;&lt;em&gt;Svetlana Isakova&lt;/em&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/svtk/you-can-do-better-with-kotlin&#34;&gt;Slides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kotlin has recently reached &lt;a href=&#34;https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/&#34;&gt;&lt;strong&gt;1.0 version&lt;/strong&gt;&lt;/a&gt; and it is gaining a lot of attention within the Java community and especially the Android one. A lot of developers — me included — are in fact hoping that Google will make it the default programming language for its mobile OS.&lt;/p&gt;

&lt;p&gt;Kotlin is a &lt;strong&gt;modern&lt;/strong&gt;, &lt;strong&gt;pragmatic&lt;/strong&gt; and &lt;strong&gt;Android-friendly&lt;/strong&gt; programming language, with robust supporting tools since it is developed from the people behind IntelliJ (thus, Android Studio). It could be mixed with Java code — thus making the switch painless — since there is no Kotlin SDK but just JDK plus extensions, and it includes a lot of modern concept such as &lt;em&gt;data classes&lt;/em&gt;, &lt;em&gt;null-safety&lt;/em&gt;, &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;lambdas&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The speaker showed also ANKO, a DSL written in Kotlin, that uses &lt;em&gt;lambdas with receivers&lt;/em&gt;, to create layouts and views and allows to write code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;verticalLayout {
    val name = editText()
    button(&amp;quot;Say Hello&amp;quot;) {
        onClick { toast(&amp;quot;Hello, ${name.text}!&amp;quot;) }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This talk was one of the most interesting to me, as it persuaded me to try and deepen my knowledge of Kotlin. Svetlana was very good at showing the main features of the JetBrains language and at explaining how they convert in Java code, an aspect that I found very useful to mutate my mindset with new concepts and  syntaxes.&lt;/p&gt;

&lt;h2 id=&#34;fun-things-you-cando-in-kotlin-maciej-górski-https-github-com-mg6maciej&#34;&gt;fun things (you: CanDo &lt;in Kotlin&gt; ) = … - &lt;a href=&#34;https://github.com/mg6maciej&#34;&gt;&lt;em&gt;Maciej Górski&lt;/em&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mg6maciej/fun-things-you-CanDo-in-Kotlin&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The second Droidcon talk about Kotlin was a very fun one, with the speaker acting a funny scene where a nephew tries to explain to his granpa why he should use &lt;strong&gt;Kotlin instead of Java&lt;/strong&gt; with a live coding session.&lt;/p&gt;

&lt;p&gt;&lt;style&gt;.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }&lt;/style&gt;&lt;div class=&#39;embed-container&#39;&gt;&lt;iframe src=&#39;https://www.youtube.com/embed/RVu_0TIiH8Q&#39; frameborder=&#39;0&#39; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;The second part of the talk was still in live programming (without slides) and showed some Kotlin feature in practice. It covered some advanced topics such as functional programming, operator overloading, infix functions, laziness and more.&lt;/p&gt;

&lt;p&gt;It was funny and informative to watch a &lt;strong&gt;live coding talk&lt;/strong&gt; and for sure it made me more curious and confident about Kotlin.&lt;/p&gt;

&lt;h1 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;The Droidcon IT is already, after three editions, the &lt;strong&gt;point of reference&lt;/strong&gt; for the Android community in Italy and this year too it lived up to the expectations. We saw a lot of well-known speakers and developers such as the Googlers Nick Butcher and  Wojtek Kaliciński. It was a conference rich of interesting talks in addition to those summarized in this post, ranging between al lot of various topics such as TDD, UX, tools and many more. The only thing that surprised me was the lack of talks about Android Wear: perhaps Google is slowing down to push this platform among developers?&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://source.android.com/source/jack.html&#34;&gt;Jack&lt;/a&gt; is the new Google compiler which has the goal to speed up the compilation process, compiling Java .class files directly to .dex files (Android bytecode)
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>