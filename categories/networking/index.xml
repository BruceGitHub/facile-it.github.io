<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Networking on Facile.it Engineering</title>
    <link>http://engineering.facile.it/categories/networking/</link>
    <description>Recent content in Networking on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 May 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://engineering.facile.it/categories/networking/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Faster Web with HTTP/2</title>
      <link>http://engineering.facile.it/blog/eng/faster-web-with-http-2/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/eng/faster-web-with-http-2/</guid>
      <description>

&lt;p&gt;HTTP is the protocol that powers the Web. It was originally designed in 1996 for transferring and manipulating simple text-based documents (mainly hypertext resources).
Nowadays it&amp;rsquo;s been adopted for many different purposes. It&amp;rsquo;s used for: multimedia content transfer, rich real-time session-based web applications, API messages dispatch, Internet of Things and much more.
For this reason, the HTTP specifications are continuously updated, by adding new features and improving performance.&lt;/p&gt;

&lt;p&gt;In May 2015, the latest version 2.0 was standardized with &lt;em&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7540&#34;&gt;RFC 7540&lt;/a&gt;&lt;/em&gt;.
This introduced major differences on how the low-level protocol works.
From the application perspective, very little has changed: requests, responses, resources, headers and HTTP methods are still there.
New features have been added such as the possibility to &lt;strong&gt;push resources to the client&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The main reason that led to HTTP/2 is &lt;strong&gt;improving performance&lt;/strong&gt;.
Previous versions of HTTP had critical problems that were not addressable without changing the low-level communication mechanisms.&lt;/p&gt;

&lt;h2 id=&#34;http-1-1-issues:cd7d608f5e6f553a5281263d75f1bec2&#34;&gt;HTTP/1.1 issues&lt;/h2&gt;

&lt;p&gt;HTTP/2 deals with many of the performance issues of HTTP/1.1:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/1.1 doesn&amp;rsquo;t support headers compression even though it would be particularly effective against text-based data;&lt;/li&gt;
&lt;li&gt;HTTP/1.1 &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_pipelining&#34;&gt;request pipelining&lt;/a&gt; is not so efficient due to &lt;a href=&#34;https://en.wikipedia.org/wiki/Head-of-line_blocking&#34;&gt;head-of-line blocking&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Modern web applications have complex resources that are linked to each other. HTTP/1.1 servers have no way to send all the related resources at once in order to avoid additional round-trips;&lt;/li&gt;
&lt;li&gt;HTTP/1.1 connections are designed to have short lifespans. Unfortunately, web resources change over time and additional connections are required to fetch the updated data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;People have adopted several tricks to mitigate these problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Session data is usually persisted on the server to minimize the amount of headers sent at every request;&lt;/li&gt;
&lt;li&gt;To reduce latency and to achieve request multiplexing, browsers open several TCP connections during page load. This is not recommended: it consumes many more resources (both client-side and server-side) and &lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_congestion_control&#34;&gt;TCP congestion avoidance&lt;/a&gt; techniques are no longer effective;&lt;/li&gt;
&lt;li&gt;Recent web applications prefer leaving connections open to reduce connection setup latency for subsequent requests;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-s-changed:cd7d608f5e6f553a5281263d75f1bec2&#34;&gt;What&amp;rsquo;s changed&lt;/h2&gt;

&lt;p&gt;HTTP/2 is &lt;strong&gt;no longer text-based&lt;/strong&gt;; this means debugging could be somewhat difficult without using special tools.&lt;/p&gt;

&lt;p&gt;Server and client communicate by sending small binary messages named &lt;strong&gt;Frames&lt;/strong&gt;.
There are different types of frames. The most important ones are &lt;code&gt;DATA&lt;/code&gt;, &lt;code&gt;HEADERS&lt;/code&gt;, &lt;code&gt;SETTINGS&lt;/code&gt; and &lt;code&gt;PUSH_PROMISE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;HTTP/2 uses the concept of &lt;strong&gt;streams&lt;/strong&gt;. Each stream is identified by an ID and it&amp;rsquo;s allocated for every request/response lifecycle.
Several streams can be active at the same time on the same connection: this provides &lt;strong&gt;real request pipelining and multiplexing&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Each frame contains the ID of the stream they refer to. Thus, frames of different streams can be interleaved without interfering.&lt;/p&gt;

&lt;p&gt;Servers, by sending the &lt;code&gt;PUSH_PROMISE&lt;/code&gt; frame, can allocate new streams without waiting for an explicit request from the client. By the virtue of this, &lt;strong&gt;the server can push resources to the client&lt;/strong&gt; and reduce the number of round-trip messages needed.&lt;/p&gt;

&lt;p&gt;Http headers (both requests&amp;rsquo; and responses&amp;rsquo; ones) are always compressed and they are sent using one or more &lt;code&gt;HEADERS&lt;/code&gt; frames.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1&#34;&gt;Response Status-Line&lt;/a&gt;&lt;/em&gt; and &lt;em&gt;&lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1&#34;&gt;request Request-Line&lt;/a&gt;&lt;/em&gt; have been moved. They are now stored in the header section via special headers (pseudo-headers): &lt;code&gt;:method&lt;/code&gt;, &lt;code&gt;:path&lt;/code&gt;, &lt;code&gt;:status&lt;/code&gt;, etc..&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Response Status-Line Reason-Phrase&lt;/em&gt; has been completely removed: there is no equivalent in HTTP/2.&lt;/p&gt;

&lt;p&gt;Servers and clients may use &lt;code&gt;PING&lt;/code&gt; frames to check the underlying connection&amp;rsquo;s state and to keep the connection alive even for a long period of time.&lt;/p&gt;

&lt;h2 id=&#34;support-by-servers-and-user-agents:cd7d608f5e6f553a5281263d75f1bec2&#34;&gt;Support by servers and user agents&lt;/h2&gt;

&lt;p&gt;HTTP/2 is actually a fork of &lt;a href=&#34;http://dev.chromium.org/spdy/spdy-whitepaper&#34;&gt;SPDY&lt;/a&gt;, a protocol developed by Google.
A lot of different servers and clients already supported the SPDY protocol, so the transition from SPDY to HTTP/2 was pretty straightforward.&lt;/p&gt;

&lt;p&gt;HTTP/2 was officially released in May 2015; since then &lt;strong&gt;all major web servers have added support for HTTP/2&lt;/strong&gt; such as Apache HTTP, Apache Tomcat, Nginx, IIS and Jetty.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;All major browsers now support HTTP/2&lt;/strong&gt;, e.g. Firefox, Chrome, IE and Edge.&lt;/p&gt;

&lt;p&gt;A the moment, they only allow HTTP/2 over TLS via &lt;a href=&#34;https://tools.ietf.org/html/rfc7301&#34;&gt;ALPN&lt;/a&gt; or &lt;a href=&#34;https://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04&#34;&gt;NPN&lt;/a&gt; as Protocol Negotiation mechanisms.
RFC 7540 considers the case of HTTP/2 being used on cleartext connections as well, but actually this is not extensively used.&lt;/p&gt;

&lt;h2 id=&#34;additional-resources:cd7d608f5e6f553a5281263d75f1bec2&#34;&gt;Additional resources&lt;/h2&gt;

&lt;p&gt;The website &lt;a href=&#34;http://www.http2demo.io/&#34;&gt;Http2demo.io&lt;/a&gt; compares performance metrics between HTTP/1.1 and HTTP/2.&lt;/p&gt;

&lt;p&gt;If you want to learn more about HTTP/2, you can read the official specifications (&lt;strong&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7540&#34;&gt;RFC 7540&lt;/a&gt;&lt;/strong&gt;) or download the book &lt;strong&gt;&lt;a href=&#34;https://daniel.haxx.se/http2/&#34;&gt;Http2 explained&lt;/a&gt;&lt;/strong&gt; which also examines the reasons behind HTTP/2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WAMP, Web Application Messaging Protocol.. e PHP!</title>
      <link>http://engineering.facile.it/blog/ita/wamp-web-application-messaging-protocol-e-php/</link>
      <pubDate>Mon, 28 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/wamp-web-application-messaging-protocol-e-php/</guid>
      <description>

&lt;p&gt;Dalle notifiche di Facebook ad un tweet stream, da Google Docs ai giochi multiplayer in HTML5, la necessità di uno &lt;strong&gt;scambio dati&lt;/strong&gt; in &lt;strong&gt;due direzioni&lt;/strong&gt;, &lt;strong&gt;efficiente&lt;/strong&gt; e a &lt;strong&gt;bassa latenza&lt;/strong&gt;, ha determinato l’ascesa negli ultimi anni di &lt;strong&gt;soluzioni basate su &lt;a href=&#34;https://www.websocket.org/&#34; target=&#34;_blank&#34;&gt;WebSocket&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Internet delle cose e web 2.0 trovano oramai sempre &lt;strong&gt;meno spazio&lt;/strong&gt; all’interno del protocollo &lt;strong&gt;HTTP/1&lt;/strong&gt;. Le tecniche di &lt;strong&gt;polling e long polling&lt;/strong&gt;, in voga fino a pochi anni fa, non permettevano di trasmettere in &lt;a href=&#34;https://it.wikipedia.org/wiki/Duplex&#34; target=&#34;_blank&#34;&gt;full duplex&lt;/a&gt; (tra server e client) contemporaneamente, erano costrette ad un alto overhead HTTP e richiedevano &lt;strong&gt;diversi sforzi&lt;/strong&gt; per simulare notifiche push server side.&lt;/p&gt;

&lt;h2 id=&#34;il-protocollo-wamp:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;Il protocollo WAMP&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://wamp.ws/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;WAMP&lt;/strong&gt;&lt;/a&gt; (Web Application Messaging Protocol e non Windows, Apache, etc.!) offre un moderno &lt;strong&gt;pattern di messaggistica&lt;/strong&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Remote_procedure_call&#34; target=&#34;_blank&#34;&gt;RPC&lt;/a&gt; e &lt;a href=&#34;https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern&#34; target=&#34;_blank&#34;&gt;Pub/Sub&lt;/a&gt; in maniera unificata. Registrato presso lo &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority&#34; target=&#34;_blank&#34;&gt;IANA&lt;/a&gt; come sottoprotocollo WebSocket, definisce uno &lt;strong&gt;standard aperto&lt;/strong&gt; per lo scambio di &lt;strong&gt;messaggi in tempo reale&lt;/strong&gt; tra applicazioni e componenti, e permette la creazione di architetture &lt;strong&gt;debolmente accoppiate&lt;/strong&gt; basate su &lt;strong&gt;microservizi&lt;/strong&gt;. Utilizza canali full-duplex ordinati ed è quindi adatto ad implementazioni basate su WebSocket, ma supporta allo stesso modo socket Unix, socket raw o long polling HTTP.&lt;/p&gt;

&lt;p&gt;Il protocollo risulta piuttosto &lt;strong&gt;completo ed adeguato&lt;/strong&gt; a diversi scenari di utilizzo se comparato ad altri sistemi di messaggistica ed RPC.&lt;/p&gt;

&lt;p&gt;&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;Technology&lt;/th&gt;
&lt;th&gt;PubSub&lt;/th&gt;
&lt;th&gt;RPC&lt;/th&gt;
&lt;th&gt;Routed RPC&lt;/th&gt;
&lt;th&gt;Web native&lt;/th&gt;
&lt;th&gt;Cross Language&lt;/th&gt;
&lt;th&gt;Open Standard&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WAMP&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AJAX&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMQP&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REST&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SOAP&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Socket.io&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SockJS&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XMPP&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZeroMQ&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;em&gt;fonte: Wikipedia&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Può essere utilizzato con profitto per sviluppare una piattaforma di gioco &lt;strong&gt;online multiplayer&lt;/strong&gt;, strumenti di &lt;strong&gt;business intelligence&lt;/strong&gt; real time e &lt;strong&gt;piattaforme collaborative&lt;/strong&gt; per numerosi utenti.&lt;/p&gt;

&lt;p&gt;Una piattaforma web di help desk ad esempio, può beneficiare di notifiche, chat, strumenti di scrittura multi-utente ed analisi dell’andamento in tempo reale  &lt;strong&gt;sullo stesso protocollo WAMP&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Per funzionare WAMP necessità di uno o più server di &lt;strong&gt;routing centralizzati&lt;/strong&gt;, allo stesso modo di &lt;strong&gt;RabbitMQ per AMQP&lt;/strong&gt;.
Per quanto esistano diverse implementazioni di router, in diversi linguaggi, lo standard &lt;em&gt;de facto&lt;/em&gt; è rappresentato da &lt;a href=&#34;http://crossbar.io/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Crossbar&lt;/strong&gt;&lt;/a&gt;, sviluppato da &lt;a href=&#34;http://tavendo.com/&#34; target=&#34;_blank&#34;&gt;Tavendo&lt;/a&gt;, alla quale si deve anche la &lt;strong&gt;definizione del protocollo&lt;/strong&gt; stesso.&lt;/p&gt;

&lt;h2 id=&#34;crossbar:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;Crossbar&lt;/h2&gt;

&lt;p&gt;Crossbar, scritto in python (&lt;a href=&#34;https://github.com/crossbario/crossbar&#34; target=&#34;_blank&#34;&gt;open source&lt;/a&gt;, licenza AGPL v3), supporta completamente le funzionalità descritte dal protocollo oltre a vantare &lt;strong&gt;configurazioni avanzate&lt;/strong&gt; come ad esempio le subscriptions &lt;a href=&#34;http://crossbar.io/docs/Pattern-Based-Subscriptions/&#34; target=&#34;_blank&#34;&gt;basate su pattern&lt;/a&gt;, le &lt;a href=&#34;http://crossbar.io/docs/Progressive-Call-Results/&#34; target=&#34;_blank&#34;&gt;progressive result&lt;/a&gt; su RPC e profili di autenticazione ed &lt;a href=&#34;http://crossbar.io/docs/Authorization/&#34; target=&#34;_blank&#34;&gt;autorizzazione&lt;/a&gt; dinamici.&lt;/p&gt;

&lt;p&gt;Nessuna delle altre implementazioni è poi al momento in grado di vantare le stesse &lt;strong&gt;prestazioni&lt;/strong&gt; e la &lt;strong&gt;stabilità&lt;/strong&gt; di Crossbar: una istanza del router è in grado di servire 1000 messaggi/secondo su Pub/Sub, a 1000 client, con una &lt;strong&gt;latenza di 25ms&lt;/strong&gt; su una &lt;strong&gt;RaspberryPi&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th&gt;Router&lt;/th&gt;
&lt;th&gt;Broker&lt;/th&gt;
&lt;th&gt;Dealer&lt;/th&gt;
&lt;th&gt;Advanced Profile&lt;/th&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Crossbar&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;Pyhton&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Thruway&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wamp.rt&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;NodeJS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jawampa&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WampSharp&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Erwa&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Erlang&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;em&gt;fonte: WAMP.ws&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;e-php:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;..e PHP?&lt;/h2&gt;

&lt;p&gt;Diverse applicazioni web di backend usate presso Facile.it permettono ad un gran numero di operatori di lavorare sulle stesse pratiche in maniera collaborativa in &lt;strong&gt;tempo reale&lt;/strong&gt;.
Il protocollo WAMP è una tecnologia sulla quale è possibile sviluppare in maniera efficiente &lt;strong&gt;dashboard collaborative&lt;/strong&gt; e realtime.. ma sarà anche in grado di funzionare adeguatamente assieme alle soluzioni PHP (spesso in Symfony 2) sviluppate in casa e &lt;strong&gt;non precedentemente disegnate per l&amp;rsquo;uso con WebSocket&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;Esistono diverse librerie (come &lt;a href=&#34;https://github.com/voryx/Thruway&#34; target=&#34;_blank&#34;&gt;Thruway&lt;/a&gt;) che permettono di operare come &lt;strong&gt;client PHP&lt;/strong&gt; in ambiente WAMP, ma per &lt;strong&gt;semplificare&lt;/strong&gt; l&amp;rsquo;integrazione del protocollo con altri servizi, Crossbar supporta il &lt;a href=&#34;http://crossbar.io/docs/HTTP-Bridge-Services/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;bridge HTTP&lt;/strong&gt;&lt;/a&gt; delle funzionalità Pub/Sub e RPC.&lt;/p&gt;

&lt;p&gt;In pratica, parlando ad esempio di Pub/Sub, è possibile &lt;strong&gt;pubblicare via HTTP&lt;/strong&gt; (o HTTPS) su Crossbar messaggi che saranno inoltrati su topic ai &lt;strong&gt;client connessi via WebSocket&lt;/strong&gt; in maniera trasparente. Altresì è possibile &lt;strong&gt;iscriversi ai topic&lt;/strong&gt; fornendo un &lt;strong&gt;endpoint HTTP&lt;/strong&gt; da chiamare per ricevere i messaggi pubblicati da client WebSocket.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;esempio sottostante configura un router Crossbar in grado di accettare connessioni websocket, pubblicazioni via HTTP e che si occupa di forwardare alcuni messaggi ad un endpoint HTTPS:&lt;/p&gt;

&lt;p&gt;&lt;style type=&#34;text/css&#34;&gt;
  .gist-file
  .gist-data {max-height: 500px;}
&lt;/style&gt;
&lt;script src=&#34;https://gist.github.com/peelandsee/51417b3c7c1dc400e85f.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Il gist precedente può essere lanciato al volo con &lt;a href=&#34;https://docs.docker.com/&#34; target=&#34;_blank&#34;&gt;docker&lt;/a&gt;:
&lt;code&gt;docker run -p 80:80 -p 8080:8080 -v $PWD/crossbar-config.json:/.crossbar/config.json vinelab/crossbar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ovviamente l&amp;rsquo;esempio non tiene conto di profili di configurazione più avanzati, come &lt;strong&gt;cifratura TLS&lt;/strong&gt;, autenticazione, ruoli separati di pubblicazione e/o iscrizione, disponibili nella documentazione di Crossbar.&lt;/p&gt;

&lt;p&gt;Features come la firma delle richieste HTTP, richiedono più di qualche minuto di sviluppo, ma sono indispensabili in un &lt;strong&gt;ambiente di produzione&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Per semplificare l&amp;rsquo;adozione del bridge HTTP in &lt;strong&gt;ambito PHP&lt;/strong&gt;, in Facile.it abbiamo sviluppato e rilasciato un &lt;strong&gt;bundle&lt;/strong&gt; che permette la configurazione automatica di &lt;strong&gt;servizi di Publisher WAMP nel service container&lt;/strong&gt; di Symfony 2.&lt;/p&gt;

&lt;p&gt;Il bundle, disponibile su &lt;a href=&#34;https://packagist.org/packages/facile-it/crossbar-http-publisher-bundle&#34; target=&#34;_blank&#34;&gt;Packagist (composer)&lt;/a&gt; può essere installato con
&lt;code&gt;$ composer require facile-it/crossbar-http-publisher-bundle dev-master&lt;/code&gt;
e richiede una &lt;strong&gt;configurazione rapida&lt;/strong&gt; ed intuitiva:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;facile_crossbar_http_publisher:
  connections:
    foo_publisher_1:
        protocol: http
        host: 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;uso è molto semplice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// recupero del servizio
$fooPublisher = $container
                -&amp;gt;get(&#39;facile.crossbar.publisher.foo_publisher_1&#39;);

$topic = &#39;com.myapp.hello&#39;;

// pubblicazione
$firstPublisher-&amp;gt;publish($topic, [&#39;foo&#39;,1]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con le poche righe sopra riportate, attraverso il metodo &lt;code&gt;publish()&lt;/code&gt; viene effettuata una &lt;strong&gt;chiamata HTTP POST&lt;/strong&gt; verso il router WAMP, ed il messaggio &lt;code&gt;[&#39;foo&#39;,1]&lt;/code&gt; raggiunge in tempo (quasi) reale tutti i client (ad esempio &lt;strong&gt;tutti i browser degli utenti&lt;/strong&gt;) iscritti al topic &lt;code&gt;com.myapp.hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Anche in questo caso, la &lt;a href=&#34;http://crossbar.io/docs/Processes/&#34; target=&#34;_blank&#34;&gt;configurazione&lt;/a&gt; può supportare diversi host, porte, uso TLS, signed request, e attraverso GitHub è possibile trovare &lt;a href=&#34;https://github.com/crossbario/crossbarexamples&#34; target=&#34;_blank&#34;&gt;diversi esempi&lt;/a&gt; di &lt;strong&gt;possibili configurazioni&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;ma-i-miei-utenti-lo-supporteranno:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;..ma i miei utenti lo supporteranno?&lt;/h2&gt;

&lt;p&gt;Lato browser, passare a WAMP è davvero &lt;strong&gt;semplice&lt;/strong&gt;:
la libreria &lt;a href=&#34;http://autobahn.ws/js/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Autobahn|JS&lt;/strong&gt;&lt;/a&gt; garantisce piena &lt;strong&gt;compatibilità&lt;/strong&gt; anche per &lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34;&gt;node.js&lt;/a&gt;, supporta l&amp;rsquo;autenticazione, ed è in grado di gestire in maniera &lt;strong&gt;asincronia&lt;/strong&gt; sia RPC che Pub/Sub.&lt;/p&gt;

&lt;p&gt;Qualora il browser di un vostro utente non supportasse WebSocket (e &lt;a href=&#34;http://caniuse.com/#feat=websockets&#34; target=&#34;_blank&#34;&gt;dovrebbe&lt;/a&gt; oramai!), Autobahn|JS è in grado di fornire un &lt;strong&gt;fallback automatico&lt;/strong&gt; a long polling.&lt;/p&gt;

&lt;p&gt;Iscriversi ad un topic o pubblicare un messaggio richiede poche linee:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/peelandsee/c853bc3fd3971e78527c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Nell&amp;rsquo;esempio sopra riportato, il client JS &lt;strong&gt;si iscrive&lt;/strong&gt; al topic &lt;code&gt;com.myapp.hello&lt;/code&gt; e passa i messaggi ricevuti ad una semplice funzione &lt;code&gt;console.log()&lt;/code&gt;; inoltre &lt;strong&gt;pubblica un messaggio&lt;/strong&gt; sul topic &lt;code&gt;com.myapp.topic1&lt;/code&gt;. Quest&amp;rsquo;ultimo, sarà anche &lt;strong&gt;forwardato da Crossbar sul nostro endpoint HTTPS&lt;/strong&gt; &lt;code&gt;https://hostname/subscriptions&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Grazie alle &lt;strong&gt;funzionalità HTTP bridge&lt;/strong&gt; di Crossabar l&amp;rsquo;utilizzo di WAMP in ambito PHP, senza connessioni persistenti o consumer sempre accesi, è &lt;strong&gt;semplice ed immediato&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Per un ulteriore &lt;strong&gt;approfondimento su WAMP&lt;/strong&gt;, saranno inoltre utili le slide che seguono:&lt;/p&gt;

&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/MEmo82CFgt1xND&#34; width=&#34;700&#34; height=&#34;550&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;riferimenti:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;Riferimenti&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wamp.ws/&#34;&gt;WAMP Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://crossbar.io/docs/TOC/&#34;&gt;Crossbar - Documentazione&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://crossbar.io/docs/HTTP-Bridge-Services/&#34;&gt;Crossbar - HTTP Bridge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://autobahn.ws/js/&#34;&gt;Autobahn|JS - Documentazione&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/facile-it/crossbar-http-publisher-bundle&#34;&gt;Facile.it CrossbarHTTPPublisherBundle - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>